<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unicity WEB GUI Wallet</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <!-- 
    Library: CryptoJS v4.1.1
    Description: JavaScript library of crypto standards
    Source: https://github.com/brix/crypto-js
    License: MIT License
    Downloaded from: https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js
    Last verified: April 23, 2025
    -->
    <script>
        !function(t,e){"object"==typeof exports?module.exports=exports=e():"function"==typeof define&&define.amd?define([],e):t.CryptoJS=e()}(this,function(){var n,o,s,a,h,t,e,l,r,i,c,f,d,u,p,S,x,b,A,H,z,_,v,g,y,B,w,k,m,C,D,E,R,M,F,P,W,O,I,U=U||function(h){var i;if("undefined"!=typeof window&&window.crypto&&(i=window.crypto),"undefined"!=typeof self&&self.crypto&&(i=self.crypto),!(i=!(i=!(i="undefined"!=typeof globalThis&&globalThis.crypto?globalThis.crypto:i)&&"undefined"!=typeof window&&window.msCrypto?window.msCrypto:i)&&"undefined"!=typeof global&&global.crypto?global.crypto:i)&&"function"==typeof require)try{i=require("crypto")}catch(t){}var r=Object.create||function(t){return e.prototype=t,t=new e,e.prototype=null,t};function e(){}var t={},n=t.lib={},o=n.Base={extend:function(t){var e=r(this);return t&&e.mixIn(t),e.hasOwnProperty("init")&&this.init!==e.init||(e.init=function(){e.$super.init.apply(this,arguments)}),(e.init.prototype=e).$super=this,e},create:function(){var t=this.extend();return t.init.apply(t,arguments),t},init:function(){},mixIn:function(t){for(var e in t)t.hasOwnProperty(e)&&(this[e]=t[e]);t.hasOwnProperty("toString")&&(this.toString=t.toString)},clone:function(){return this.init.prototype.extend(this)}},l=n.WordArray=o.extend({init:function(t,e){t=this.words=t||[],this.sigBytes=null!=e?e:4*t.length},toString:function(t){return(t||c).stringify(this)},concat:function(t){var e=this.words,r=t.words,i=this.sigBytes,n=t.sigBytes;if(this.clamp(),i%4)for(var o=0;o<n;o++){var s=r[o>>>2]>>>24-o%4*8&255;e[i+o>>>2]|=s<<24-(i+o)%4*8}else for(var c=0;c<n;c+=4)e[i+c>>>2]=r[c>>>2];return this.sigBytes+=n,this},clamp:function(){var t=this.words,e=this.sigBytes;t[e>>>2]&=4294967295<<32-e%4*8,t.length=h.ceil(e/4)},clone:function(){var t=o.clone.call(this);return t.words=this.words.slice(0),t},random:function(t){for(var e=[],r=0;r<t;r+=4)e.push(function(){if(i){if("function"==typeof i.getRandomValues)try{return i.getRandomValues(new Uint32Array(1))[0]}catch(t){}if("function"==typeof i.randomBytes)try{return i.randomBytes(4).readInt32LE()}catch(t){}}throw new Error("Native crypto module could not be used to get secure random number.")}());return new l.init(e,t)}}),s=t.enc={},c=s.Hex={stringify:function(t){for(var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n++){var o=e[n>>>2]>>>24-n%4*8&255;i.push((o>>>4).toString(16)),i.push((15&o).toString(16))}return i.join("")},parse:function(t){for(var e=t.length,r=[],i=0;i<e;i+=2)r[i>>>3]|=parseInt(t.substr(i,2),16)<<24-i%8*4;return new l.init(r,e/2)}},a=s.Latin1={stringify:function(t){for(var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n++){var o=e[n>>>2]>>>24-n%4*8&255;i.push(String.fromCharCode(o))}return i.join("")},parse:function(t){for(var e=t.length,r=[],i=0;i<e;i++)r[i>>>2]|=(255&t.charCodeAt(i))<<24-i%4*8;return new l.init(r,e)}},f=s.Utf8={stringify:function(t){try{return decodeURIComponent(escape(a.stringify(t)))}catch(t){throw new Error("Malformed UTF-8 data")}},parse:function(t){return a.parse(unescape(encodeURIComponent(t)))}},d=n.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new l.init,this._nDataBytes=0},_append:function(t){"string"==typeof t&&(t=f.parse(t)),this._data.concat(t),this._nDataBytes+=t.sigBytes},_process:function(t){var e,r=this._data,i=r.words,n=r.sigBytes,o=this.blockSize,s=n/(4*o),c=(s=t?h.ceil(s):h.max((0|s)-this._minBufferSize,0))*o,n=h.min(4*c,n);if(c){for(var a=0;a<c;a+=o)this._doProcessBlock(i,a);e=i.splice(0,c),r.sigBytes-=n}return new l.init(e,n)},clone:function(){var t=o.clone.call(this);return t._data=this._data.clone(),t},_minBufferSize:0}),u=(n.Hasher=d.extend({cfg:o.extend(),init:function(t){this.cfg=this.cfg.extend(t),this.reset()},reset:function(){d.reset.call(this),this._doReset()},update:function(t){return this._append(t),this._process(),this},finalize:function(t){return t&&this._append(t),this._doFinalize()},blockSize:16,_createHelper:function(r){return function(t,e){return new r.init(e).finalize(t)}},_createHmacHelper:function(r){return function(t,e){return new u.HMAC.init(r,e).finalize(t)}}}),t.algo={});return t}(Math);function K(t,e,r){return t&e|~t&r}function X(t,e,r){return t&r|e&~r}function L(t,e){return t<<e|t>>>32-e}function j(t,e,r,i){var n,o=this._iv;o?(n=o.slice(0),this._iv=void 0):n=this._prevBlock,i.encryptBlock(n,0);for(var s=0;s<r;s++)t[e+s]^=n[s]}function T(t){var e,r,i;return 255==(t>>24&255)?(r=t>>8&255,i=255&t,255===(e=t>>16&255)?(e=0,255===r?(r=0,255===i?i=0:++i):++r):++e,t=0,t+=e<<16,t+=r<<8,t+=i):t+=1<<24,t}function N(){for(var t=this._X,e=this._C,r=0;r<8;r++)E[r]=e[r];e[0]=e[0]+1295307597+this._b|0,e[1]=e[1]+3545052371+(e[0]>>>0<E[0]>>>0?1:0)|0,e[2]=e[2]+886263092+(e[1]>>>0<E[1]>>>0?1:0)|0,e[3]=e[3]+1295307597+(e[2]>>>0<E[2]>>>0?1:0)|0,e[4]=e[4]+3545052371+(e[3]>>>0<E[3]>>>0?1:0)|0,e[5]=e[5]+886263092+(e[4]>>>0<E[4]>>>0?1:0)|0,e[6]=e[6]+1295307597+(e[5]>>>0<E[5]>>>0?1:0)|0,e[7]=e[7]+3545052371+(e[6]>>>0<E[6]>>>0?1:0)|0,this._b=e[7]>>>0<E[7]>>>0?1:0;for(r=0;r<8;r++){var i=t[r]+e[r],n=65535&i,o=i>>>16;R[r]=((n*n>>>17)+n*o>>>15)+o*o^((4294901760&i)*i|0)+((65535&i)*i|0)}t[0]=R[0]+(R[7]<<16|R[7]>>>16)+(R[6]<<16|R[6]>>>16)|0,t[1]=R[1]+(R[0]<<8|R[0]>>>24)+R[7]|0,t[2]=R[2]+(R[1]<<16|R[1]>>>16)+(R[0]<<16|R[0]>>>16)|0,t[3]=R[3]+(R[2]<<8|R[2]>>>24)+R[1]|0,t[4]=R[4]+(R[3]<<16|R[3]>>>16)+(R[2]<<16|R[2]>>>16)|0,t[5]=R[5]+(R[4]<<8|R[4]>>>24)+R[3]|0,t[6]=R[6]+(R[5]<<16|R[5]>>>16)+(R[4]<<16|R[4]>>>16)|0,t[7]=R[7]+(R[6]<<8|R[6]>>>24)+R[5]|0}function q(){for(var t=this._X,e=this._C,r=0;r<8;r++)O[r]=e[r];e[0]=e[0]+1295307597+this._b|0,e[1]=e[1]+3545052371+(e[0]>>>0<O[0]>>>0?1:0)|0,e[2]=e[2]+886263092+(e[1]>>>0<O[1]>>>0?1:0)|0,e[3]=e[3]+1295307597+(e[2]>>>0<O[2]>>>0?1:0)|0,e[4]=e[4]+3545052371+(e[3]>>>0<O[3]>>>0?1:0)|0,e[5]=e[5]+886263092+(e[4]>>>0<O[4]>>>0?1:0)|0,e[6]=e[6]+1295307597+(e[5]>>>0<O[5]>>>0?1:0)|0,e[7]=e[7]+3545052371+(e[6]>>>0<O[6]>>>0?1:0)|0,this._b=e[7]>>>0<O[7]>>>0?1:0;for(r=0;r<8;r++){var i=t[r]+e[r],n=65535&i,o=i>>>16;I[r]=((n*n>>>17)+n*o>>>15)+o*o^((4294901760&i)*i|0)+((65535&i)*i|0)}t[0]=I[0]+(I[7]<<16|I[7]>>>16)+(I[6]<<16|I[6]>>>16)|0,t[1]=I[1]+(I[0]<<8|I[0]>>>24)+I[7]|0,t[2]=I[2]+(I[1]<<16|I[1]>>>16)+(I[0]<<16|I[0]>>>16)|0,t[3]=I[3]+(I[2]<<8|I[2]>>>24)+I[1]|0,t[4]=I[4]+(I[3]<<16|I[3]>>>16)+(I[2]<<16|I[2]>>>16)|0,t[5]=I[5]+(I[4]<<8|I[4]>>>24)+I[3]|0,t[6]=I[6]+(I[5]<<16|I[5]>>>16)+(I[4]<<16|I[4]>>>16)|0,t[7]=I[7]+(I[6]<<8|I[6]>>>24)+I[5]|0}return F=(M=U).lib,n=F.Base,o=F.WordArray,(M=M.x64={}).Word=n.extend({init:function(t,e){this.high=t,this.low=e}}),M.WordArray=n.extend({init:function(t,e){t=this.words=t||[],this.sigBytes=null!=e?e:8*t.length},toX32:function(){for(var t=this.words,e=t.length,r=[],i=0;i<e;i++){var n=t[i];r.push(n.high),r.push(n.low)}return o.create(r,this.sigBytes)},clone:function(){for(var t=n.clone.call(this),e=t.words=this.words.slice(0),r=e.length,i=0;i<r;i++)e[i]=e[i].clone();return t}}),"function"==typeof ArrayBuffer&&(P=U.lib.WordArray,s=P.init,(P.init=function(t){if((t=(t=t instanceof ArrayBuffer?new Uint8Array(t):t)instanceof Int8Array||"undefined"!=typeof Uint8ClampedArray&&t instanceof Uint8ClampedArray||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Float32Array||t instanceof Float64Array?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t)instanceof Uint8Array){for(var e=t.byteLength,r=[],i=0;i<e;i++)r[i>>>2]|=t[i]<<24-i%4*8;s.call(this,r,e)}else s.apply(this,arguments)}).prototype=P),function(){var t=U,n=t.lib.WordArray,t=t.enc;t.Utf16=t.Utf16BE={stringify:function(t){for(var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n+=2){var o=e[n>>>2]>>>16-n%4*8&65535;i.push(String.fromCharCode(o))}return i.join("")},parse:function(t){for(var e=t.length,r=[],i=0;i<e;i++)r[i>>>1]|=t.charCodeAt(i)<<16-i%2*16;return n.create(r,2*e)}};function s(t){return t<<8&4278255360|t>>>8&16711935}t.Utf16LE={stringify:function(t){for(var e=t.words,r=t.sigBytes,i=[],n=0;n<r;n+=2){var o=s(e[n>>>2]>>>16-n%4*8&65535);i.push(String.fromCharCode(o))}return i.join("")},parse:function(t){for(var e=t.length,r=[],i=0;i<e;i++)r[i>>>1]|=s(t.charCodeAt(i)<<16-i%2*16);return n.create(r,2*e)}}}(),a=(w=U).lib.WordArray,w.enc.Base64={stringify:function(t){var e=t.words,r=t.sigBytes,i=this._map;t.clamp();for(var n=[],o=0;o<r;o+=3)for(var s=(e[o>>>2]>>>24-o%4*8&255)<<16|(e[o+1>>>2]>>>24-(o+1)%4*8&255)<<8|e[o+2>>>2]>>>24-(o+2)%4*8&255,c=0;c<4&&o+.75*c<r;c++)n.push(i.charAt(s>>>6*(3-c)&63));var a=i.charAt(64);if(a)for(;n.length%4;)n.push(a);return n.join("")},parse:function(t){var e=t.length,r=this._map;if(!(i=this._reverseMap))for(var i=this._reverseMap=[],n=0;n<r.length;n++)i[r.charCodeAt(n)]=n;var o=r.charAt(64);return!o||-1!==(o=t.indexOf(o))&&(e=o),function(t,e,r){for(var i=[],n=0,o=0;o<e;o++){var s,c;o%4&&(s=r[t.charCodeAt(o-1)]<<o%4*2,c=r[t.charCodeAt(o)]>>>6-o%4*2,c=s|c,i[n>>>2]|=c<<24-n%4*8,n++)}return a.create(i,n)}(t,e,i)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},h=(F=U).lib.WordArray,F.enc.Base64url={stringify:function(t,e=!0){var r=t.words,i=t.sigBytes,n=e?this._safe_map:this._map;t.clamp();for(var o=[],s=0;s<i;s+=3)for(var c=(r[s>>>2]>>>24-s%4*8&255)<<16|(r[s+1>>>2]>>>24-(s+1)%4*8&255)<<8|r[s+2>>>2]>>>24-(s+2)%4*8&255,a=0;a<4&&s+.75*a<i;a++)o.push(n.charAt(c>>>6*(3-a)&63));var h=n.charAt(64);if(h)for(;o.length%4;)o.push(h);return o.join("")},parse:function(t,e=!0){var r=t.length,i=e?this._safe_map:this._map;if(!(n=this._reverseMap))for(var n=this._reverseMap=[],o=0;o<i.length;o++)n[i.charCodeAt(o)]=o;e=i.charAt(64);return!e||-1!==(e=t.indexOf(e))&&(r=e),function(t,e,r){for(var i=[],n=0,o=0;o<e;o++){var s,c;o%4&&(s=r[t.charCodeAt(o-1)]<<o%4*2,c=r[t.charCodeAt(o)]>>>6-o%4*2,c=s|c,i[n>>>2]|=c<<24-n%4*8,n++)}return h.create(i,n)}(t,r,n)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_safe_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"},function(a){var t=U,e=t.lib,r=e.WordArray,i=e.Hasher,e=t.algo,A=[];!function(){for(var t=0;t<64;t++)A[t]=4294967296*a.abs(a.sin(t+1))|0}();e=e.MD5=i.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(t,e){for(var r=0;r<16;r++){var i=e+r,n=t[i];t[i]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8)}var o=this._hash.words,s=t[e+0],c=t[e+1],a=t[e+2],h=t[e+3],l=t[e+4],f=t[e+5],d=t[e+6],u=t[e+7],p=t[e+8],_=t[e+9],y=t[e+10],v=t[e+11],g=t[e+12],B=t[e+13],w=t[e+14],k=t[e+15],m=H(m=o[0],b=o[1],x=o[2],S=o[3],s,7,A[0]),S=H(S,m,b,x,c,12,A[1]),x=H(x,S,m,b,a,17,A[2]),b=H(b,x,S,m,h,22,A[3]);m=H(m,b,x,S,l,7,A[4]),S=H(S,m,b,x,f,12,A[5]),x=H(x,S,m,b,d,17,A[6]),b=H(b,x,S,m,u,22,A[7]),m=H(m,b,x,S,p,7,A[8]),S=H(S,m,b,x,_,12,A[9]),x=H(x,S,m,b,y,17,A[10]),b=H(b,x,S,m,v,22,A[11]),m=H(m,b,x,S,g,7,A[12]),S=H(S,m,b,x,B,12,A[13]),x=H(x,S,m,b,w,17,A[14]),m=z(m,b=H(b,x,S,m,k,22,A[15]),x,S,c,5,A[16]),S=z(S,m,b,x,d,9,A[17]),x=z(x,S,m,b,v,14,A[18]),b=z(b,x,S,m,s,20,A[19]),m=z(m,b,x,S,f,5,A[20]),S=z(S,m,b,x,y,9,A[21]),x=z(x,S,m,b,k,14,A[22]),b=z(b,x,S,m,l,20,A[23]),m=z(m,b,x,S,_,5,A[24]),S=z(S,m,b,x,w,9,A[25]),x=z(x,S,m,b,h,14,A[26]),b=z(b,x,S,m,p,20,A[27]),m=z(m,b,x,S,B,5,A[28]),S=z(S,m,b,x,a,9,A[29]),x=z(x,S,m,b,u,14,A[30]),m=C(m,b=z(b,x,S,m,g,20,A[31]),x,S,f,4,A[32]),S=C(S,m,b,x,p,11,A[33]),x=C(x,S,m,b,v,16,A[34]),b=C(b,x,S,m,w,23,A[35]),m=C(m,b,x,S,c,4,A[36]),S=C(S,m,b,x,l,11,A[37]),x=C(x,S,m,b,u,16,A[38]),b=C(b,x,S,m,y,23,A[39]),m=C(m,b,x,S,B,4,A[40]),S=C(S,m,b,x,s,11,A[41]),x=C(x,S,m,b,h,16,A[42]),b=C(b,x,S,m,d,23,A[43]),m=C(m,b,x,S,_,4,A[44]),S=C(S,m,b,x,g,11,A[45]),x=C(x,S,m,b,k,16,A[46]),m=D(m,b=C(b,x,S,m,a,23,A[47]),x,S,s,6,A[48]),S=D(S,m,b,x,u,10,A[49]),x=D(x,S,m,b,w,15,A[50]),b=D(b,x,S,m,f,21,A[51]),m=D(m,b,x,S,g,6,A[52]),S=D(S,m,b,x,h,10,A[53]),x=D(x,S,m,b,y,15,A[54]),b=D(b,x,S,m,c,21,A[55]),m=D(m,b,x,S,p,6,A[56]),S=D(S,m,b,x,k,10,A[57]),x=D(x,S,m,b,d,15,A[58]),b=D(b,x,S,m,B,21,A[59]),m=D(m,b,x,S,l,6,A[60]),S=D(S,m,b,x,v,10,A[61]),x=D(x,S,m,b,a,15,A[62]),b=D(b,x,S,m,_,21,A[63]),o[0]=o[0]+m|0,o[1]=o[1]+b|0,o[2]=o[2]+x|0,o[3]=o[3]+S|0},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;e[i>>>5]|=128<<24-i%32;var n=a.floor(r/4294967296),r=r;e[15+(64+i>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e[14+(64+i>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),t.sigBytes=4*(e.length+1),this._process();for(var e=this._hash,o=e.words,s=0;s<4;s++){var c=o[s];o[s]=16711935&(c<<8|c>>>24)|4278255360&(c<<24|c>>>8)}return e},clone:function(){var t=i.clone.call(this);return t._hash=this._hash.clone(),t}});function H(t,e,r,i,n,o,s){s=t+(e&r|~e&i)+n+s;return(s<<o|s>>>32-o)+e}function z(t,e,r,i,n,o,s){s=t+(e&i|r&~i)+n+s;return(s<<o|s>>>32-o)+e}function C(t,e,r,i,n,o,s){s=t+(e^r^i)+n+s;return(s<<o|s>>>32-o)+e}function D(t,e,r,i,n,o,s){s=t+(r^(e|~i))+n+s;return(s<<o|s>>>32-o)+e}t.MD5=i._createHelper(e),t.HmacMD5=i._createHmacHelper(e)}(Math),P=(M=U).lib,t=P.WordArray,e=P.Hasher,P=M.algo,l=[],P=P.SHA1=e.extend({_doReset:function(){this._hash=new t.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(t,e){for(var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=0;a<80;a++){a<16?l[a]=0|t[e+a]:(h=l[a-3]^l[a-8]^l[a-14]^l[a-16],l[a]=h<<1|h>>>31);var h=(i<<5|i>>>27)+c+l[a];h+=a<20?1518500249+(n&o|~n&s):a<40?1859775393+(n^o^s):a<60?(n&o|n&s|o&s)-1894007588:(n^o^s)-899497514,c=s,s=o,o=n<<30|n>>>2,n=i,i=h}r[0]=r[0]+i|0,r[1]=r[1]+n|0,r[2]=r[2]+o|0,r[3]=r[3]+s|0,r[4]=r[4]+c|0},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=Math.floor(r/4294967296),e[15+(64+i>>>9<<4)]=r,t.sigBytes=4*e.length,this._process(),this._hash},clone:function(){var t=e.clone.call(this);return t._hash=this._hash.clone(),t}}),M.SHA1=e._createHelper(P),M.HmacSHA1=e._createHmacHelper(P),function(n){var t=U,e=t.lib,r=e.WordArray,i=e.Hasher,e=t.algo,o=[],p=[];!function(){function t(t){return 4294967296*(t-(0|t))|0}for(var e=2,r=0;r<64;)!function(t){for(var e=n.sqrt(t),r=2;r<=e;r++)if(!(t%r))return;return 1}(e)||(r<8&&(o[r]=t(n.pow(e,.5))),p[r]=t(n.pow(e,1/3)),r++),e++}();var _=[],e=e.SHA256=i.extend({_doReset:function(){this._hash=new r.init(o.slice(0))},_doProcessBlock:function(t,e){for(var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=r[5],h=r[6],l=r[7],f=0;f<64;f++){f<16?_[f]=0|t[e+f]:(d=_[f-15],u=_[f-2],_[f]=((d<<25|d>>>7)^(d<<14|d>>>18)^d>>>3)+_[f-7]+((u<<15|u>>>17)^(u<<13|u>>>19)^u>>>10)+_[f-16]);var d=i&n^i&o^n&o,u=l+((c<<26|c>>>6)^(c<<21|c>>>11)^(c<<7|c>>>25))+(c&a^~c&h)+p[f]+_[f],l=h,h=a,a=c,c=s+u|0,s=o,o=n,n=i,i=u+(((i<<30|i>>>2)^(i<<19|i>>>13)^(i<<10|i>>>22))+d)|0}r[0]=r[0]+i|0,r[1]=r[1]+n|0,r[2]=r[2]+o|0,r[3]=r[3]+s|0,r[4]=r[4]+c|0,r[5]=r[5]+a|0,r[6]=r[6]+h|0,r[7]=r[7]+l|0},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=n.floor(r/4294967296),e[15+(64+i>>>9<<4)]=r,t.sigBytes=4*e.length,this._process(),this._hash},clone:function(){var t=i.clone.call(this);return t._hash=this._hash.clone(),t}});t.SHA256=i._createHelper(e),t.HmacSHA256=i._createHmacHelper(e)}(Math),r=(w=U).lib.WordArray,F=w.algo,i=F.SHA256,F=F.SHA224=i.extend({_doReset:function(){this._hash=new r.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var t=i._doFinalize.call(this);return t.sigBytes-=4,t}}),w.SHA224=i._createHelper(F),w.HmacSHA224=i._createHmacHelper(F),function(){var t=U,e=t.lib.Hasher,r=t.x64,i=r.Word,n=r.WordArray,r=t.algo;function o(){return i.create.apply(i,arguments)}var t1=[o(1116352408,3609767458),o(1899447441,602891725),o(3049323471,3964484399),o(3921009573,2173295548),o(961987163,4081628472),o(1508970993,3053834265),o(2453635748,2937671579),o(2870763221,3664609560),o(3624381080,2734883394),o(310598401,1164996542),o(607225278,1323610764),o(1426881987,3590304994),o(1925078388,4068182383),o(2162078206,991336113),o(2614888103,633803317),o(3248222580,3479774868),o(3835390401,2666613458),o(4022224774,944711139),o(264347078,2341262773),o(604807628,2007800933),o(770255983,1495990901),o(1249150122,1856431235),o(1555081692,3175218132),o(1996064986,2198950837),o(2554220882,3999719339),o(2821834349,766784016),o(2952996808,2566594879),o(3210313671,3203337956),o(3336571891,1034457026),o(3584528711,2466948901),o(113926993,3758326383),o(338241895,168717936),o(666307205,1188179964),o(773529912,1546045734),o(1294757372,1522805485),o(1396182291,2643833823),o(1695183700,2343527390),o(1986661051,1014477480),o(2177026350,1206759142),o(2456956037,344077627),o(2730485921,1290863460),o(2820302411,3158454273),o(3259730800,3505952657),o(3345764771,106217008),o(3516065817,3606008344),o(3600352804,1432725776),o(4094571909,1467031594),o(275423344,851169720),o(430227734,3100823752),o(506948616,1363258195),o(659060556,3750685593),o(883997877,3785050280),o(958139571,3318307427),o(1322822218,3812723403),o(1537002063,2003034995),o(1747873779,3602036899),o(1955562222,1575990012),o(2024104815,1125592928),o(2227730452,2716904306),o(2361852424,442776044),o(2428436474,593698344),o(2756734187,3733110249),o(3204031479,2999351573),o(3329325298,3815920427),o(3391569614,3928383900),o(3515267271,566280711),o(3940187606,3454069534),o(4118630271,4000239992),o(116418474,1914138554),o(174292421,2731055270),o(289380356,3203993006),o(460393269,320620315),o(685471733,587496836),o(852142971,1086792851),o(1017036298,365543100),o(1126000580,2618297676),o(1288033470,3409855158),o(1501505948,4234509866),o(1607167915,987167468),o(1816402316,1246189591)],e1=[];!function(){for(var t=0;t<80;t++)e1[t]=o()}();r=r.SHA512=e.extend({_doReset:function(){this._hash=new n.init([new i.init(1779033703,4089235720),new i.init(3144134277,2227873595),new i.init(1013904242,4271175723),new i.init(2773480762,1595750129),new i.init(1359893119,2917565137),new i.init(2600822924,725511199),new i.init(528734635,4215389547),new i.init(1541459225,327033209)])},_doProcessBlock:function(t,e){for(var r=this._hash.words,i=r[0],n=r[1],o=r[2],s=r[3],c=r[4],a=r[5],h=r[6],l=r[7],f=i.high,d=i.low,u=n.high,p=n.low,_=o.high,y=o.low,v=s.high,g=s.low,B=c.high,w=c.low,k=a.high,m=a.low,S=h.high,x=h.low,b=l.high,r=l.low,A=f,H=d,z=u,C=p,D=_,E=y,R=v,M=g,F=B,P=w,W=k,O=m,I=S,U=x,K=b,X=r,L=0;L<80;L++){var j,T,N=e1[L];L<16?(T=N.high=0|t[e+2*L],j=N.low=0|t[e+2*L+1]):($=(q=e1[L-15]).high,J=q.low,G=(Q=e1[L-2]).high,V=Q.low,Z=(Y=e1[L-7]).high,q=Y.low,Y=(Q=e1[L-16]).high,T=(T=(($>>>1|J<<31)^($>>>8|J<<24)^$>>>7)+Z+((j=(Z=(J>>>1|$<<31)^(J>>>8|$<<24)^(J>>>7|$<<25))+q)>>>0<Z>>>0?1:0))+((G>>>19|V<<13)^(G<<3|V>>>29)^G>>>6)+((j+=J=(V>>>19|G<<13)^(V<<3|G>>>29)^(V>>>6|G<<26))>>>0<J>>>0?1:0),j+=$=Q.low,N.high=T=T+Y+(j>>>0<$>>>0?1:0),N.low=j);var q=F&W^~F&I,Z=P&O^~P&U,V=A&z^A&D^z&D,G=(H>>>28|A<<4)^(H<<30|A>>>2)^(H<<25|A>>>7),J=t1[L],Q=J.high,Y=J.low,$=X+((P>>>14|F<<18)^(P>>>18|F<<14)^(P<<23|F>>>9)),N=K+((F>>>14|P<<18)^(F>>>18|P<<14)^(F<<23|P>>>9))+($>>>0<X>>>0?1:0),J=G+(H&C^H&E^C&E),K=I,X=U,I=W,U=O,W=F,O=P,F=R+(N=(N=(N=N+q+(($=$+Z)>>>0<Z>>>0?1:0))+Q+(($=$+Y)>>>0<Y>>>0?1:0))+T+(($=$+j)>>>0<j>>>0?1:0))+((P=M+$|0)>>>0<M>>>0?1:0)|0,R=D,M=E,D=z,E=C,z=A,C=H,A=N+(((A>>>28|H<<4)^(A<<30|H>>>2)^(A<<25|H>>>7))+V+(J>>>0<G>>>0?1:0))+((H=$+J|0)>>>0<$>>>0?1:0)|0}d=i.low=d+H,i.high=f+A+(d>>>0<H>>>0?1:0),p=n.low=p+C,n.high=u+z+(p>>>0<C>>>0?1:0),y=o.low=y+E,o.high=_+D+(y>>>0<E>>>0?1:0),g=s.low=g+M,s.high=v+R+(g>>>0<M>>>0?1:0),w=c.low=w+P,c.high=B+F+(w>>>0<P>>>0?1:0),m=a.low=m+O,a.high=k+W+(m>>>0<O>>>0?1:0),x=h.low=x+U,h.high=S+I+(x>>>0<U>>>0?1:0),r=l.low=r+X,l.high=b+K+(r>>>0<X>>>0?1:0)},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;return e[i>>>5]|=128<<24-i%32,e[30+(128+i>>>10<<5)]=Math.floor(r/4294967296),e[31+(128+i>>>10<<5)]=r,t.sigBytes=4*e.length,this._process(),this._hash.toX32()},clone:function(){var t=e.clone.call(this);return t._hash=this._hash.clone(),t},blockSize:32});t.SHA512=e._createHelper(r),t.HmacSHA512=e._createHmacHelper(r)}(),P=(M=U).x64,c=P.Word,f=P.WordArray,P=M.algo,d=P.SHA512,P=P.SHA384=d.extend({_doReset:function(){this._hash=new f.init([new c.init(3418070365,3238371032),new c.init(1654270250,914150663),new c.init(2438529370,812702999),new c.init(355462360,4144912697),new c.init(1731405415,4290775857),new c.init(2394180231,1750603025),new c.init(3675008525,1694076839),new c.init(1203062813,3204075428)])},_doFinalize:function(){var t=d._doFinalize.call(this);return t.sigBytes-=16,t}}),M.SHA384=d._createHelper(P),M.HmacSHA384=d._createHmacHelper(P),function(l){var t=U,e=t.lib,f=e.WordArray,i=e.Hasher,d=t.x64.Word,e=t.algo,A=[],H=[],z=[];!function(){for(var t=1,e=0,r=0;r<24;r++){A[t+5*e]=(r+1)*(r+2)/2%64;var i=(2*t+3*e)%5;t=e%5,e=i}for(t=0;t<5;t++)for(e=0;e<5;e++)H[t+5*e]=e+(2*t+3*e)%5*5;for(var n=1,o=0;o<24;o++){for(var s,c=0,a=0,h=0;h<7;h++)1&n&&((s=(1<<h)-1)<32?a^=1<<s:c^=1<<s-32),128&n?n=n<<1^113:n<<=1;z[o]=d.create(c,a)}}();var C=[];!function(){for(var t=0;t<25;t++)C[t]=d.create()}();e=e.SHA3=i.extend({cfg:i.cfg.extend({outputLength:512}),_doReset:function(){for(var t=this._state=[],e=0;e<25;e++)t[e]=new d.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(t,e){for(var r=this._state,i=this.blockSize/2,n=0;n<i;n++){var o=t[e+2*n],s=t[e+2*n+1],o=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8);(m=r[n]).high^=s=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),m.low^=o}for(var c=0;c<24;c++){for(var a=0;a<5;a++){for(var h=0,l=0,f=0;f<5;f++)h^=(m=r[a+5*f]).high,l^=m.low;var d=C[a];d.high=h,d.low=l}for(a=0;a<5;a++)for(var u=C[(a+4)%5],p=C[(a+1)%5],_=p.high,p=p.low,h=u.high^(_<<1|p>>>31),l=u.low^(p<<1|_>>>31),f=0;f<5;f++)(m=r[a+5*f]).high^=h,m.low^=l;for(var y=1;y<25;y++){var v=(m=r[y]).high,g=m.low,B=A[y];l=B<32?(h=v<<B|g>>>32-B,g<<B|v>>>32-B):(h=g<<B-32|v>>>64-B,v<<B-32|g>>>64-B);B=C[H[y]];B.high=h,B.low=l}var w=C[0],k=r[0];w.high=k.high,w.low=k.low;for(a=0;a<5;a++)for(f=0;f<5;f++){var m=r[y=a+5*f],S=C[y],x=C[(a+1)%5+5*f],b=C[(a+2)%5+5*f];m.high=S.high^~x.high&b.high,m.low=S.low^~x.low&b.low}m=r[0],k=z[c];m.high^=k.high,m.low^=k.low}},_doFinalize:function(){var t=this._data,e=t.words,r=(this._nDataBytes,8*t.sigBytes),i=32*this.blockSize;e[r>>>5]|=1<<24-r%32,e[(l.ceil((1+r)/i)*i>>>5)-1]|=128,t.sigBytes=4*e.length,this._process();for(var n=this._state,e=this.cfg.outputLength/8,o=e/8,s=[],c=0;c<o;c++){var a=n[c],h=a.high,a=a.low,h=16711935&(h<<8|h>>>24)|4278255360&(h<<24|h>>>8);s.push(a=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)),s.push(h)}return new f.init(s,e)},clone:function(){for(var t=i.clone.call(this),e=t._state=this._state.slice(0),r=0;r<25;r++)e[r]=e[r].clone();return t}});t.SHA3=i._createHelper(e),t.HmacSHA3=i._createHmacHelper(e)}(Math),Math,F=(w=U).lib,u=F.WordArray,p=F.Hasher,F=w.algo,S=u.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),x=u.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),b=u.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),A=u.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),H=u.create([0,1518500249,1859775393,2400959708,2840853838]),z=u.create([1352829926,1548603684,1836072691,2053994217,0]),F=F.RIPEMD160=p.extend({_doReset:function(){this._hash=u.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(t,e){for(var r=0;r<16;r++){var i=e+r,n=t[i];t[i]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8)}for(var o,s,c,a,h,l,f=this._hash.words,d=H.words,u=z.words,p=S.words,_=x.words,y=b.words,v=A.words,g=o=f[0],B=s=f[1],w=c=f[2],k=a=f[3],m=h=f[4],r=0;r<80;r+=1)l=o+t[e+p[r]]|0,l+=r<16?(s^c^a)+d[0]:r<32?K(s,c,a)+d[1]:r<48?((s|~c)^a)+d[2]:r<64?X(s,c,a)+d[3]:(s^(c|~a))+d[4],l=(l=L(l|=0,y[r]))+h|0,o=h,h=a,a=L(c,10),c=s,s=l,l=g+t[e+_[r]]|0,l+=r<16?(B^(w|~k))+u[0]:r<32?X(B,w,k)+u[1]:r<48?((B|~w)^k)+u[2]:r<64?K(B,w,k)+u[3]:(B^w^k)+u[4],l=(l=L(l|=0,v[r]))+m|0,g=m,m=k,k=L(w,10),w=B,B=l;l=f[1]+c+k|0,f[1]=f[2]+a+m|0,f[2]=f[3]+h+g|0,f[3]=f[4]+o+B|0,f[4]=f[0]+s+w|0,f[0]=l},_doFinalize:function(){var t=this._data,e=t.words,r=8*this._nDataBytes,i=8*t.sigBytes;e[i>>>5]|=128<<24-i%32,e[14+(64+i>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),t.sigBytes=4*(e.length+1),this._process();for(var e=this._hash,n=e.words,o=0;o<5;o++){var s=n[o];n[o]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8)}return e},clone:function(){var t=p.clone.call(this);return t._hash=this._hash.clone(),t}}),w.RIPEMD160=p._createHelper(F),w.HmacRIPEMD160=p._createHmacHelper(F),P=(M=U).lib.Base,_=M.enc.Utf8,M.algo.HMAC=P.extend({init:function(t,e){t=this._hasher=new t.init,"string"==typeof e&&(e=_.parse(e));var r=t.blockSize,i=4*r;(e=e.sigBytes>i?t.finalize(e):e).clamp();for(var t=this._oKey=e.clone(),e=this._iKey=e.clone(),n=t.words,o=e.words,s=0;s<r;s++)n[s]^=1549556828,o[s]^=909522486;t.sigBytes=e.sigBytes=i,this.reset()},reset:function(){var t=this._hasher;t.reset(),t.update(this._iKey)},update:function(t){return this._hasher.update(t),this},finalize:function(t){var e=this._hasher,t=e.finalize(t);return e.reset(),e.finalize(this._oKey.clone().concat(t))}}),F=(w=U).lib,M=F.Base,v=F.WordArray,P=w.algo,F=P.SHA1,g=P.HMAC,y=P.PBKDF2=M.extend({cfg:M.extend({keySize:4,hasher:F,iterations:1}),init:function(t){this.cfg=this.cfg.extend(t)},compute:function(t,e){for(var r=this.cfg,i=g.create(r.hasher,t),n=v.create(),o=v.create([1]),s=n.words,c=o.words,a=r.keySize,h=r.iterations;s.length<a;){var l=i.update(e).finalize(o);i.reset();for(var f=l.words,d=f.length,u=l,p=1;p<h;p++){u=i.finalize(u),i.reset();for(var _=u.words,y=0;y<d;y++)f[y]^=_[y]}n.concat(l),c[0]++}return n.sigBytes=4*a,n}}),w.PBKDF2=function(t,e,r){return y.create(r).compute(t,e)},M=(P=U).lib,F=M.Base,B=M.WordArray,w=P.algo,M=w.MD5,k=w.EvpKDF=F.extend({cfg:F.extend({keySize:4,hasher:M,iterations:1}),init:function(t){this.cfg=this.cfg.extend(t)},compute:function(t,e){for(var r,i=this.cfg,n=i.hasher.create(),o=B.create(),s=o.words,c=i.keySize,a=i.iterations;s.length<c;){r&&n.update(r),r=n.update(t).finalize(e),n.reset();for(var h=1;h<a;h++)r=n.finalize(r),n.reset();o.concat(r)}return o.sigBytes=4*c,o}}),P.EvpKDF=function(t,e,r){return k.create(r).compute(t,e)},U.lib.Cipher||function(){var t=U,e=t.lib,r=e.Base,s=e.WordArray,i=e.BufferedBlockAlgorithm,n=t.enc,o=(n.Utf8,n.Base64),c=t.algo.EvpKDF,a=e.Cipher=i.extend({cfg:r.extend(),createEncryptor:function(t,e){return this.create(this._ENC_XFORM_MODE,t,e)},createDecryptor:function(t,e){return this.create(this._DEC_XFORM_MODE,t,e)},init:function(t,e,r){this.cfg=this.cfg.extend(r),this._xformMode=t,this._key=e,this.reset()},reset:function(){i.reset.call(this),this._doReset()},process:function(t){return this._append(t),this._process()},finalize:function(t){return t&&this._append(t),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(i){return{encrypt:function(t,e,r){return h(e).encrypt(i,t,e,r)},decrypt:function(t,e,r){return h(e).decrypt(i,t,e,r)}}}});function h(t){return"string"==typeof t?p:u}e.StreamCipher=a.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var l=t.mode={},n=e.BlockCipherMode=r.extend({createEncryptor:function(t,e){return this.Encryptor.create(t,e)},createDecryptor:function(t,e){return this.Decryptor.create(t,e)},init:function(t,e){this._cipher=t,this._iv=e}}),n=l.CBC=((l=n.extend()).Encryptor=l.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize;f.call(this,t,e,i),r.encryptBlock(t,e),this._prevBlock=t.slice(e,e+i)}}),l.Decryptor=l.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=t.slice(e,e+i);r.decryptBlock(t,e),f.call(this,t,e,i),this._prevBlock=n}}),l);function f(t,e,r){var i,n=this._iv;n?(i=n,this._iv=void 0):i=this._prevBlock;for(var o=0;o<r;o++)t[e+o]^=i[o]}var l=(t.pad={}).Pkcs7={pad:function(t,e){for(var e=4*e,r=e-t.sigBytes%e,i=r<<24|r<<16|r<<8|r,n=[],o=0;o<r;o+=4)n.push(i);e=s.create(n,r);t.concat(e)},unpad:function(t){var e=255&t.words[t.sigBytes-1>>>2];t.sigBytes-=e}},d=(e.BlockCipher=a.extend({cfg:a.cfg.extend({mode:n,padding:l}),reset:function(){var t;a.reset.call(this);var e=this.cfg,r=e.iv,e=e.mode;this._xformMode==this._ENC_XFORM_MODE?t=e.createEncryptor:(t=e.createDecryptor,this._minBufferSize=1),this._mode&&this._mode.__creator==t?this._mode.init(this,r&&r.words):(this._mode=t.call(e,this,r&&r.words),this._mode.__creator=t)},_doProcessBlock:function(t,e){this._mode.processBlock(t,e)},_doFinalize:function(){var t,e=this.cfg.padding;return this._xformMode==this._ENC_XFORM_MODE?(e.pad(this._data,this.blockSize),t=this._process(!0)):(t=this._process(!0),e.unpad(t)),t},blockSize:4}),e.CipherParams=r.extend({init:function(t){this.mixIn(t)},toString:function(t){return(t||this.formatter).stringify(this)}})),l=(t.format={}).OpenSSL={stringify:function(t){var e=t.ciphertext,t=t.salt,e=t?s.create([1398893684,1701076831]).concat(t).concat(e):e;return e.toString(o)},parse:function(t){var e,r=o.parse(t),t=r.words;return 1398893684==t[0]&&1701076831==t[1]&&(e=s.create(t.slice(2,4)),t.splice(0,4),r.sigBytes-=16),d.create({ciphertext:r,salt:e})}},u=e.SerializableCipher=r.extend({cfg:r.extend({format:l}),encrypt:function(t,e,r,i){i=this.cfg.extend(i);var n=t.createEncryptor(r,i),e=n.finalize(e),n=n.cfg;return d.create({ciphertext:e,key:r,iv:n.iv,algorithm:t,mode:n.mode,padding:n.padding,blockSize:t.blockSize,formatter:i.format})},decrypt:function(t,e,r,i){return i=this.cfg.extend(i),e=this._parse(e,i.format),t.createDecryptor(r,i).finalize(e.ciphertext)},_parse:function(t,e){return"string"==typeof t?e.parse(t,this):t}}),t=(t.kdf={}).OpenSSL={execute:function(t,e,r,i){i=i||s.random(8);t=c.create({keySize:e+r}).compute(t,i),r=s.create(t.words.slice(e),4*r);return t.sigBytes=4*e,d.create({key:t,iv:r,salt:i})}},p=e.PasswordBasedCipher=u.extend({cfg:u.cfg.extend({kdf:t}),encrypt:function(t,e,r,i){r=(i=this.cfg.extend(i)).kdf.execute(r,t.keySize,t.ivSize);i.iv=r.iv;i=u.encrypt.call(this,t,e,r.key,i);return i.mixIn(r),i},decrypt:function(t,e,r,i){i=this.cfg.extend(i),e=this._parse(e,i.format);r=i.kdf.execute(r,t.keySize,t.ivSize,e.salt);return i.iv=r.iv,u.decrypt.call(this,t,e,r.key,i)}})}(),U.mode.CFB=((F=U.lib.BlockCipherMode.extend()).Encryptor=F.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize;j.call(this,t,e,i,r),this._prevBlock=t.slice(e,e+i)}}),F.Decryptor=F.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=t.slice(e,e+i);j.call(this,t,e,i,r),this._prevBlock=n}}),F),U.mode.CTR=(M=U.lib.BlockCipherMode.extend(),P=M.Encryptor=M.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=this._iv,o=this._counter;n&&(o=this._counter=n.slice(0),this._iv=void 0);var s=o.slice(0);r.encryptBlock(s,0),o[i-1]=o[i-1]+1|0;for(var c=0;c<i;c++)t[e+c]^=s[c]}}),M.Decryptor=P,M),U.mode.CTRGladman=(F=U.lib.BlockCipherMode.extend(),P=F.Encryptor=F.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=this._iv,o=this._counter;n&&(o=this._counter=n.slice(0),this._iv=void 0),0===((n=o)[0]=T(n[0]))&&(n[1]=T(n[1]));var s=o.slice(0);r.encryptBlock(s,0);for(var c=0;c<i;c++)t[e+c]^=s[c]}}),F.Decryptor=P,F),U.mode.OFB=(M=U.lib.BlockCipherMode.extend(),P=M.Encryptor=M.extend({processBlock:function(t,e){var r=this._cipher,i=r.blockSize,n=this._iv,o=this._keystream;n&&(o=this._keystream=n.slice(0),this._iv=void 0),r.encryptBlock(o,0);for(var s=0;s<i;s++)t[e+s]^=o[s]}}),M.Decryptor=P,M),U.mode.ECB=((F=U.lib.BlockCipherMode.extend()).Encryptor=F.extend({processBlock:function(t,e){this._cipher.encryptBlock(t,e)}}),F.Decryptor=F.extend({processBlock:function(t,e){this._cipher.decryptBlock(t,e)}}),F),U.pad.AnsiX923={pad:function(t,e){var r=t.sigBytes,e=4*e,e=e-r%e,r=r+e-1;t.clamp(),t.words[r>>>2]|=e<<24-r%4*8,t.sigBytes+=e},unpad:function(t){var e=255&t.words[t.sigBytes-1>>>2];t.sigBytes-=e}},U.pad.Iso10126={pad:function(t,e){e*=4,e-=t.sigBytes%e;t.concat(U.lib.WordArray.random(e-1)).concat(U.lib.WordArray.create([e<<24],1))},unpad:function(t){var e=255&t.words[t.sigBytes-1>>>2];t.sigBytes-=e}},U.pad.Iso97971={pad:function(t,e){t.concat(U.lib.WordArray.create([2147483648],1)),U.pad.ZeroPadding.pad(t,e)},unpad:function(t){U.pad.ZeroPadding.unpad(t),t.sigBytes--}},U.pad.ZeroPadding={pad:function(t,e){e*=4;t.clamp(),t.sigBytes+=e-(t.sigBytes%e||e)},unpad:function(t){for(var e=t.words,r=t.sigBytes-1,r=t.sigBytes-1;0<=r;r--)if(e[r>>>2]>>>24-r%4*8&255){t.sigBytes=r+1;break}}},U.pad.NoPadding={pad:function(){},unpad:function(){}},m=(P=U).lib.CipherParams,C=P.enc.Hex,P.format.Hex={stringify:function(t){return t.ciphertext.toString(C)},parse:function(t){t=C.parse(t);return m.create({ciphertext:t})}},function(){var t=U,e=t.lib.BlockCipher,r=t.algo,h=[],l=[],f=[],d=[],u=[],p=[],_=[],y=[],v=[],g=[];!function(){for(var t=[],e=0;e<256;e++)t[e]=e<128?e<<1:e<<1^283;for(var r=0,i=0,e=0;e<256;e++){var n=i^i<<1^i<<2^i<<3^i<<4;h[r]=n=n>>>8^255&n^99;var o=t[l[n]=r],s=t[o],c=t[s],a=257*t[n]^16843008*n;f[r]=a<<24|a>>>8,d[r]=a<<16|a>>>16,u[r]=a<<8|a>>>24,p[r]=a,_[n]=(a=16843009*c^65537*s^257*o^16843008*r)<<24|a>>>8,y[n]=a<<16|a>>>16,v[n]=a<<8|a>>>24,g[n]=a,r?(r=o^t[t[t[c^o]]],i^=t[t[i]]):r=i=1}}();var B=[0,1,2,4,8,16,32,64,128,27,54],r=r.AES=e.extend({_doReset:function(){if(!this._nRounds||this._keyPriorReset!==this._key){for(var t=this._keyPriorReset=this._key,e=t.words,r=t.sigBytes/4,i=4*(1+(this._nRounds=6+r)),n=this._keySchedule=[],o=0;o<i;o++)o<r?n[o]=e[o]:(a=n[o-1],o%r?6<r&&o%r==4&&(a=h[a>>>24]<<24|h[a>>>16&255]<<16|h[a>>>8&255]<<8|h[255&a]):(a=h[(a=a<<8|a>>>24)>>>24]<<24|h[a>>>16&255]<<16|h[a>>>8&255]<<8|h[255&a],a^=B[o/r|0]<<24),n[o]=n[o-r]^a);for(var s=this._invKeySchedule=[],c=0;c<i;c++){var a,o=i-c;a=c%4?n[o]:n[o-4],s[c]=c<4||o<=4?a:_[h[a>>>24]]^y[h[a>>>16&255]]^v[h[a>>>8&255]]^g[h[255&a]]}}},encryptBlock:function(t,e){this._doCryptBlock(t,e,this._keySchedule,f,d,u,p,h)},decryptBlock:function(t,e){var r=t[e+1];t[e+1]=t[e+3],t[e+3]=r,this._doCryptBlock(t,e,this._invKeySchedule,_,y,v,g,l);r=t[e+1];t[e+1]=t[e+3],t[e+3]=r},_doCryptBlock:function(t,e,r,i,n,o,s,c){for(var a=this._nRounds,h=t[e]^r[0],l=t[e+1]^r[1],f=t[e+2]^r[2],d=t[e+3]^r[3],u=4,p=1;p<a;p++)var _=i[h>>>24]^n[l>>>16&255]^o[f>>>8&255]^s[255&d]^r[u++],y=i[l>>>24]^n[f>>>16&255]^o[d>>>8&255]^s[255&h]^r[u++],v=i[f>>>24]^n[d>>>16&255]^o[h>>>8&255]^s[255&l]^r[u++],g=i[d>>>24]^n[h>>>16&255]^o[l>>>8&255]^s[255&f]^r[u++],h=_,l=y,f=v,d=g;_=(c[h>>>24]<<24|c[l>>>16&255]<<16|c[f>>>8&255]<<8|c[255&d])^r[u++],y=(c[l>>>24]<<24|c[f>>>16&255]<<16|c[d>>>8&255]<<8|c[255&h])^r[u++],v=(c[f>>>24]<<24|c[d>>>16&255]<<16|c[h>>>8&255]<<8|c[255&l])^r[u++],g=(c[d>>>24]<<24|c[h>>>16&255]<<16|c[l>>>8&255]<<8|c[255&f])^r[u++];t[e]=_,t[e+1]=y,t[e+2]=v,t[e+3]=g},keySize:8});t.AES=e._createHelper(r)}(),function(){var t=U,e=t.lib,i=e.WordArray,r=e.BlockCipher,e=t.algo,h=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],l=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],f=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],d=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],u=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],n=e.DES=r.extend({_doReset:function(){for(var t=this._key.words,e=[],r=0;r<56;r++){var i=h[r]-1;e[r]=t[i>>>5]>>>31-i%32&1}for(var n=this._subKeys=[],o=0;o<16;o++){for(var s=n[o]=[],c=f[o],r=0;r<24;r++)s[r/6|0]|=e[(l[r]-1+c)%28]<<31-r%6,s[4+(r/6|0)]|=e[28+(l[r+24]-1+c)%28]<<31-r%6;s[0]=s[0]<<1|s[0]>>>31;for(r=1;r<7;r++)s[r]=s[r]>>>4*(r-1)+3;s[7]=s[7]<<5|s[7]>>>27}for(var a=this._invSubKeys=[],r=0;r<16;r++)a[r]=n[15-r]},encryptBlock:function(t,e){this._doCryptBlock(t,e,this._subKeys)},decryptBlock:function(t,e){this._doCryptBlock(t,e,this._invSubKeys)},_doCryptBlock:function(t,e,r){this._lBlock=t[e],this._rBlock=t[e+1],p.call(this,4,252645135),p.call(this,16,65535),_.call(this,2,858993459),_.call(this,8,16711935),p.call(this,1,1431655765);for(var i=0;i<16;i++){for(var n=r[i],o=this._lBlock,s=this._rBlock,c=0,a=0;a<8;a++)c|=d[a][((s^n[a])&u[a])>>>0];this._lBlock=s,this._rBlock=o^c}var h=this._lBlock;this._lBlock=this._rBlock,this._rBlock=h,p.call(this,1,1431655765),_.call(this,8,16711935),_.call(this,2,858993459),p.call(this,16,65535),p.call(this,4,252645135),t[e]=this._lBlock,t[e+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});function p(t,e){e=(this._lBlock>>>t^this._rBlock)&e;this._rBlock^=e,this._lBlock^=e<<t}function _(t,e){e=(this._rBlock>>>t^this._lBlock)&e;this._lBlock^=e,this._rBlock^=e<<t}t.DES=r._createHelper(n);e=e.TripleDES=r.extend({_doReset:function(){var t=this._key.words;if(2!==t.length&&4!==t.length&&t.length<6)throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");var e=t.slice(0,2),r=t.length<4?t.slice(0,2):t.slice(2,4),t=t.length<6?t.slice(0,2):t.slice(4,6);this._des1=n.createEncryptor(i.create(e)),this._des2=n.createEncryptor(i.create(r)),this._des3=n.createEncryptor(i.create(t))},encryptBlock:function(t,e){this._des1.encryptBlock(t,e),this._des2.decryptBlock(t,e),this._des3.encryptBlock(t,e)},decryptBlock:function(t,e){this._des3.decryptBlock(t,e),this._des2.encryptBlock(t,e),this._des1.decryptBlock(t,e)},keySize:6,ivSize:2,blockSize:2});t.TripleDES=r._createHelper(e)}(),function(){var t=U,e=t.lib.StreamCipher,r=t.algo,i=r.RC4=e.extend({_doReset:function(){for(var t=this._key,e=t.words,r=t.sigBytes,i=this._S=[],n=0;n<256;n++)i[n]=n;for(var n=0,o=0;n<256;n++){var s=n%r,s=e[s>>>2]>>>24-s%4*8&255,o=(o+i[n]+s)%256,s=i[n];i[n]=i[o],i[o]=s}this._i=this._j=0},_doProcessBlock:function(t,e){t[e]^=n.call(this)},keySize:8,ivSize:0});function n(){for(var t=this._S,e=this._i,r=this._j,i=0,n=0;n<4;n++){var r=(r+t[e=(e+1)%256])%256,o=t[e];t[e]=t[r],t[r]=o,i|=t[(t[e]+t[r])%256]<<24-8*n}return this._i=e,this._j=r,i}t.RC4=e._createHelper(i);r=r.RC4Drop=i.extend({cfg:i.cfg.extend({drop:192}),_doReset:function(){i._doReset.call(this);for(var t=this.cfg.drop;0<t;t--)n.call(this)}});t.RC4Drop=e._createHelper(r)}(),F=(M=U).lib.StreamCipher,P=M.algo,D=[],E=[],R=[],P=P.Rabbit=F.extend({_doReset:function(){for(var t=this._key.words,e=this.cfg.iv,r=0;r<4;r++)t[r]=16711935&(t[r]<<8|t[r]>>>24)|4278255360&(t[r]<<24|t[r]>>>8);for(var i=this._X=[t[0],t[3]<<16|t[2]>>>16,t[1],t[0]<<16|t[3]>>>16,t[2],t[1]<<16|t[0]>>>16,t[3],t[2]<<16|t[1]>>>16],n=this._C=[t[2]<<16|t[2]>>>16,4294901760&t[0]|65535&t[1],t[3]<<16|t[3]>>>16,4294901760&t[1]|65535&t[2],t[0]<<16|t[0]>>>16,4294901760&t[2]|65535&t[3],t[1]<<16|t[1]>>>16,4294901760&t[3]|65535&t[0]],r=this._b=0;r<4;r++)N.call(this);for(r=0;r<8;r++)n[r]^=i[r+4&7];if(e){var o=e.words,s=o[0],c=o[1],e=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),o=16711935&(c<<8|c>>>24)|4278255360&(c<<24|c>>>8),s=e>>>16|4294901760&o,c=o<<16|65535&e;n[0]^=e,n[1]^=s,n[2]^=o,n[3]^=c,n[4]^=e,n[5]^=s,n[6]^=o,n[7]^=c;for(r=0;r<4;r++)N.call(this)}},_doProcessBlock:function(t,e){var r=this._X;N.call(this),D[0]=r[0]^r[5]>>>16^r[3]<<16,D[1]=r[2]^r[7]>>>16^r[5]<<16,D[2]=r[4]^r[1]>>>16^r[7]<<16,D[3]=r[6]^r[3]>>>16^r[1]<<16;for(var i=0;i<4;i++)D[i]=16711935&(D[i]<<8|D[i]>>>24)|4278255360&(D[i]<<24|D[i]>>>8),t[e+i]^=D[i]},blockSize:4,ivSize:2}),M.Rabbit=F._createHelper(P),F=(M=U).lib.StreamCipher,P=M.algo,W=[],O=[],I=[],P=P.RabbitLegacy=F.extend({_doReset:function(){for(var t=this._key.words,e=this.cfg.iv,r=this._X=[t[0],t[3]<<16|t[2]>>>16,t[1],t[0]<<16|t[3]>>>16,t[2],t[1]<<16|t[0]>>>16,t[3],t[2]<<16|t[1]>>>16],i=this._C=[t[2]<<16|t[2]>>>16,4294901760&t[0]|65535&t[1],t[3]<<16|t[3]>>>16,4294901760&t[1]|65535&t[2],t[0]<<16|t[0]>>>16,4294901760&t[2]|65535&t[3],t[1]<<16|t[1]>>>16,4294901760&t[3]|65535&t[0]],n=this._b=0;n<4;n++)q.call(this);for(n=0;n<8;n++)i[n]^=r[n+4&7];if(e){var o=e.words,s=o[0],t=o[1],e=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),o=16711935&(t<<8|t>>>24)|4278255360&(t<<24|t>>>8),s=e>>>16|4294901760&o,t=o<<16|65535&e;i[0]^=e,i[1]^=s,i[2]^=o,i[3]^=t,i[4]^=e,i[5]^=s,i[6]^=o,i[7]^=t;for(n=0;n<4;n++)q.call(this)}},_doProcessBlock:function(t,e){var r=this._X;q.call(this),W[0]=r[0]^r[5]>>>16^r[3]<<16,W[1]=r[2]^r[7]>>>16^r[5]<<16,W[2]=r[4]^r[1]>>>16^r[7]<<16,W[3]=r[6]^r[3]>>>16^r[1]<<16;for(var i=0;i<4;i++)W[i]=16711935&(W[i]<<8|W[i]>>>24)|4278255360&(W[i]<<24|W[i]>>>8),t[e+i]^=W[i]},blockSize:4,ivSize:2}),M.RabbitLegacy=F._createHelper(P),U});
    </script>
    
    <!-- 
    Library: Elliptic v6.5.4
    Description: Fast elliptic curve cryptography in JavaScript
    Source: https://github.com/indutny/elliptic
    License: MIT License
    Downloaded from: https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js
    Last verified: April 23, 2025
    -->
    <script>
        !function(e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).elliptic=e()}(function(){return function r(f,d,n){function a(t,e){if(!d[t]){if(!f[t]){var i="function"==typeof require&&require;if(!e&&i)return i(t,!0);if(s)return s(t,!0);throw(i=new Error("Cannot find module '"+t+"'")).code="MODULE_NOT_FOUND",i}i=d[t]={exports:{}},f[t][0].call(i.exports,function(e){return a(f[t][1][e]||e)},i,i.exports,r,f,d,n)}return d[t].exports}for(var s="function"==typeof require&&require,e=0;e<n.length;e++)a(n[e]);return a}({1:[function(e,t,i){"use strict";i.version=e("../package.json").version,i.utils=e("./elliptic/utils"),i.rand=e("brorand"),i.curve=e("./elliptic/curve"),i.curves=e("./elliptic/curves"),i.ec=e("./elliptic/ec"),i.eddsa=e("./elliptic/eddsa")},{"../package.json":35,"./elliptic/curve":4,"./elliptic/curves":7,"./elliptic/ec":8,"./elliptic/eddsa":11,"./elliptic/utils":15,brorand:17}],2:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../utils"),x=f.getNAF,I=f.getJSF,o=f.assert;function d(e,t){this.type=e,this.p=new r(t.p,16),this.red=t.prime?r.red(t.prime):r.mont(this.p),this.zero=new r(0).toRed(this.red),this.one=new r(1).toRed(this.red),this.two=new r(2).toRed(this.red),this.n=t.n&&new r(t.n,16),this.g=t.g&&this.pointFromJSON(t.g,t.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4),this._bitLength=this.n?this.n.bitLength():0;t=this.n&&this.p.div(this.n);!t||0<t.cmpn(100)?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function n(e,t){this.curve=e,this.type=t,this.precomputed=null}(t.exports=d).prototype.point=function(){throw new Error("Not implemented")},d.prototype.validate=function(){throw new Error("Not implemented")},d.prototype._fixedNafMul=function(e,t){o(e.precomputed);var i=e._getDoubles(),r=x(t,1,this._bitLength),t=(1<<i.step+1)-(i.step%2==0?2:1);t/=3;for(var f,d=[],n=0;n<r.length;n+=i.step){f=0;for(var a=n+i.step-1;n<=a;a--)f=(f<<1)+r[a];d.push(f)}for(var s=this.jpoint(null,null,null),c=this.jpoint(null,null,null),h=t;0<h;h--){for(n=0;n<d.length;n++)(f=d[n])===h?c=c.mixedAdd(i.points[n]):f===-h&&(c=c.mixedAdd(i.points[n].neg()));s=s.add(c)}return s.toP()},d.prototype._wnafMul=function(e,t){for(var i=e._getNAFPoints(4),r=i.wnd,f=i.points,d=x(t,r,this._bitLength),n=this.jpoint(null,null,null),a=d.length-1;0<=a;a--){for(var s=0;0<=a&&0===d[a];a--)s++;if(0<=a&&s++,n=n.dblp(s),a<0)break;var c=d[a];o(0!==c),n="affine"===e.type?0<c?n.mixedAdd(f[c-1>>1]):n.mixedAdd(f[-c-1>>1].neg()):0<c?n.add(f[c-1>>1]):n.add(f[-c-1>>1].neg())}return"affine"===e.type?n.toP():n},d.prototype._wnafMulAdd=function(e,t,i,r,f){for(var d,n=this._wnafT1,a=this._wnafT2,s=this._wnafT3,c=0,h=0;h<r;h++){var o=(d=t[h])._getNAFPoints(e);n[h]=o.wnd,a[h]=o.points}for(h=r-1;1<=h;h-=2){var u=h-1,b=h;if(1===n[u]&&1===n[b]){var l=[t[u],null,null,t[b]];0===t[u].y.cmp(t[b].y)?(l[1]=t[u].add(t[b]),l[2]=t[u].toJ().mixedAdd(t[b].neg())):0===t[u].y.cmp(t[b].y.redNeg())?(l[1]=t[u].toJ().mixedAdd(t[b]),l[2]=t[u].add(t[b].neg())):(l[1]=t[u].toJ().mixedAdd(t[b]),l[2]=t[u].toJ().mixedAdd(t[b].neg()));var p=[-3,-1,-5,-7,0,7,5,1,3],m=I(i[u],i[b]),c=Math.max(m[0].length,c);for(s[u]=new Array(c),s[b]=new Array(c),_=0;_<c;_++){var v=0|m[0][_],g=0|m[1][_];s[u][_]=p[3*(1+v)+(1+g)],s[b][_]=0,a[u]=l}}else s[u]=x(i[u],n[u],this._bitLength),s[b]=x(i[b],n[b],this._bitLength),c=Math.max(s[u].length,c),c=Math.max(s[b].length,c)}var y=this.jpoint(null,null,null),M=this._wnafT4;for(h=c;0<=h;h--){for(var w=0;0<=h;){for(var S=!0,_=0;_<r;_++)M[_]=0|s[_][h],0!==M[_]&&(S=!1);if(!S)break;w++,h--}if(0<=h&&w++,y=y.dblp(w),h<0)break;for(_=0;_<r;_++){var A=M[_];0!==A&&(0<A?d=a[_][A-1>>1]:A<0&&(d=a[_][-A-1>>1].neg()),y="affine"===d.type?y.mixedAdd(d):y.add(d))}}for(h=0;h<r;h++)a[h]=null;return f?y:y.toP()},(d.BasePoint=n).prototype.eq=function(){throw new Error("Not implemented")},n.prototype.validate=function(){return this.curve.validate(this)},d.prototype.decodePoint=function(e,t){e=f.toArray(e,t);t=this.p.byteLength();if((4===e[0]||6===e[0]||7===e[0])&&e.length-1==2*t)return 6===e[0]?o(e[e.length-1]%2==0):7===e[0]&&o(e[e.length-1]%2==1),this.point(e.slice(1,1+t),e.slice(1+t,1+2*t));if((2===e[0]||3===e[0])&&e.length-1===t)return this.pointFromX(e.slice(1,1+t),3===e[0]);throw new Error("Unknown point format")},n.prototype.encodeCompressed=function(e){return this.encode(e,!0)},n.prototype._encode=function(e){var t=this.curve.p.byteLength(),i=this.getX().toArray("be",t);return e?[this.getY().isEven()?2:3].concat(i):[4].concat(i,this.getY().toArray("be",t))},n.prototype.encode=function(e,t){return f.encode(this._encode(t),e)},n.prototype.precompute=function(e){if(this.precomputed)return this;var t={doubles:null,naf:null,beta:null};return t.naf=this._getNAFPoints(8),t.doubles=this._getDoubles(4,e),t.beta=this._getBeta(),this.precomputed=t,this},n.prototype._hasDoubles=function(e){if(!this.precomputed)return!1;var t=this.precomputed.doubles;return!!t&&t.points.length>=Math.ceil((e.bitLength()+1)/t.step)},n.prototype._getDoubles=function(e,t){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var i=[this],r=this,f=0;f<t;f+=e){for(var d=0;d<e;d++)r=r.dbl();i.push(r)}return{step:e,points:i}},n.prototype._getNAFPoints=function(e){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var t=[this],i=(1<<e)-1,r=1==i?null:this.dbl(),f=1;f<i;f++)t[f]=t[f-1].add(r);return{wnd:e,points:t}},n.prototype._getBeta=function(){return null},n.prototype.dblp=function(e){for(var t=this,i=0;i<e;i++)t=t.dbl();return t}},{"../utils":15,"bn.js":16}],3:[function(e,t,i){"use strict";var r=e("../utils"),d=e("bn.js"),f=e("inherits"),n=e("./base"),a=r.assert;function s(e){this.twisted=1!=(0|e.a),this.mOneA=this.twisted&&-1==(0|e.a),this.extended=this.mOneA,n.call(this,"edwards",e),this.a=new d(e.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new d(e.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new d(e.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),a(!this.twisted||0===this.c.fromRed().cmpn(1)),this.oneC=1==(0|e.c)}function c(e,t,i,r,f){n.BasePoint.call(this,e,"projective"),null===t&&null===i&&null===r?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new d(t,16),this.y=new d(i,16),this.z=r?new d(r,16):this.curve.one,this.t=f&&new d(f,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}f(s,n),(t.exports=s).prototype._mulA=function(e){return this.mOneA?e.redNeg():this.a.redMul(e)},s.prototype._mulC=function(e){return this.oneC?e:this.c.redMul(e)},s.prototype.jpoint=function(e,t,i,r){return this.point(e,t,i,r)},s.prototype.pointFromX=function(e,t){var i=(e=!(e=new d(e,16)).red?e.toRed(this.red):e).redSqr(),r=this.c2.redSub(this.a.redMul(i)),i=this.one.redSub(this.c2.redMul(this.d).redMul(i)),r=r.redMul(i.redInvm()),i=r.redSqrt();if(0!==i.redSqr().redSub(r).cmp(this.zero))throw new Error("invalid point");r=i.fromRed().isOdd();return(t&&!r||!t&&r)&&(i=i.redNeg()),this.point(e,i)},s.prototype.pointFromY=function(e,t){var i=(e=!(e=new d(e,16)).red?e.toRed(this.red):e).redSqr(),r=i.redSub(this.c2),i=i.redMul(this.d).redMul(this.c2).redSub(this.a),r=r.redMul(i.redInvm());if(0===r.cmp(this.zero)){if(t)throw new Error("invalid point");return this.point(this.zero,e)}i=r.redSqrt();if(0!==i.redSqr().redSub(r).cmp(this.zero))throw new Error("invalid point");return i.fromRed().isOdd()!==t&&(i=i.redNeg()),this.point(i,e)},s.prototype.validate=function(e){if(e.isInfinity())return!0;e.normalize();var t=e.x.redSqr(),i=e.y.redSqr(),e=t.redMul(this.a).redAdd(i),i=this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(i)));return 0===e.cmp(i)},f(c,n.BasePoint),s.prototype.pointFromJSON=function(e){return c.fromJSON(this,e)},s.prototype.point=function(e,t,i,r){return new c(this,e,t,i,r)},c.fromJSON=function(e,t){return new c(e,t[0],t[1],t[2])},c.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},c.prototype.isInfinity=function(){return 0===this.x.cmpn(0)&&(0===this.y.cmp(this.z)||this.zOne&&0===this.y.cmp(this.curve.c))},c.prototype._extDbl=function(){var e=this.x.redSqr(),t=this.y.redSqr(),i=(i=this.z.redSqr()).redIAdd(i),r=this.curve._mulA(e),f=this.x.redAdd(this.y).redSqr().redISub(e).redISub(t),d=r.redAdd(t),e=d.redSub(i),i=r.redSub(t),r=f.redMul(e),t=d.redMul(i),i=f.redMul(i),d=e.redMul(d);return this.curve.point(r,t,d,i)},c.prototype._projDbl=function(){var e,t,i,r,f,d,n=this.x.redAdd(this.y).redSqr(),a=this.x.redSqr(),s=this.y.redSqr();return d=this.curve.twisted?(f=(i=this.curve._mulA(a)).redAdd(s),this.zOne?(e=n.redSub(a).redSub(s).redMul(f.redSub(this.curve.two)),t=f.redMul(i.redSub(s)),f.redSqr().redSub(f).redSub(f)):(r=this.z.redSqr(),d=f.redSub(r).redISub(r),e=n.redSub(a).redISub(s).redMul(d),t=f.redMul(i.redSub(s)),f.redMul(d))):(i=a.redAdd(s),r=this.curve._mulC(this.z).redSqr(),d=i.redSub(r).redSub(r),e=this.curve._mulC(n.redISub(i)).redMul(d),t=this.curve._mulC(i).redMul(a.redISub(s)),i.redMul(d)),this.curve.point(e,t,d)},c.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},c.prototype._extAdd=function(e){var t=this.y.redSub(this.x).redMul(e.y.redSub(e.x)),i=this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)),r=this.t.redMul(this.curve.dd).redMul(e.t),f=this.z.redMul(e.z.redAdd(e.z)),d=i.redSub(t),e=f.redSub(r),f=f.redAdd(r),r=i.redAdd(t),i=d.redMul(e),t=f.redMul(r),r=d.redMul(r),f=e.redMul(f);return this.curve.point(i,t,f,r)},c.prototype._projAdd=function(e){var t,i=this.z.redMul(e.z),r=i.redSqr(),f=this.x.redMul(e.x),d=this.y.redMul(e.y),n=this.curve.d.redMul(f).redMul(d),a=r.redSub(n),n=r.redAdd(n),e=this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f).redISub(d),e=i.redMul(a).redMul(e),n=this.curve.twisted?(t=i.redMul(n).redMul(d.redSub(this.curve._mulA(f))),a.redMul(n)):(t=i.redMul(n).redMul(d.redSub(f)),this.curve._mulC(a).redMul(n));return this.curve.point(e,t,n)},c.prototype.add=function(e){return this.isInfinity()?e:e.isInfinity()?this:this.curve.extended?this._extAdd(e):this._projAdd(e)},c.prototype.mul=function(e){return this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve._wnafMul(this,e)},c.prototype.mulAdd=function(e,t,i){return this.curve._wnafMulAdd(1,[this,t],[e,i],2,!1)},c.prototype.jmulAdd=function(e,t,i){return this.curve._wnafMulAdd(1,[this,t],[e,i],2,!0)},c.prototype.normalize=function(){if(this.zOne)return this;var e=this.z.redInvm();return this.x=this.x.redMul(e),this.y=this.y.redMul(e),this.t&&(this.t=this.t.redMul(e)),this.z=this.curve.one,this.zOne=!0,this},c.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},c.prototype.getX=function(){return this.normalize(),this.x.fromRed()},c.prototype.getY=function(){return this.normalize(),this.y.fromRed()},c.prototype.eq=function(e){return this===e||0===this.getX().cmp(e.getX())&&0===this.getY().cmp(e.getY())},c.prototype.eqXToP=function(e){var t=e.toRed(this.curve.red).redMul(this.z);if(0===this.x.cmp(t))return!0;for(var i=e.clone(),r=this.curve.redN.redMul(this.z);;){if(i.iadd(this.curve.n),0<=i.cmp(this.curve.p))return!1;if(t.redIAdd(r),0===this.x.cmp(t))return!0}},c.prototype.toP=c.prototype.normalize,c.prototype.mixedAdd=c.prototype.add},{"../utils":15,"./base":2,"bn.js":16,inherits:32}],4:[function(e,t,i){"use strict";i.base=e("./base"),i.short=e("./short"),i.mont=e("./mont"),i.edwards=e("./edwards")},{"./base":2,"./edwards":3,"./mont":5,"./short":6}],5:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("inherits"),d=e("./base"),n=e("../utils");function a(e){d.call(this,"mont",e),this.a=new r(e.a,16).toRed(this.red),this.b=new r(e.b,16).toRed(this.red),this.i4=new r(4).toRed(this.red).redInvm(),this.two=new r(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}function s(e,t,i){d.BasePoint.call(this,e,"projective"),null===t&&null===i?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new r(t,16),this.z=new r(i,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}f(a,d),(t.exports=a).prototype.validate=function(e){var t=e.normalize().x,e=t.redSqr(),t=e.redMul(t).redAdd(e.redMul(this.a)).redAdd(t);return 0===t.redSqrt().redSqr().cmp(t)},f(s,d.BasePoint),a.prototype.decodePoint=function(e,t){return this.point(n.toArray(e,t),1)},a.prototype.point=function(e,t){return new s(this,e,t)},a.prototype.pointFromJSON=function(e){return s.fromJSON(this,e)},s.prototype.precompute=function(){},s.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())},s.fromJSON=function(e,t){return new s(e,t[0],t[1]||e.one)},s.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},s.prototype.isInfinity=function(){return 0===this.z.cmpn(0)},s.prototype.dbl=function(){var e=this.x.redAdd(this.z).redSqr(),t=this.x.redSub(this.z).redSqr(),i=e.redSub(t),e=e.redMul(t),i=i.redMul(t.redAdd(this.curve.a24.redMul(i)));return this.curve.point(e,i)},s.prototype.add=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.diffAdd=function(e,t){var i=this.x.redAdd(this.z),r=this.x.redSub(this.z),f=e.x.redAdd(e.z),i=e.x.redSub(e.z).redMul(i),f=f.redMul(r),r=t.z.redMul(i.redAdd(f).redSqr()),f=t.x.redMul(i.redISub(f).redSqr());return this.curve.point(r,f)},s.prototype.mul=function(e){for(var t=e.clone(),i=this,r=this.curve.point(null,null),f=[];0!==t.cmpn(0);t.iushrn(1))f.push(t.andln(1));for(var d=f.length-1;0<=d;d--)0===f[d]?(i=i.diffAdd(r,this),r=r.dbl()):(r=i.diffAdd(r,this),i=i.dbl());return r},s.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")},s.prototype.eq=function(e){return 0===this.getX().cmp(e.getX())},s.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},s.prototype.getX=function(){return this.normalize(),this.x.fromRed()}},{"../utils":15,"./base":2,"bn.js":16,inherits:32}],6:[function(e,t,i){"use strict";var r=e("../utils"),y=e("bn.js"),f=e("inherits"),d=e("./base"),n=r.assert;function a(e){d.call(this,"short",e),this.a=new y(e.a,16).toRed(this.red),this.b=new y(e.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(e),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}function s(e,t,i,r){d.BasePoint.call(this,e,"affine"),null===t&&null===i?(this.x=null,this.y=null,this.inf=!0):(this.x=new y(t,16),this.y=new y(i,16),r&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}function c(e,t,i,r){d.BasePoint.call(this,e,"jacobian"),null===t&&null===i&&null===r?(this.x=this.curve.one,this.y=this.curve.one,this.z=new y(0)):(this.x=new y(t,16),this.y=new y(i,16),this.z=new y(r,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}f(a,d),(t.exports=a).prototype._getEndomorphism=function(e){var t,i,r;if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3))return i=(e.beta?new y(e.beta,16):i=(r=this._getEndoRoots(this.p))[0].cmp(r[1])<0?r[0]:r[1]).toRed(this.red),e.lambda?t=new y(e.lambda,16):(r=this._getEndoRoots(this.n),0===this.g.mul(r[0]).x.cmp(this.g.x.redMul(i))?t=r[0]:(t=r[1],n(0===this.g.mul(t).x.cmp(this.g.x.redMul(i))))),{beta:i,lambda:t,basis:e.basis?e.basis.map(function(e){return{a:new y(e.a,16),b:new y(e.b,16)}}):this._getEndoBasis(t)}},a.prototype._getEndoRoots=function(e){var t=e===this.p?this.red:y.mont(e),i=new y(2).toRed(t).redInvm(),e=i.redNeg(),i=new y(3).toRed(t).redNeg().redSqrt().redMul(i);return[e.redAdd(i).fromRed(),e.redSub(i).fromRed()]},a.prototype._getEndoBasis=function(e){for(var t,i,r,f,d,n,a,s=this.n.ushrn(Math.floor(this.n.bitLength()/2)),c=e,h=this.n.clone(),o=new y(1),u=new y(0),b=new y(0),l=new y(1),p=0;0!==c.cmpn(0);){var m=h.div(c),v=h.sub(m.mul(c)),g=b.sub(m.mul(o)),m=l.sub(m.mul(u));if(!r&&v.cmp(s)<0)t=a.neg(),i=o,r=v.neg(),f=g;else if(r&&2==++p)break;h=c,c=a=v,b=o,o=g,l=u,u=m}d=v.neg(),n=g;e=r.sqr().add(f.sqr());return 0<=d.sqr().add(n.sqr()).cmp(e)&&(d=t,n=i),r.negative&&(r=r.neg(),f=f.neg()),d.negative&&(d=d.neg(),n=n.neg()),[{a:r,b:f},{a:d,b:n}]},a.prototype._endoSplit=function(e){var t=this.endo.basis,i=t[0],r=t[1],f=r.b.mul(e).divRound(this.n),d=i.b.neg().mul(e).divRound(this.n),n=f.mul(i.a),t=d.mul(r.a),i=f.mul(i.b),r=d.mul(r.b);return{k1:e.sub(n).sub(t),k2:i.add(r).neg()}},a.prototype.pointFromX=function(e,t){var i=(e=!(e=new y(e,16)).red?e.toRed(this.red):e).redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),r=i.redSqrt();if(0!==r.redSqr().redSub(i).cmp(this.zero))throw new Error("invalid point");i=r.fromRed().isOdd();return(t&&!i||!t&&i)&&(r=r.redNeg()),this.point(e,r)},a.prototype.validate=function(e){if(e.inf)return!0;var t=e.x,i=e.y,e=this.a.redMul(t),e=t.redSqr().redMul(t).redIAdd(e).redIAdd(this.b);return 0===i.redSqr().redISub(e).cmpn(0)},a.prototype._endoWnafMulAdd=function(e,t,i){for(var r=this._endoWnafT1,f=this._endoWnafT2,d=0;d<e.length;d++){var n=this._endoSplit(t[d]),a=e[d],s=a._getBeta();n.k1.negative&&(n.k1.ineg(),a=a.neg(!0)),n.k2.negative&&(n.k2.ineg(),s=s.neg(!0)),r[2*d]=a,r[2*d+1]=s,f[2*d]=n.k1,f[2*d+1]=n.k2}for(var i=this._wnafMulAdd(1,r,f,2*d,i),c=0;c<2*d;c++)r[c]=null,f[c]=null;return i},f(s,d.BasePoint),a.prototype.point=function(e,t,i){return new s(this,e,t,i)},a.prototype.pointFromJSON=function(e,t){return s.fromJSON(this,e,t)},s.prototype._getBeta=function(){if(this.curve.endo){var e=this.precomputed;if(e&&e.beta)return e.beta;var t,i,r=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);return e&&(t=this.curve,i=function(e){return t.point(e.x.redMul(t.endo.beta),e.y)},(e.beta=r).precomputed={beta:null,naf:e.naf&&{wnd:e.naf.wnd,points:e.naf.points.map(i)},doubles:e.doubles&&{step:e.doubles.step,points:e.doubles.points.map(i)}}),r}},s.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},s.fromJSON=function(t,e,i){"string"==typeof e&&(e=JSON.parse(e));var r=t.point(e[0],e[1],i);if(!e[2])return r;function f(e){return t.point(e[0],e[1],i)}e=e[2];return r.precomputed={beta:null,doubles:e.doubles&&{step:e.doubles.step,points:[r].concat(e.doubles.points.map(f))},naf:e.naf&&{wnd:e.naf.wnd,points:[r].concat(e.naf.points.map(f))}},r},s.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},s.prototype.isInfinity=function(){return this.inf},s.prototype.add=function(e){if(this.inf)return e;if(e.inf)return this;if(this.eq(e))return this.dbl();if(this.neg().eq(e))return this.curve.point(null,null);if(0===this.x.cmp(e.x))return this.curve.point(null,null);var t=this.y.redSub(e.y),e=(t=0!==t.cmpn(0)?t.redMul(this.x.redSub(e.x).redInvm()):t).redSqr().redISub(this.x).redISub(e.x),t=t.redMul(this.x.redSub(e)).redISub(this.y);return this.curve.point(e,t)},s.prototype.dbl=function(){if(this.inf)return this;var e=this.y.redAdd(this.y);if(0===e.cmpn(0))return this.curve.point(null,null);var t=this.curve.a,i=this.x.redSqr(),e=e.redInvm(),t=i.redAdd(i).redIAdd(i).redIAdd(t).redMul(e),e=t.redSqr().redISub(this.x.redAdd(this.x)),t=t.redMul(this.x.redSub(e)).redISub(this.y);return this.curve.point(e,t)},s.prototype.getX=function(){return this.x.fromRed()},s.prototype.getY=function(){return this.y.fromRed()},s.prototype.mul=function(e){return e=new y(e,16),this.isInfinity()?this:this._hasDoubles(e)?this.curve._fixedNafMul(this,e):this.curve.endo?this.curve._endoWnafMulAdd([this],[e]):this.curve._wnafMul(this,e)},s.prototype.mulAdd=function(e,t,i){t=[this,t],i=[e,i];return this.curve.endo?this.curve._endoWnafMulAdd(t,i):this.curve._wnafMulAdd(1,t,i,2)},s.prototype.jmulAdd=function(e,t,i){t=[this,t],i=[e,i];return this.curve.endo?this.curve._endoWnafMulAdd(t,i,!0):this.curve._wnafMulAdd(1,t,i,2,!0)},s.prototype.eq=function(e){return this===e||this.inf===e.inf&&(this.inf||0===this.x.cmp(e.x)&&0===this.y.cmp(e.y))},s.prototype.neg=function(e){if(this.inf)return this;var t,i=this.curve.point(this.x,this.y.redNeg());return e&&this.precomputed&&(t=this.precomputed,e=function(e){return e.neg()},i.precomputed={naf:t.naf&&{wnd:t.naf.wnd,points:t.naf.points.map(e)},doubles:t.doubles&&{step:t.doubles.step,points:t.doubles.points.map(e)}}),i},s.prototype.toJ=function(){return this.inf?this.curve.jpoint(null,null,null):this.curve.jpoint(this.x,this.y,this.curve.one)},f(c,d.BasePoint),a.prototype.jpoint=function(e,t,i){return new c(this,e,t,i)},c.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var e=this.z.redInvm(),t=e.redSqr(),i=this.x.redMul(t),e=this.y.redMul(t).redMul(e);return this.curve.point(i,e)},c.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},c.prototype.add=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.z.redSqr(),i=this.z.redSqr(),r=this.x.redMul(t),f=e.x.redMul(i),d=this.y.redMul(t.redMul(e.z)),n=e.y.redMul(i.redMul(this.z)),t=r.redSub(f),i=d.redSub(n);if(0===t.cmpn(0))return 0!==i.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();f=t.redSqr(),n=f.redMul(t),r=r.redMul(f),f=i.redSqr().redIAdd(n).redISub(r).redISub(r),n=i.redMul(r.redISub(f)).redISub(d.redMul(n)),t=this.z.redMul(e.z).redMul(t);return this.curve.jpoint(f,n,t)},c.prototype.mixedAdd=function(e){if(this.isInfinity())return e.toJ();if(e.isInfinity())return this;var t=this.z.redSqr(),i=this.x,r=e.x.redMul(t),f=this.y,d=e.y.redMul(t).redMul(this.z),e=i.redSub(r),t=f.redSub(d);if(0===e.cmpn(0))return 0!==t.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();r=e.redSqr(),d=r.redMul(e),i=i.redMul(r),r=t.redSqr().redIAdd(d).redISub(i).redISub(i),d=t.redMul(i.redISub(r)).redISub(f.redMul(d)),e=this.z.redMul(e);return this.curve.jpoint(r,d,e)},c.prototype.dblp=function(e){if(0===e)return this;if(this.isInfinity())return this;if(!e)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var t=this,i=0;i<e;i++)t=t.dbl();return t}var r=this.curve.a,f=this.curve.tinv,d=this.x,n=this.y,a=this.z,s=a.redSqr().redSqr(),c=n.redAdd(n);for(i=0;i<e;i++){var h=d.redSqr(),o=c.redSqr(),u=o.redSqr(),b=h.redAdd(h).redIAdd(h).redIAdd(r.redMul(s)),h=d.redMul(o),o=b.redSqr().redISub(h.redAdd(h)),h=h.redISub(o),b=(b=b.redMul(h)).redIAdd(b).redISub(u),h=c.redMul(a);i+1<e&&(s=s.redMul(u)),d=o,a=h,c=b}return this.curve.jpoint(d,c.redMul(f),a)},c.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},c.prototype._zeroDbl=function(){var e,t,i,r,f,d=this.zOne?(i=this.x.redSqr(),e=(r=this.y.redSqr()).redSqr(),f=(f=this.x.redAdd(r).redSqr().redISub(i).redISub(e)).redIAdd(f),r=(t=i.redAdd(i).redIAdd(i)).redSqr().redISub(f).redISub(f),i=(i=(i=e.redIAdd(e)).redIAdd(i)).redIAdd(i),e=r,t=t.redMul(f.redISub(r)).redISub(i),this.y.redAdd(this.y)):(f=this.x.redSqr(),d=(r=this.y.redSqr()).redSqr(),i=(i=this.x.redAdd(r).redSqr().redISub(f).redISub(d)).redIAdd(i),f=(r=f.redAdd(f).redIAdd(f)).redSqr(),d=(d=(d=d.redIAdd(d)).redIAdd(d)).redIAdd(d),e=f.redISub(i).redISub(i),t=r.redMul(i.redISub(e)).redISub(d),(d=this.y.redMul(this.z)).redIAdd(d));return this.curve.jpoint(e,t,d)},c.prototype._threeDbl=function(){var e,t,i,r,f,d,n,a;return this.zOne?(e=this.x.redSqr(),r=(t=this.y.redSqr()).redSqr(),n=(n=this.x.redAdd(t).redSqr().redISub(e).redISub(r)).redIAdd(n),i=f=(a=e.redAdd(e).redIAdd(e).redIAdd(this.curve.a)).redSqr().redISub(n).redISub(n),d=(d=(d=r.redIAdd(r)).redIAdd(d)).redIAdd(d),t=a.redMul(n.redISub(f)).redISub(d),e=this.y.redAdd(this.y)):(r=this.z.redSqr(),a=this.y.redSqr(),n=this.x.redMul(a),f=(f=this.x.redSub(r).redMul(this.x.redAdd(r))).redAdd(f).redIAdd(f),n=(d=(d=n.redIAdd(n)).redIAdd(d)).redAdd(d),i=f.redSqr().redISub(n),e=this.y.redAdd(this.z).redSqr().redISub(a).redISub(r),a=(a=(a=(a=a.redSqr()).redIAdd(a)).redIAdd(a)).redIAdd(a),t=f.redMul(d.redISub(i)).redISub(a)),this.curve.jpoint(i,t,e)},c.prototype._dbl=function(){var e=this.curve.a,t=this.x,i=this.y,r=this.z,f=r.redSqr().redSqr(),d=t.redSqr(),n=i.redSqr(),e=d.redAdd(d).redIAdd(d).redIAdd(e.redMul(f)),f=t.redAdd(t),t=(f=f.redIAdd(f)).redMul(n),f=e.redSqr().redISub(t.redAdd(t)),t=t.redISub(f),n=n.redSqr();n=(n=(n=n.redIAdd(n)).redIAdd(n)).redIAdd(n);n=e.redMul(t).redISub(n),r=i.redAdd(i).redMul(r);return this.curve.jpoint(f,n,r)},c.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var e=this.x.redSqr(),t=this.y.redSqr(),i=this.z.redSqr(),r=t.redSqr(),f=e.redAdd(e).redIAdd(e),d=f.redSqr(),n=this.x.redAdd(t).redSqr().redISub(e).redISub(r),e=(n=(n=(n=n.redIAdd(n)).redAdd(n).redIAdd(n)).redISub(d)).redSqr(),r=r.redIAdd(r);r=(r=(r=r.redIAdd(r)).redIAdd(r)).redIAdd(r);d=f.redIAdd(n).redSqr().redISub(d).redISub(e).redISub(r),t=t.redMul(d);t=(t=t.redIAdd(t)).redIAdd(t);t=this.x.redMul(e).redISub(t);t=(t=t.redIAdd(t)).redIAdd(t);d=this.y.redMul(d.redMul(r.redISub(d)).redISub(n.redMul(e)));d=(d=(d=d.redIAdd(d)).redIAdd(d)).redIAdd(d);e=this.z.redAdd(n).redSqr().redISub(i).redISub(e);return this.curve.jpoint(t,d,e)},c.prototype.mul=function(e,t){return e=new y(e,t),this.curve._wnafMul(this,e)},c.prototype.eq=function(e){if("affine"===e.type)return this.eq(e.toJ());if(this===e)return!0;var t=this.z.redSqr(),i=e.z.redSqr();if(0!==this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0))return!1;t=t.redMul(this.z),i=i.redMul(e.z);return 0===this.y.redMul(i).redISub(e.y.redMul(t)).cmpn(0)},c.prototype.eqXToP=function(e){var t=this.z.redSqr(),i=e.toRed(this.curve.red).redMul(t);if(0===this.x.cmp(i))return!0;for(var r=e.clone(),f=this.curve.redN.redMul(t);;){if(r.iadd(this.curve.n),0<=r.cmp(this.curve.p))return!1;if(i.redIAdd(f),0===this.x.cmp(i))return!0}},c.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},c.prototype.isInfinity=function(){return 0===this.z.cmpn(0)}},{"../utils":15,"./base":2,"bn.js":16,inherits:32}],7:[function(e,t,i){"use strict";var r,f=i,i=e("hash.js"),d=e("./curve"),n=e("./utils").assert;function a(e){"short"===e.type?this.curve=new d.short(e):"edwards"===e.type?this.curve=new d.edwards(e):this.curve=new d.mont(e),this.g=this.curve.g,this.n=this.curve.n,this.hash=e.hash,n(this.g.validate(),"Invalid curve"),n(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}function s(t,i){Object.defineProperty(f,t,{configurable:!0,enumerable:!0,get:function(){var e=new a(i);return Object.defineProperty(f,t,{configurable:!0,enumerable:!0,value:e}),e}})}f.PresetCurve=a,s("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:i.sha256,gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),s("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:i.sha256,gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),s("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:i.sha256,gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),s("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:i.sha384,gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),s("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:i.sha512,gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),s("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:i.sha256,gRed:!1,g:["9"]}),s("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:i.sha256,gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});try{r=e("./precomputed/secp256k1")}catch(e){r=void 0}s("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:i.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",r]})},{"./curve":4,"./precomputed/secp256k1":14,"./utils":15,"hash.js":19}],8:[function(e,t,i){"use strict";var u=e("bn.js"),b=e("hmac-drbg"),r=e("../utils"),f=e("../curves"),d=e("brorand"),a=r.assert,n=e("./key"),l=e("./signature");function s(e){if(!(this instanceof s))return new s(e);"string"==typeof e&&(a(Object.prototype.hasOwnProperty.call(f,e),"Unknown curve "+e),e=f[e]),e instanceof f.PresetCurve&&(e={curve:e}),this.curve=e.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=e.curve.g,this.g.precompute(e.curve.n.bitLength()+1),this.hash=e.hash||e.curve.hash}(t.exports=s).prototype.keyPair=function(e){return new n(this,e)},s.prototype.keyFromPrivate=function(e,t){return n.fromPrivate(this,e,t)},s.prototype.keyFromPublic=function(e,t){return n.fromPublic(this,e,t)},s.prototype.genKeyPair=function(e){e=e||{};for(var t=new b({hash:this.hash,pers:e.pers,persEnc:e.persEnc||"utf8",entropy:e.entropy||d(this.hash.hmacStrength),entropyEnc:e.entropy&&e.entropyEnc||"utf8",nonce:this.n.toArray()}),i=this.n.byteLength(),r=this.n.sub(new u(2));;){var f=new u(t.generate(i));if(!(0<f.cmp(r)))return f.iaddn(1),this.keyFromPrivate(f)}},s.prototype._truncateToN=function(e,t){var i=8*e.byteLength()-this.n.bitLength();return 0<i&&(e=e.ushrn(i)),!t&&0<=e.cmp(this.n)?e.sub(this.n):e},s.prototype.sign=function(e,t,i,r){"object"==typeof i&&(r=i,i=null),r=r||{},t=this.keyFromPrivate(t,i),e=this._truncateToN(new u(e,16));for(var f=this.n.byteLength(),i=t.getPrivate().toArray("be",f),f=e.toArray("be",f),d=new b({hash:this.hash,entropy:i,nonce:f,pers:r.pers,persEnc:r.persEnc||"utf8"}),n=this.n.sub(new u(1)),a=0;;a++){var s=r.k?r.k(a):new u(d.generate(this.n.byteLength()));if(!((s=this._truncateToN(s,!0)).cmpn(1)<=0||0<=s.cmp(n))){var c=this.g.mul(s);if(!c.isInfinity()){var h=c.getX(),o=h.umod(this.n);if(0!==o.cmpn(0)){s=s.invm(this.n).mul(o.mul(t.getPrivate()).iadd(e));if(0!==(s=s.umod(this.n)).cmpn(0)){h=(c.getY().isOdd()?1:0)|(0!==h.cmp(o)?2:0);return r.canonical&&0<s.cmp(this.nh)&&(s=this.n.sub(s),h^=1),new l({r:o,s:s,recoveryParam:h})}}}}}},s.prototype.verify=function(e,t,i,r){e=this._truncateToN(new u(e,16)),i=this.keyFromPublic(i,r);r=(t=new l(t,"hex")).r,t=t.s;if(r.cmpn(1)<0||0<=r.cmp(this.n))return!1;if(t.cmpn(1)<0||0<=t.cmp(this.n))return!1;var f,t=t.invm(this.n),e=t.mul(e).umod(this.n),t=t.mul(r).umod(this.n);return this.curve._maxwellTrick?!(f=this.g.jmulAdd(e,i.getPublic(),t)).isInfinity()&&f.eqXToP(r):!(f=this.g.mulAdd(e,i.getPublic(),t)).isInfinity()&&0===f.getX().umod(this.n).cmp(r)},s.prototype.recoverPubKey=function(e,t,i,r){a((3&i)===i,"The recovery param is more than two bits"),t=new l(t,r);var f=this.n,d=new u(e),n=t.r,r=t.s,e=1&i,i=i>>1;if(0<=n.cmp(this.curve.p.umod(this.curve.n))&&i)throw new Error("Unable to find sencond key candinate");n=i?this.curve.pointFromX(n.add(this.curve.n),e):this.curve.pointFromX(n,e);t=t.r.invm(f),d=f.sub(d).mul(t).umod(f),f=r.mul(t).umod(f);return this.g.mulAdd(d,n,f)},s.prototype.getKeyRecoveryParam=function(e,t,i,r){if(null!==(t=new l(t,r)).recoveryParam)return t.recoveryParam;for(var f,d=0;d<4;d++){try{f=this.recoverPubKey(e,t,d)}catch(e){continue}if(f.eq(i))return d}throw new Error("Unable to find valid recovery factor")}},{"../curves":7,"../utils":15,"./key":9,"./signature":10,"bn.js":16,brorand:17,"hmac-drbg":31}],9:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../utils").assert;function d(e,t){this.ec=e,this.priv=null,this.pub=null,t.priv&&this._importPrivate(t.priv,t.privEnc),t.pub&&this._importPublic(t.pub,t.pubEnc)}(t.exports=d).fromPublic=function(e,t,i){return t instanceof d?t:new d(e,{pub:t,pubEnc:i})},d.fromPrivate=function(e,t,i){return t instanceof d?t:new d(e,{priv:t,privEnc:i})},d.prototype.validate=function(){var e=this.getPublic();return e.isInfinity()?{result:!1,reason:"Invalid public key"}:e.validate()?e.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},d.prototype.getPublic=function(e,t){return"string"==typeof e&&(t=e,e=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),t?this.pub.encode(t,e):this.pub},d.prototype.getPrivate=function(e){return"hex"===e?this.priv.toString(16,2):this.priv},d.prototype._importPrivate=function(e,t){this.priv=new r(e,t||16),this.priv=this.priv.umod(this.ec.curve.n)},d.prototype._importPublic=function(e,t){if(e.x||e.y)return"mont"===this.ec.curve.type?f(e.x,"Need x coordinate"):"short"!==this.ec.curve.type&&"edwards"!==this.ec.curve.type||f(e.x&&e.y,"Need both x and y coordinate"),void(this.pub=this.ec.curve.point(e.x,e.y));this.pub=this.ec.curve.decodePoint(e,t)},d.prototype.derive=function(e){return e.validate()||f(e.validate(),"public point not validated"),e.mul(this.priv).getX()},d.prototype.sign=function(e,t,i){return this.ec.sign(e,this,t,i)},d.prototype.verify=function(e,t){return this.ec.verify(e,t,this)},d.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"}},{"../utils":15,"bn.js":16}],10:[function(e,t,i){"use strict";var f=e("bn.js"),d=e("../utils"),r=d.assert;function n(e,t){if(e instanceof n)return e;this._importDER(e,t)||(r(e.r&&e.s,"Signature without r or s"),this.r=new f(e.r,16),this.s=new f(e.s,16),void 0===e.recoveryParam?this.recoveryParam=null:this.recoveryParam=e.recoveryParam)}function a(){this.place=0}function s(e,t){var i=e[t.place++];if(!(128&i))return i;var r=15&i;if(0==r||4<r)return!1;for(var f=0,d=0,n=t.place;d<r;d++,n++)f<<=8,f|=e[n],f>>>=0;return!(f<=127)&&(t.place=n,f)}function c(e){for(var t=0,i=e.length-1;!e[t]&&!(128&e[t+1])&&t<i;)t++;return 0===t?e:e.slice(t)}function h(e,t){if(t<128)e.push(t);else{var i=1+(Math.log(t)/Math.LN2>>>3);for(e.push(128|i);--i;)e.push(t>>>(i<<3)&255);e.push(t)}}(t.exports=n).prototype._importDER=function(e,t){e=d.toArray(e,t);var i=new a;if(48!==e[i.place++])return!1;var r=s(e,i);if(!1===r)return!1;if(r+i.place!==e.length)return!1;if(2!==e[i.place++])return!1;t=s(e,i);if(!1===t)return!1;r=e.slice(i.place,t+i.place);if(i.place+=t,2!==e[i.place++])return!1;t=s(e,i);if(!1===t)return!1;if(e.length!==t+i.place)return!1;i=e.slice(i.place,t+i.place);if(0===r[0]){if(!(128&r[1]))return!1;r=r.slice(1)}if(0===i[0]){if(!(128&i[1]))return!1;i=i.slice(1)}return this.r=new f(r),this.s=new f(i),!(this.recoveryParam=null)},n.prototype.toDER=function(e){var t=this.r.toArray(),i=this.s.toArray();for(128&t[0]&&(t=[0].concat(t)),128&i[0]&&(i=[0].concat(i)),t=c(t),i=c(i);!(i[0]||128&i[1]);)i=i.slice(1);var r=[2];h(r,t.length),(r=r.concat(t)).push(2),h(r,i.length);t=r.concat(i),r=[48];return h(r,t.length),r=r.concat(t),d.encode(r,e)}},{"../utils":15,"bn.js":16}],11:[function(e,t,i){"use strict";var r=e("hash.js"),f=e("../curves"),d=e("../utils"),n=d.assert,a=d.parseBytes,s=e("./key"),c=e("./signature");function h(e){if(n("ed25519"===e,"only tested with ed25519 so far"),!(this instanceof h))return new h(e);e=f[e].curve,this.curve=e,this.g=e.g,this.g.precompute(e.n.bitLength()+1),this.pointClass=e.point().constructor,this.encodingLength=Math.ceil(e.n.bitLength()/8),this.hash=r.sha512}(t.exports=h).prototype.sign=function(e,t){e=a(e);var i=this.keyFromSecret(t),r=this.hashInt(i.messagePrefix(),e),f=this.g.mul(r),t=this.encodePoint(f),i=this.hashInt(t,i.pubBytes(),e).mul(i.priv()),i=r.add(i).umod(this.curve.n);return this.makeSignature({R:f,S:i,Rencoded:t})},h.prototype.verify=function(e,t,i){e=a(e),t=this.makeSignature(t);var r=this.keyFromPublic(i),i=this.hashInt(t.Rencoded(),r.pubBytes(),e),e=this.g.mul(t.S());return t.R().add(r.pub().mul(i)).eq(e)},h.prototype.hashInt=function(){for(var e=this.hash(),t=0;t<arguments.length;t++)e.update(arguments[t]);return d.intFromLE(e.digest()).umod(this.curve.n)},h.prototype.keyFromPublic=function(e){return s.fromPublic(this,e)},h.prototype.keyFromSecret=function(e){return s.fromSecret(this,e)},h.prototype.makeSignature=function(e){return e instanceof c?e:new c(this,e)},h.prototype.encodePoint=function(e){var t=e.getY().toArray("le",this.encodingLength);return t[this.encodingLength-1]|=e.getX().isOdd()?128:0,t},h.prototype.decodePoint=function(e){var t=(e=d.parseBytes(e)).length-1,i=e.slice(0,t).concat(-129&e[t]),t=0!=(128&e[t]),i=d.intFromLE(i);return this.curve.pointFromY(i,t)},h.prototype.encodeInt=function(e){return e.toArray("le",this.encodingLength)},h.prototype.decodeInt=function(e){return d.intFromLE(e)},h.prototype.isPoint=function(e){return e instanceof this.pointClass}},{"../curves":7,"../utils":15,"./key":12,"./signature":13,"hash.js":19}],12:[function(e,t,i){"use strict";var r=e("../utils"),f=r.assert,d=r.parseBytes,e=r.cachedProperty;function n(e,t){this.eddsa=e,this._secret=d(t.secret),e.isPoint(t.pub)?this._pub=t.pub:this._pubBytes=d(t.pub)}n.fromPublic=function(e,t){return t instanceof n?t:new n(e,{pub:t})},n.fromSecret=function(e,t){return t instanceof n?t:new n(e,{secret:t})},n.prototype.secret=function(){return this._secret},e(n,"pubBytes",function(){return this.eddsa.encodePoint(this.pub())}),e(n,"pub",function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())}),e(n,"privBytes",function(){var e=this.eddsa,t=this.hash(),i=e.encodingLength-1,e=t.slice(0,e.encodingLength);return e[0]&=248,e[i]&=127,e[i]|=64,e}),e(n,"priv",function(){return this.eddsa.decodeInt(this.privBytes())}),e(n,"hash",function(){return this.eddsa.hash().update(this.secret()).digest()}),e(n,"messagePrefix",function(){return this.hash().slice(this.eddsa.encodingLength)}),n.prototype.sign=function(e){return f(this._secret,"KeyPair can only verify"),this.eddsa.sign(e,this)},n.prototype.verify=function(e,t){return this.eddsa.verify(e,t,this)},n.prototype.getSecret=function(e){return f(this._secret,"KeyPair is public only"),r.encode(this.secret(),e)},n.prototype.getPublic=function(e){return r.encode(this.pubBytes(),e)},t.exports=n},{"../utils":15}],13:[function(e,t,i){"use strict";var r=e("bn.js"),f=e("../utils"),d=f.assert,e=f.cachedProperty,n=f.parseBytes;function a(e,t){this.eddsa=e,"object"!=typeof t&&(t=n(t)),Array.isArray(t)&&(t={R:t.slice(0,e.encodingLength),S:t.slice(e.encodingLength)}),d(t.R&&t.S,"Signature without R or S"),e.isPoint(t.R)&&(this._R=t.R),t.S instanceof r&&(this._S=t.S),this._Rencoded=Array.isArray(t.R)?t.R:t.Rencoded,this._Sencoded=Array.isArray(t.S)?t.S:t.Sencoded}e(a,"S",function(){return this.eddsa.decodeInt(this.Sencoded())}),e(a,"R",function(){return this.eddsa.decodePoint(this.Rencoded())}),e(a,"Rencoded",function(){return this.eddsa.encodePoint(this.R())}),e(a,"Sencoded",function(){return this.eddsa.encodeInt(this.S())}),a.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())},a.prototype.toHex=function(){return f.encode(this.toBytes(),"hex").toUpperCase()},t.exports=a},{"../utils":15,"bn.js":16}],14:[function(e,t,i){t.exports={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}}},{}],15:[function(e,t,i){"use strict";var r=i,f=e("bn.js"),i=e("minimalistic-assert"),e=e("minimalistic-crypto-utils");r.assert=i,r.toArray=e.toArray,r.zero2=e.zero2,r.toHex=e.toHex,r.encode=e.encode,r.getNAF=function(e,t,i){var r=new Array(Math.max(e.bitLength(),i)+1);r.fill(0);for(var f=1<<t+1,d=e.clone(),n=0;n<r.length;n++){var a,s=d.andln(f-1);d.isOdd()?(a=(f>>1)-1<s?(f>>1)-s:s,d.isubn(a)):a=0,r[n]=a,d.iushrn(1)}return r},r.getJSF=function(e,t){var i=[[],[]];e=e.clone(),t=t.clone();for(var r,f=0,d=0;0<e.cmpn(-f)||0<t.cmpn(-d);){var n,a=e.andln(3)+f&3,s=t.andln(3)+d&3;3===s&&(s=-1),n=0==(1&(a=3===a?-1:a))?0:3!==(r=e.andln(7)+f&7)&&5!==r||2!==s?a:-a,i[0].push(n),s=0==(1&s)?0:3!==(r=t.andln(7)+d&7)&&5!==r||2!==a?s:-s,i[1].push(s),2*f===n+1&&(f=1-f),2*d===s+1&&(d=1-d),e.iushrn(1),t.iushrn(1)}return i},r.cachedProperty=function(e,t,i){var r="_"+t;e.prototype[t]=function(){return void 0!==this[r]?this[r]:this[r]=i.call(this)}},r.parseBytes=function(e){return"string"==typeof e?r.toArray(e,"hex"):e},r.intFromLE=function(e){return new f(e,"hex","le")}},{"bn.js":16,"minimalistic-assert":33,"minimalistic-crypto-utils":34}],16:[function(_,e,t){!function(e,t){"use strict";function p(e,t){if(!e)throw new Error(t||"Assertion failed")}function i(e,t){e.super_=t;function i(){}i.prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e}function m(e,t,i){if(m.isBN(e))return e;this.negative=0,this.words=null,this.length=0,(this.red=null)!==e&&("le"!==t&&"be"!==t||(i=t,t=10),this._init(e||0,t||10,i||"be"))}var r;"object"==typeof e?e.exports=m:t.BN=m,(m.BN=m).wordSize=26;try{r=_("buffer").Buffer}catch(e){}function n(e,t,i){for(var r=0,f=Math.min(e.length,i),d=t;d<f;d++){var n=e.charCodeAt(d)-48;r<<=4,r|=49<=n&&n<=54?n-49+10:17<=n&&n<=22?n-17+10:15&n}return r}function o(e,t,i,r){for(var f=0,d=Math.min(e.length,i),n=t;n<d;n++){var a=e.charCodeAt(n)-48;f*=r,f+=49<=a?a-49+10:17<=a?a-17+10:a}return f}m.isBN=function(e){return e instanceof m||null!==e&&"object"==typeof e&&e.constructor.wordSize===m.wordSize&&Array.isArray(e.words)},m.max=function(e,t){return 0<e.cmp(t)?e:t},m.min=function(e,t){return e.cmp(t)<0?e:t},m.prototype._init=function(e,t,i){if("number"==typeof e)return this._initNumber(e,t,i);if("object"==typeof e)return this._initArray(e,t,i);p((t="hex"===t?16:t)===(0|t)&&2<=t&&t<=36);var r=0;"-"===(e=e.toString().replace(/\s+/g,""))[0]&&r++,16===t?this._parseHex(e,r):this._parseBase(e,t,r),"-"===e[0]&&(this.negative=1),this.strip(),"le"===i&&this._initArray(this.toArray(),t,i)},m.prototype._initNumber=function(e,t,i){e<0&&(this.negative=1,e=-e),e<67108864?(this.words=[67108863&e],this.length=1):e<4503599627370496?(this.words=[67108863&e,e/67108864&67108863],this.length=2):(p(e<9007199254740992),this.words=[67108863&e,e/67108864&67108863,1],this.length=3),"le"===i&&this._initArray(this.toArray(),t,i)},m.prototype._initArray=function(e,t,i){if(p("number"==typeof e.length),e.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(e.length/3),this.words=new Array(this.length);for(var r,f,d=0;d<this.length;d++)this.words[d]=0;var n=0;if("be"===i)for(d=e.length-1,r=0;0<=d;d-=3)f=e[d]|e[d-1]<<8|e[d-2]<<16,this.words[r]|=f<<n&67108863,this.words[r+1]=f>>>26-n&67108863,26<=(n+=24)&&(n-=26,r++);else if("le"===i)for(r=d=0;d<e.length;d+=3)f=e[d]|e[d+1]<<8|e[d+2]<<16,this.words[r]|=f<<n&67108863,this.words[r+1]=f>>>26-n&67108863,26<=(n+=24)&&(n-=26,r++);return this.strip()},m.prototype._parseHex=function(e,t){this.length=Math.ceil((e.length-t)/6),this.words=new Array(this.length);for(var i,r=0;r<this.length;r++)this.words[r]=0;for(var f=0,r=e.length-6,d=0;t<=r;r-=6)i=n(e,r,r+6),this.words[d]|=i<<f&67108863,this.words[d+1]|=i>>>26-f&4194303,26<=(f+=24)&&(f-=26,d++);r+6!==t&&(i=n(e,t,r+6),this.words[d]|=i<<f&67108863,this.words[d+1]|=i>>>26-f&4194303),this.strip()},m.prototype._parseBase=function(e,t,i){this.words=[0];for(var r=0,f=this.length=1;f<=67108863;f*=t)r++;r--,f=f/t|0;for(var d=e.length-i,n=d%r,a=Math.min(d,d-n)+i,s=0,c=i;c<a;c+=r)s=o(e,c,c+r,t),this.imuln(f),this.words[0]+s<67108864?this.words[0]+=s:this._iaddn(s);if(0!=n){for(var h=1,s=o(e,c,e.length,t),c=0;c<n;c++)h*=t;this.imuln(h),this.words[0]+s<67108864?this.words[0]+=s:this._iaddn(s)}},m.prototype.copy=function(e){e.words=new Array(this.length);for(var t=0;t<this.length;t++)e.words[t]=this.words[t];e.length=this.length,e.negative=this.negative,e.red=this.red},m.prototype.clone=function(){var e=new m(null);return this.copy(e),e},m.prototype._expand=function(e){for(;this.length<e;)this.words[this.length++]=0;return this},m.prototype.strip=function(){for(;1<this.length&&0===this.words[this.length-1];)this.length--;return this._normSign()},m.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},m.prototype.inspect=function(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var u=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],b=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],l=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function f(e,t,i){i.negative=t.negative^e.negative;var r=e.length+t.length|0,r=(i.length=r)-1|0,f=67108863&(o=(0|e.words[0])*(0|t.words[0])),d=o/67108864|0;i.words[0]=f;for(var n=1;n<r;n++){for(var a=d>>>26,s=67108863&d,c=Math.min(n,t.length-1),h=Math.max(0,n-e.length+1);h<=c;h++){var o,u=n-h|0;a+=(o=(0|e.words[u])*(0|t.words[h])+s)/67108864|0,s=67108863&o}i.words[n]=0|s,d=0|a}return 0!==d?i.words[n]=0|d:i.length--,i.strip()}m.prototype.toString=function(e,t){if(t=0|t||1,16===(e=e||10)||"hex"===e){a="";for(var i=0,r=0,f=0;f<this.length;f++){var d=this.words[f],n=(16777215&(d<<i|r)).toString(16),a=0!==(r=d>>>24-i&16777215)||f!==this.length-1?u[6-n.length]+n+a:n+a;26<=(i+=2)&&(i-=26,f--)}for(0!==r&&(a=r.toString(16)+a);a.length%t!=0;)a="0"+a;return a=0!==this.negative?"-"+a:a}if(e===(0|e)&&2<=e&&e<=36){var s=b[e],c=l[e];for(a="",(h=this.clone()).negative=0;!h.isZero();){var h,o=h.modn(c).toString(e);a=(h=h.idivn(c)).isZero()?o+a:u[s-o.length]+o+a}for(this.isZero()&&(a="0"+a);a.length%t!=0;)a="0"+a;return a=0!==this.negative?"-"+a:a}p(!1,"Base should be between 2 and 36")},m.prototype.toNumber=function(){var e=this.words[0];return 2===this.length?e+=67108864*this.words[1]:3===this.length&&1===this.words[2]?e+=4503599627370496+67108864*this.words[1]:2<this.length&&p(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-e:e},m.prototype.toJSON=function(){return this.toString(16)},m.prototype.toBuffer=function(e,t){return p(void 0!==r),this.toArrayLike(r,e,t)},m.prototype.toArray=function(e,t){return this.toArrayLike(Array,e,t)},m.prototype.toArrayLike=function(e,t,i){var r=this.byteLength(),f=i||Math.max(1,r);p(r<=f,"byte array longer than desired length"),p(0<f,"Requested array length <= 0"),this.strip();var d,n,t="le"===t,a=new e(f),s=this.clone();if(t){for(n=0;!s.isZero();n++)d=s.andln(255),s.iushrn(8),a[n]=d;for(;n<f;n++)a[n]=0}else{for(n=0;n<f-r;n++)a[n]=0;for(n=0;!s.isZero();n++)d=s.andln(255),s.iushrn(8),a[f-n-1]=d}return a},Math.clz32?m.prototype._countBits=function(e){return 32-Math.clz32(e)}:m.prototype._countBits=function(e){var t=e,e=0;return 4096<=t&&(e+=13,t>>>=13),64<=t&&(e+=7,t>>>=7),8<=t&&(e+=4,t>>>=4),2<=t&&(e+=2,t>>>=2),e+t},m.prototype._zeroBits=function(e){if(0===e)return 26;var t=e,e=0;return 0==(8191&t)&&(e+=13,t>>>=13),0==(127&t)&&(e+=7,t>>>=7),0==(15&t)&&(e+=4,t>>>=4),0==(3&t)&&(e+=2,t>>>=2),0==(1&t)&&e++,e},m.prototype.bitLength=function(){var e=this.words[this.length-1],e=this._countBits(e);return 26*(this.length-1)+e},m.prototype.zeroBits=function(){if(this.isZero())return 0;for(var e=0,t=0;t<this.length;t++){var i=this._zeroBits(this.words[t]);if(e+=i,26!==i)break}return e},m.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},m.prototype.toTwos=function(e){return 0!==this.negative?this.abs().inotn(e).iaddn(1):this.clone()},m.prototype.fromTwos=function(e){return this.testn(e-1)?this.notn(e).iaddn(1).ineg():this.clone()},m.prototype.isNeg=function(){return 0!==this.negative},m.prototype.neg=function(){return this.clone().ineg()},m.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},m.prototype.iuor=function(e){for(;this.length<e.length;)this.words[this.length++]=0;for(var t=0;t<e.length;t++)this.words[t]=this.words[t]|e.words[t];return this.strip()},m.prototype.ior=function(e){return p(0==(this.negative|e.negative)),this.iuor(e)},m.prototype.or=function(e){return this.length>e.length?this.clone().ior(e):e.clone().ior(this)},m.prototype.uor=function(e){return this.length>e.length?this.clone().iuor(e):e.clone().iuor(this)},m.prototype.iuand=function(e){for(var t=this.length>e.length?e:this,i=0;i<t.length;i++)this.words[i]=this.words[i]&e.words[i];return this.length=t.length,this.strip()},m.prototype.iand=function(e){return p(0==(this.negative|e.negative)),this.iuand(e)},m.prototype.and=function(e){return this.length>e.length?this.clone().iand(e):e.clone().iand(this)},m.prototype.uand=function(e){return this.length>e.length?this.clone().iuand(e):e.clone().iuand(this)},m.prototype.iuxor=function(e){for(var t,i=this.length>e.length?(t=this,e):(t=e,this),r=0;r<i.length;r++)this.words[r]=t.words[r]^i.words[r];if(this!==t)for(;r<t.length;r++)this.words[r]=t.words[r];return this.length=t.length,this.strip()},m.prototype.ixor=function(e){return p(0==(this.negative|e.negative)),this.iuxor(e)},m.prototype.xor=function(e){return this.length>e.length?this.clone().ixor(e):e.clone().ixor(this)},m.prototype.uxor=function(e){return this.length>e.length?this.clone().iuxor(e):e.clone().iuxor(this)},m.prototype.inotn=function(e){p("number"==typeof e&&0<=e);var t=0|Math.ceil(e/26),e=e%26;this._expand(t),0<e&&t--;for(var i=0;i<t;i++)this.words[i]=67108863&~this.words[i];return 0<e&&(this.words[i]=~this.words[i]&67108863>>26-e),this.strip()},m.prototype.notn=function(e){return this.clone().inotn(e)},m.prototype.setn=function(e,t){p("number"==typeof e&&0<=e);var i=e/26|0,e=e%26;return this._expand(1+i),this.words[i]=t?this.words[i]|1<<e:this.words[i]&~(1<<e),this.strip()},m.prototype.iadd=function(e){var t,i,r;if(0!==this.negative&&0===e.negative)return this.negative=0,t=this.isub(e),this.negative^=1,this._normSign();if(0===this.negative&&0!==e.negative)return e.negative=0,t=this.isub(e),e.negative=1,t._normSign();r=this.length>e.length?(i=this,e):(i=e,this);for(var f=0,d=0;d<r.length;d++)t=(0|i.words[d])+(0|r.words[d])+f,this.words[d]=67108863&t,f=t>>>26;for(;0!==f&&d<i.length;d++)t=(0|i.words[d])+f,this.words[d]=67108863&t,f=t>>>26;if(this.length=i.length,0!==f)this.words[this.length]=f,this.length++;else if(i!==this)for(;d<i.length;d++)this.words[d]=i.words[d];return this},m.prototype.add=function(e){var t;return 0!==e.negative&&0===this.negative?(e.negative=0,t=this.sub(e),e.negative^=1,t):0===e.negative&&0!==this.negative?(this.negative=0,t=e.sub(this),this.negative=1,t):this.length>e.length?this.clone().iadd(e):e.clone().iadd(this)},m.prototype.isub=function(e){if(0!==e.negative){e.negative=0;var t=this.iadd(e);return e.negative=1,t._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(e),this.negative=1,this._normSign();var i,r,f=this.cmp(e);if(0===f)return this.negative=0,this.length=1,this.words[0]=0,this;r=0<f?(i=this,e):(i=e,this);for(var d=0,n=0;n<r.length;n++)d=(t=(0|i.words[n])-(0|r.words[n])+d)>>26,this.words[n]=67108863&t;for(;0!==d&&n<i.length;n++)d=(t=(0|i.words[n])+d)>>26,this.words[n]=67108863&t;if(0===d&&n<i.length&&i!==this)for(;n<i.length;n++)this.words[n]=i.words[n];return this.length=Math.max(this.length,n),i!==this&&(this.negative=1),this.strip()},m.prototype.sub=function(e){return this.clone().isub(e)};var d=function(e,t,i){var r=e.words,f=t.words,d=i.words,n=0|r[0],a=8191&n,s=n>>>13,c=0|r[1],h=8191&c,o=c>>>13,u=0|r[2],b=8191&u,l=u>>>13,p=0|r[3],m=8191&p,v=p>>>13,g=0|r[4],y=8191&g,M=g>>>13,w=0|r[5],S=8191&w,_=w>>>13,A=0|r[6],x=8191&A,I=A>>>13,z=0|r[7],q=8191&z,R=z>>>13,k=0|r[8],P=8191&k,j=k>>>13,N=0|r[9],E=8191&N,B=N>>>13,L=0|f[0],O=8191&L,F=L>>>13,T=0|f[1],C=8191&T,Z=T>>>13,J=0|f[2],H=8191&J,D=J>>>13,X=0|f[3],K=8191&X,V=X>>>13,W=0|f[4],U=8191&W,Y=W>>>13,G=0|f[5],Q=8191&G,$=G>>>13,n=0|f[6],c=8191&n,u=n>>>13,p=0|f[7],g=8191&p,w=p>>>13,A=0|f[8],z=8191&A,k=A>>>13,r=0|f[9],N=8191&r,L=r>>>13;i.negative=e.negative^t.negative,i.length=19;var X=(0+Math.imul(a,O)|0)+((8191&(J=Math.imul(a,F)+Math.imul(s,O)|0))<<13)|0,ee=(Math.imul(s,F)+(J>>>13)|0)+(X>>>26)|0;X&=67108863,T=Math.imul(h,O),J=Math.imul(h,F)+Math.imul(o,O)|0,W=Math.imul(o,F);G=(ee+(T+Math.imul(a,C)|0)|0)+((8191&(J=(J+Math.imul(a,Z)|0)+Math.imul(s,C)|0))<<13)|0;ee=((W+Math.imul(s,Z)|0)+(J>>>13)|0)+(G>>>26)|0,G&=67108863,T=Math.imul(b,O),J=Math.imul(b,F)+Math.imul(l,O)|0,W=Math.imul(l,F),T=T+Math.imul(h,C)|0,J=(J+Math.imul(h,Z)|0)+Math.imul(o,C)|0,W=W+Math.imul(o,Z)|0;n=(ee+(T+Math.imul(a,H)|0)|0)+((8191&(J=(J+Math.imul(a,D)|0)+Math.imul(s,H)|0))<<13)|0;ee=((W+Math.imul(s,D)|0)+(J>>>13)|0)+(n>>>26)|0,n&=67108863,T=Math.imul(m,O),J=Math.imul(m,F)+Math.imul(v,O)|0,W=Math.imul(v,F),T=T+Math.imul(b,C)|0,J=(J+Math.imul(b,Z)|0)+Math.imul(l,C)|0,W=W+Math.imul(l,Z)|0,T=T+Math.imul(h,H)|0,J=(J+Math.imul(h,D)|0)+Math.imul(o,H)|0,W=W+Math.imul(o,D)|0;p=(ee+(T+Math.imul(a,K)|0)|0)+((8191&(J=(J+Math.imul(a,V)|0)+Math.imul(s,K)|0))<<13)|0;ee=((W+Math.imul(s,V)|0)+(J>>>13)|0)+(p>>>26)|0,p&=67108863,T=Math.imul(y,O),J=Math.imul(y,F)+Math.imul(M,O)|0,W=Math.imul(M,F),T=T+Math.imul(m,C)|0,J=(J+Math.imul(m,Z)|0)+Math.imul(v,C)|0,W=W+Math.imul(v,Z)|0,T=T+Math.imul(b,H)|0,J=(J+Math.imul(b,D)|0)+Math.imul(l,H)|0,W=W+Math.imul(l,D)|0,T=T+Math.imul(h,K)|0,J=(J+Math.imul(h,V)|0)+Math.imul(o,K)|0,W=W+Math.imul(o,V)|0;A=(ee+(T+Math.imul(a,U)|0)|0)+((8191&(J=(J+Math.imul(a,Y)|0)+Math.imul(s,U)|0))<<13)|0;ee=((W+Math.imul(s,Y)|0)+(J>>>13)|0)+(A>>>26)|0,A&=67108863,T=Math.imul(S,O),J=Math.imul(S,F)+Math.imul(_,O)|0,W=Math.imul(_,F),T=T+Math.imul(y,C)|0,J=(J+Math.imul(y,Z)|0)+Math.imul(M,C)|0,W=W+Math.imul(M,Z)|0,T=T+Math.imul(m,H)|0,J=(J+Math.imul(m,D)|0)+Math.imul(v,H)|0,W=W+Math.imul(v,D)|0,T=T+Math.imul(b,K)|0,J=(J+Math.imul(b,V)|0)+Math.imul(l,K)|0,W=W+Math.imul(l,V)|0,T=T+Math.imul(h,U)|0,J=(J+Math.imul(h,Y)|0)+Math.imul(o,U)|0,W=W+Math.imul(o,Y)|0;f=(ee+(T+Math.imul(a,Q)|0)|0)+((8191&(J=(J+Math.imul(a,$)|0)+Math.imul(s,Q)|0))<<13)|0;ee=((W+Math.imul(s,$)|0)+(J>>>13)|0)+(f>>>26)|0,f&=67108863,T=Math.imul(x,O),J=Math.imul(x,F)+Math.imul(I,O)|0,W=Math.imul(I,F),T=T+Math.imul(S,C)|0,J=(J+Math.imul(S,Z)|0)+Math.imul(_,C)|0,W=W+Math.imul(_,Z)|0,T=T+Math.imul(y,H)|0,J=(J+Math.imul(y,D)|0)+Math.imul(M,H)|0,W=W+Math.imul(M,D)|0,T=T+Math.imul(m,K)|0,J=(J+Math.imul(m,V)|0)+Math.imul(v,K)|0,W=W+Math.imul(v,V)|0,T=T+Math.imul(b,U)|0,J=(J+Math.imul(b,Y)|0)+Math.imul(l,U)|0,W=W+Math.imul(l,Y)|0,T=T+Math.imul(h,Q)|0,J=(J+Math.imul(h,$)|0)+Math.imul(o,Q)|0,W=W+Math.imul(o,$)|0;r=(ee+(T+Math.imul(a,c)|0)|0)+((8191&(J=(J+Math.imul(a,u)|0)+Math.imul(s,c)|0))<<13)|0;ee=((W+Math.imul(s,u)|0)+(J>>>13)|0)+(r>>>26)|0,r&=67108863,T=Math.imul(q,O),J=Math.imul(q,F)+Math.imul(R,O)|0,W=Math.imul(R,F),T=T+Math.imul(x,C)|0,J=(J+Math.imul(x,Z)|0)+Math.imul(I,C)|0,W=W+Math.imul(I,Z)|0,T=T+Math.imul(S,H)|0,J=(J+Math.imul(S,D)|0)+Math.imul(_,H)|0,W=W+Math.imul(_,D)|0,T=T+Math.imul(y,K)|0,J=(J+Math.imul(y,V)|0)+Math.imul(M,K)|0,W=W+Math.imul(M,V)|0,T=T+Math.imul(m,U)|0,J=(J+Math.imul(m,Y)|0)+Math.imul(v,U)|0,W=W+Math.imul(v,Y)|0,T=T+Math.imul(b,Q)|0,J=(J+Math.imul(b,$)|0)+Math.imul(l,Q)|0,W=W+Math.imul(l,$)|0,T=T+Math.imul(h,c)|0,J=(J+Math.imul(h,u)|0)+Math.imul(o,c)|0,W=W+Math.imul(o,u)|0;e=(ee+(T+Math.imul(a,g)|0)|0)+((8191&(J=(J+Math.imul(a,w)|0)+Math.imul(s,g)|0))<<13)|0;ee=((W+Math.imul(s,w)|0)+(J>>>13)|0)+(e>>>26)|0,e&=67108863,T=Math.imul(P,O),J=Math.imul(P,F)+Math.imul(j,O)|0,W=Math.imul(j,F),T=T+Math.imul(q,C)|0,J=(J+Math.imul(q,Z)|0)+Math.imul(R,C)|0,W=W+Math.imul(R,Z)|0,T=T+Math.imul(x,H)|0,J=(J+Math.imul(x,D)|0)+Math.imul(I,H)|0,W=W+Math.imul(I,D)|0,T=T+Math.imul(S,K)|0,J=(J+Math.imul(S,V)|0)+Math.imul(_,K)|0,W=W+Math.imul(_,V)|0,T=T+Math.imul(y,U)|0,J=(J+Math.imul(y,Y)|0)+Math.imul(M,U)|0,W=W+Math.imul(M,Y)|0,T=T+Math.imul(m,Q)|0,J=(J+Math.imul(m,$)|0)+Math.imul(v,Q)|0,W=W+Math.imul(v,$)|0,T=T+Math.imul(b,c)|0,J=(J+Math.imul(b,u)|0)+Math.imul(l,c)|0,W=W+Math.imul(l,u)|0,T=T+Math.imul(h,g)|0,J=(J+Math.imul(h,w)|0)+Math.imul(o,g)|0,W=W+Math.imul(o,w)|0;t=(ee+(T+Math.imul(a,z)|0)|0)+((8191&(J=(J+Math.imul(a,k)|0)+Math.imul(s,z)|0))<<13)|0;ee=((W+Math.imul(s,k)|0)+(J>>>13)|0)+(t>>>26)|0,t&=67108863,T=Math.imul(E,O),J=Math.imul(E,F)+Math.imul(B,O)|0,W=Math.imul(B,F),T=T+Math.imul(P,C)|0,J=(J+Math.imul(P,Z)|0)+Math.imul(j,C)|0,W=W+Math.imul(j,Z)|0,T=T+Math.imul(q,H)|0,J=(J+Math.imul(q,D)|0)+Math.imul(R,H)|0,W=W+Math.imul(R,D)|0,T=T+Math.imul(x,K)|0,J=(J+Math.imul(x,V)|0)+Math.imul(I,K)|0,W=W+Math.imul(I,V)|0,T=T+Math.imul(S,U)|0,J=(J+Math.imul(S,Y)|0)+Math.imul(_,U)|0,W=W+Math.imul(_,Y)|0,T=T+Math.imul(y,Q)|0,J=(J+Math.imul(y,$)|0)+Math.imul(M,Q)|0,W=W+Math.imul(M,$)|0,T=T+Math.imul(m,c)|0,J=(J+Math.imul(m,u)|0)+Math.imul(v,c)|0,W=W+Math.imul(v,u)|0,T=T+Math.imul(b,g)|0,J=(J+Math.imul(b,w)|0)+Math.imul(l,g)|0,W=W+Math.imul(l,w)|0,T=T+Math.imul(h,z)|0,J=(J+Math.imul(h,k)|0)+Math.imul(o,z)|0,W=W+Math.imul(o,k)|0;a=(ee+(T+Math.imul(a,N)|0)|0)+((8191&(J=(J+Math.imul(a,L)|0)+Math.imul(s,N)|0))<<13)|0;ee=((W+Math.imul(s,L)|0)+(J>>>13)|0)+(a>>>26)|0,a&=67108863,T=Math.imul(E,C),J=Math.imul(E,Z)+Math.imul(B,C)|0,W=Math.imul(B,Z),T=T+Math.imul(P,H)|0,J=(J+Math.imul(P,D)|0)+Math.imul(j,H)|0,W=W+Math.imul(j,D)|0,T=T+Math.imul(q,K)|0,J=(J+Math.imul(q,V)|0)+Math.imul(R,K)|0,W=W+Math.imul(R,V)|0,T=T+Math.imul(x,U)|0,J=(J+Math.imul(x,Y)|0)+Math.imul(I,U)|0,W=W+Math.imul(I,Y)|0,T=T+Math.imul(S,Q)|0,J=(J+Math.imul(S,$)|0)+Math.imul(_,Q)|0,W=W+Math.imul(_,$)|0,T=T+Math.imul(y,c)|0,J=(J+Math.imul(y,u)|0)+Math.imul(M,c)|0,W=W+Math.imul(M,u)|0,T=T+Math.imul(m,g)|0,J=(J+Math.imul(m,w)|0)+Math.imul(v,g)|0,W=W+Math.imul(v,w)|0,T=T+Math.imul(b,z)|0,J=(J+Math.imul(b,k)|0)+Math.imul(l,z)|0,W=W+Math.imul(l,k)|0;h=(ee+(T+Math.imul(h,N)|0)|0)+((8191&(J=(J+Math.imul(h,L)|0)+Math.imul(o,N)|0))<<13)|0;ee=((W+Math.imul(o,L)|0)+(J>>>13)|0)+(h>>>26)|0,h&=67108863,T=Math.imul(E,H),J=Math.imul(E,D)+Math.imul(B,H)|0,W=Math.imul(B,D),T=T+Math.imul(P,K)|0,J=(J+Math.imul(P,V)|0)+Math.imul(j,K)|0,W=W+Math.imul(j,V)|0,T=T+Math.imul(q,U)|0,J=(J+Math.imul(q,Y)|0)+Math.imul(R,U)|0,W=W+Math.imul(R,Y)|0,T=T+Math.imul(x,Q)|0,J=(J+Math.imul(x,$)|0)+Math.imul(I,Q)|0,W=W+Math.imul(I,$)|0,T=T+Math.imul(S,c)|0,J=(J+Math.imul(S,u)|0)+Math.imul(_,c)|0,W=W+Math.imul(_,u)|0,T=T+Math.imul(y,g)|0,J=(J+Math.imul(y,w)|0)+Math.imul(M,g)|0,W=W+Math.imul(M,w)|0,T=T+Math.imul(m,z)|0,J=(J+Math.imul(m,k)|0)+Math.imul(v,z)|0,W=W+Math.imul(v,k)|0;b=(ee+(T+Math.imul(b,N)|0)|0)+((8191&(J=(J+Math.imul(b,L)|0)+Math.imul(l,N)|0))<<13)|0;ee=((W+Math.imul(l,L)|0)+(J>>>13)|0)+(b>>>26)|0,b&=67108863,T=Math.imul(E,K),J=Math.imul(E,V)+Math.imul(B,K)|0,W=Math.imul(B,V),T=T+Math.imul(P,U)|0,J=(J+Math.imul(P,Y)|0)+Math.imul(j,U)|0,W=W+Math.imul(j,Y)|0,T=T+Math.imul(q,Q)|0,J=(J+Math.imul(q,$)|0)+Math.imul(R,Q)|0,W=W+Math.imul(R,$)|0,T=T+Math.imul(x,c)|0,J=(J+Math.imul(x,u)|0)+Math.imul(I,c)|0,W=W+Math.imul(I,u)|0,T=T+Math.imul(S,g)|0,J=(J+Math.imul(S,w)|0)+Math.imul(_,g)|0,W=W+Math.imul(_,w)|0,T=T+Math.imul(y,z)|0,J=(J+Math.imul(y,k)|0)+Math.imul(M,z)|0,W=W+Math.imul(M,k)|0;m=(ee+(T+Math.imul(m,N)|0)|0)+((8191&(J=(J+Math.imul(m,L)|0)+Math.imul(v,N)|0))<<13)|0;ee=((W+Math.imul(v,L)|0)+(J>>>13)|0)+(m>>>26)|0,m&=67108863,T=Math.imul(E,U),J=Math.imul(E,Y)+Math.imul(B,U)|0,W=Math.imul(B,Y),T=T+Math.imul(P,Q)|0,J=(J+Math.imul(P,$)|0)+Math.imul(j,Q)|0,W=W+Math.imul(j,$)|0,T=T+Math.imul(q,c)|0,J=(J+Math.imul(q,u)|0)+Math.imul(R,c)|0,W=W+Math.imul(R,u)|0,T=T+Math.imul(x,g)|0,J=(J+Math.imul(x,w)|0)+Math.imul(I,g)|0,W=W+Math.imul(I,w)|0,T=T+Math.imul(S,z)|0,J=(J+Math.imul(S,k)|0)+Math.imul(_,z)|0,W=W+Math.imul(_,k)|0;y=(ee+(T+Math.imul(y,N)|0)|0)+((8191&(J=(J+Math.imul(y,L)|0)+Math.imul(M,N)|0))<<13)|0;ee=((W+Math.imul(M,L)|0)+(J>>>13)|0)+(y>>>26)|0,y&=67108863,T=Math.imul(E,Q),J=Math.imul(E,$)+Math.imul(B,Q)|0,W=Math.imul(B,$),T=T+Math.imul(P,c)|0,J=(J+Math.imul(P,u)|0)+Math.imul(j,c)|0,W=W+Math.imul(j,u)|0,T=T+Math.imul(q,g)|0,J=(J+Math.imul(q,w)|0)+Math.imul(R,g)|0,W=W+Math.imul(R,w)|0,T=T+Math.imul(x,z)|0,J=(J+Math.imul(x,k)|0)+Math.imul(I,z)|0,W=W+Math.imul(I,k)|0;S=(ee+(T+Math.imul(S,N)|0)|0)+((8191&(J=(J+Math.imul(S,L)|0)+Math.imul(_,N)|0))<<13)|0;ee=((W+Math.imul(_,L)|0)+(J>>>13)|0)+(S>>>26)|0,S&=67108863,T=Math.imul(E,c),J=Math.imul(E,u)+Math.imul(B,c)|0,W=Math.imul(B,u),T=T+Math.imul(P,g)|0,J=(J+Math.imul(P,w)|0)+Math.imul(j,g)|0,W=W+Math.imul(j,w)|0,T=T+Math.imul(q,z)|0,J=(J+Math.imul(q,k)|0)+Math.imul(R,z)|0,W=W+Math.imul(R,k)|0;x=(ee+(T+Math.imul(x,N)|0)|0)+((8191&(J=(J+Math.imul(x,L)|0)+Math.imul(I,N)|0))<<13)|0;ee=((W+Math.imul(I,L)|0)+(J>>>13)|0)+(x>>>26)|0,x&=67108863,T=Math.imul(E,g),J=Math.imul(E,w)+Math.imul(B,g)|0,W=Math.imul(B,w),T=T+Math.imul(P,z)|0,J=(J+Math.imul(P,k)|0)+Math.imul(j,z)|0,W=W+Math.imul(j,k)|0;q=(ee+(T+Math.imul(q,N)|0)|0)+((8191&(J=(J+Math.imul(q,L)|0)+Math.imul(R,N)|0))<<13)|0;ee=((W+Math.imul(R,L)|0)+(J>>>13)|0)+(q>>>26)|0,q&=67108863,T=Math.imul(E,z),J=Math.imul(E,k)+Math.imul(B,z)|0,W=Math.imul(B,k);P=(ee+(T+Math.imul(P,N)|0)|0)+((8191&(J=(J+Math.imul(P,L)|0)+Math.imul(j,N)|0))<<13)|0;ee=((W+Math.imul(j,L)|0)+(J>>>13)|0)+(P>>>26)|0,P&=67108863;N=(ee+Math.imul(E,N)|0)+((8191&(J=Math.imul(E,L)+Math.imul(B,N)|0))<<13)|0;return ee=(Math.imul(B,L)+(J>>>13)|0)+(N>>>26)|0,N&=67108863,d[0]=X,d[1]=G,d[2]=n,d[3]=p,d[4]=A,d[5]=f,d[6]=r,d[7]=e,d[8]=t,d[9]=a,d[10]=h,d[11]=b,d[12]=m,d[13]=y,d[14]=S,d[15]=x,d[16]=q,d[17]=P,d[18]=N,0!=ee&&(d[19]=ee,i.length++),i};function a(e,t,i){return(new s).mulp(e,t,i)}function s(e,t){this.x=e,this.y=t}Math.imul||(d=f),m.prototype.mulTo=function(e,t){var i=this.length+e.length,t=(10===this.length&&10===e.length?d:i<63?f:i<1024?function(e,t,i){i.negative=t.negative^e.negative,i.length=e.length+t.length;for(var r=0,f=0,d=0;d<i.length-1;d++){for(var n=f,f=0,a=67108863&r,s=Math.min(d,t.length-1),c=Math.max(0,d-e.length+1);c<=s;c++){var h=d-c,o=(0|e.words[h])*(0|t.words[c]),h=67108863&o,a=67108863&(h=h+a|0);f+=(n=(n=n+(o/67108864|0)|0)+(h>>>26)|0)>>>26,n&=67108863}i.words[d]=a,r=n,n=f}return 0!==r?i.words[d]=r:i.length--,i.strip()}:a)(this,e,t);return t},s.prototype.makeRBT=function(e){for(var t=new Array(e),i=m.prototype._countBits(e)-1,r=0;r<e;r++)t[r]=this.revBin(r,i,e);return t},s.prototype.revBin=function(e,t,i){if(0===e||e===i-1)return e;for(var r=0,f=0;f<t;f++)r|=(1&e)<<t-f-1,e>>=1;return r},s.prototype.permute=function(e,t,i,r,f,d){for(var n=0;n<d;n++)r[n]=t[e[n]],f[n]=i[e[n]]},s.prototype.transform=function(e,t,i,r,f,d){this.permute(d,e,t,i,r,f);for(var n=1;n<f;n<<=1)for(var a=n<<1,s=Math.cos(2*Math.PI/a),c=Math.sin(2*Math.PI/a),h=0;h<f;h+=a)for(var o=s,u=c,b=0;b<n;b++){var l=i[h+b],p=r[h+b],m=o*(g=i[h+b+n])-u*(v=r[h+b+n]),v=o*v+u*g,g=m;i[h+b]=l+g,r[h+b]=p+v,i[h+b+n]=l-g,r[h+b+n]=p-v,b!==a&&(m=s*o-c*u,u=s*u+c*o,o=m)}},s.prototype.guessLen13b=function(e,t){for(var e=1&(r=1|Math.max(t,e)),i=0,r=r/2|0;r;r>>>=1)i++;return 1<<i+1+e},s.prototype.conjugate=function(e,t,i){if(!(i<=1))for(var r=0;r<i/2;r++){var f=e[r];e[r]=e[i-r-1],e[i-r-1]=f,f=t[r],t[r]=-t[i-r-1],t[i-r-1]=-f}},s.prototype.normalize13b=function(e,t){for(var i=0,r=0;r<t/2;r++){var f=8192*Math.round(e[2*r+1]/t)+Math.round(e[2*r]/t)+i;e[r]=67108863&f,i=f<67108864?0:f/67108864|0}return e},s.prototype.convert13b=function(e,t,i,r){for(var f=0,d=0;d<t;d++)f+=0|e[d],i[2*d]=8191&f,f>>>=13,i[2*d+1]=8191&f,f>>>=13;for(d=2*t;d<r;++d)i[d]=0;p(0===f),p(0==(-8192&f))},s.prototype.stub=function(e){for(var t=new Array(e),i=0;i<e;i++)t[i]=0;return t},s.prototype.mulp=function(e,t,i){var r=2*this.guessLen13b(e.length,t.length),f=this.makeRBT(r),d=this.stub(r),n=new Array(r),a=new Array(r),s=new Array(r),c=new Array(r),h=new Array(r),o=new Array(r),u=i.words;u.length=r,this.convert13b(e.words,e.length,n,r),this.convert13b(t.words,t.length,c,r),this.transform(n,d,a,s,r,f),this.transform(c,d,h,o,r,f);for(var b=0;b<r;b++){var l=a[b]*h[b]-s[b]*o[b];s[b]=a[b]*o[b]+s[b]*h[b],a[b]=l}return this.conjugate(a,s,r),this.transform(a,s,u,d,r,f),this.conjugate(u,d,r),this.normalize13b(u,r),i.negative=e.negative^t.negative,i.length=e.length+t.length,i.strip()},m.prototype.mul=function(e){var t=new m(null);return t.words=new Array(this.length+e.length),this.mulTo(e,t)},m.prototype.mulf=function(e){var t=new m(null);return t.words=new Array(this.length+e.length),a(this,e,t)},m.prototype.imul=function(e){return this.clone().mulTo(e,this)},m.prototype.imuln=function(e){p("number"==typeof e),p(e<67108864);for(var t=0,i=0;i<this.length;i++){var r=(0|this.words[i])*e,f=(67108863&r)+(67108863&t);t>>=26,t+=r/67108864|0,t+=f>>>26,this.words[i]=67108863&f}return 0!==t&&(this.words[i]=t,this.length++),this},m.prototype.muln=function(e){return this.clone().imuln(e)},m.prototype.sqr=function(){return this.mul(this)},m.prototype.isqr=function(){return this.imul(this.clone())},m.prototype.pow=function(e){var t=function(e){for(var t=new Array(e.bitLength()),i=0;i<t.length;i++){var r=i/26|0,f=i%26;t[i]=(e.words[r]&1<<f)>>>f}return t}(e);if(0===t.length)return new m(1);for(var i=this,r=0;r<t.length&&0===t[r];r++,i=i.sqr());if(++r<t.length)for(var f=i.sqr();r<t.length;r++,f=f.sqr())0!==t[r]&&(i=i.mul(f));return i},m.prototype.iushln=function(e){p("number"==typeof e&&0<=e);var t=e%26,i=(e-t)/26,r=67108863>>>26-t<<26-t;if(0!=t){for(var f=0,d=0;d<this.length;d++){var n=this.words[d]&r,a=(0|this.words[d])-n<<t;this.words[d]=a|f,f=n>>>26-t}f&&(this.words[d]=f,this.length++)}if(0!=i){for(d=this.length-1;0<=d;d--)this.words[d+i]=this.words[d];for(d=0;d<i;d++)this.words[d]=0;this.length+=i}return this.strip()},m.prototype.ishln=function(e){return p(0===this.negative),this.iushln(e)},m.prototype.iushrn=function(e,t,i){var r;p("number"==typeof e&&0<=e),r=t?(t-t%26)/26:0;var f=e%26,d=Math.min((e-f)/26,this.length),n=67108863^67108863>>>f<<f,a=i;if(r-=d,r=Math.max(0,r),a){for(var s=0;s<d;s++)a.words[s]=this.words[s];a.length=d}if(0!==d)if(this.length>d)for(this.length-=d,s=0;s<this.length;s++)this.words[s]=this.words[s+d];else this.words[0]=0,this.length=1;for(var c=0,s=this.length-1;0<=s&&(0!==c||r<=s);s--){var h=0|this.words[s];this.words[s]=c<<26-f|h>>>f,c=h&n}return a&&0!==c&&(a.words[a.length++]=c),0===this.length&&(this.words[0]=0,this.length=1),this.strip()},m.prototype.ishrn=function(e,t,i){return p(0===this.negative),this.iushrn(e,t,i)},m.prototype.shln=function(e){return this.clone().ishln(e)},m.prototype.ushln=function(e){return this.clone().iushln(e)},m.prototype.shrn=function(e){return this.clone().ishrn(e)},m.prototype.ushrn=function(e){return this.clone().iushrn(e)},m.prototype.testn=function(e){p("number"==typeof e&&0<=e);var t=e%26,e=(e-t)/26,t=1<<t;return!(this.length<=e)&&!!(this.words[e]&t)},m.prototype.imaskn=function(e){p("number"==typeof e&&0<=e);var t=e%26,e=(e-t)/26;return p(0===this.negative,"imaskn works only with positive numbers"),this.length<=e?this:(0!=t&&e++,this.length=Math.min(e,this.length),0!=t&&(t=67108863^67108863>>>t<<t,this.words[this.length-1]&=t),this.strip())},m.prototype.maskn=function(e){return this.clone().imaskn(e)},m.prototype.iaddn=function(e){return p("number"==typeof e),p(e<67108864),e<0?this.isubn(-e):0!==this.negative?(1===this.length&&(0|this.words[0])<e?(this.words[0]=e-(0|this.words[0]),this.negative=0):(this.negative=0,this.isubn(e),this.negative=1),this):this._iaddn(e)},m.prototype._iaddn=function(e){this.words[0]+=e;for(var t=0;t<this.length&&67108864<=this.words[t];t++)this.words[t]-=67108864,t===this.length-1?this.words[t+1]=1:this.words[t+1]++;return this.length=Math.max(this.length,t+1),this},m.prototype.isubn=function(e){if(p("number"==typeof e),p(e<67108864),e<0)return this.iaddn(-e);if(0!==this.negative)return this.negative=0,this.iaddn(e),this.negative=1,this;if(this.words[0]-=e,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var t=0;t<this.length&&this.words[t]<0;t++)this.words[t]+=67108864,--this.words[t+1];return this.strip()},m.prototype.addn=function(e){return this.clone().iaddn(e)},m.prototype.subn=function(e){return this.clone().isubn(e)},m.prototype.iabs=function(){return this.negative=0,this},m.prototype.abs=function(){return this.clone().iabs()},m.prototype._ishlnsubmul=function(e,t,i){var r,f=e.length+i;this._expand(f);for(var d=0,n=0;n<e.length;n++){r=(0|this.words[n+i])+d;var a=(0|e.words[n])*t,d=((r-=67108863&a)>>26)-(a/67108864|0);this.words[n+i]=67108863&r}for(;n<this.length-i;n++)d=(r=(0|this.words[n+i])+d)>>26,this.words[n+i]=67108863&r;if(0===d)return this.strip();for(p(-1===d),n=d=0;n<this.length;n++)d=(r=-(0|this.words[n])+d)>>26,this.words[n]=67108863&r;return this.negative=1,this.strip()},m.prototype._wordDiv=function(e,t){var i=this.length-e.length,r=this.clone(),f=e,d=0|f.words[f.length-1];0!=(i=26-this._countBits(d))&&(f=f.ushln(i),r.iushln(i),d=0|f.words[f.length-1]);var n,a=r.length-f.length;if("mod"!==t){(n=new m(null)).length=1+a,n.words=new Array(n.length);for(var s=0;s<n.length;s++)n.words[s]=0}e=r.clone()._ishlnsubmul(f,1,a);0===e.negative&&(r=e,n&&(n.words[a]=1));for(var c=a-1;0<=c;c--){var h=67108864*(0|r.words[f.length+c])+(0|r.words[f.length+c-1]),h=Math.min(h/d|0,67108863);for(r._ishlnsubmul(f,h,c);0!==r.negative;)h--,r.negative=0,r._ishlnsubmul(f,1,c),r.isZero()||(r.negative^=1);n&&(n.words[c]=h)}return n&&n.strip(),r.strip(),"div"!==t&&0!=i&&r.iushrn(i),{div:n||null,mod:r}},m.prototype.divmod=function(e,t,i){return p(!e.isZero()),this.isZero()?{div:new m(0),mod:new m(0)}:0!==this.negative&&0===e.negative?(d=this.neg().divmod(e,t),"mod"!==t&&(r=d.div.neg()),"div"!==t&&(f=d.mod.neg(),i&&0!==f.negative&&f.iadd(e)),{div:r,mod:f}):0===this.negative&&0!==e.negative?(d=this.divmod(e.neg(),t),{div:r="mod"!==t?d.div.neg():r,mod:d.mod}):0!=(this.negative&e.negative)?(d=this.neg().divmod(e.neg(),t),"div"!==t&&(f=d.mod.neg(),i&&0!==f.negative&&f.isub(e)),{div:d.div,mod:f}):e.length>this.length||this.cmp(e)<0?{div:new m(0),mod:this}:1===e.length?"div"===t?{div:this.divn(e.words[0]),mod:null}:"mod"===t?{div:null,mod:new m(this.modn(e.words[0]))}:{div:this.divn(e.words[0]),mod:new m(this.modn(e.words[0]))}:this._wordDiv(e,t);var r,f,d},m.prototype.div=function(e){return this.divmod(e,"div",!1).div},m.prototype.mod=function(e){return this.divmod(e,"mod",!1).mod},m.prototype.umod=function(e){return this.divmod(e,"mod",!0).mod},m.prototype.divRound=function(e){var t=this.divmod(e);if(t.mod.isZero())return t.div;var i=0!==t.div.negative?t.mod.isub(e):t.mod,r=e.ushrn(1),e=e.andln(1),r=i.cmp(r);return r<0||1===e&&0===r?t.div:0!==t.div.negative?t.div.isubn(1):t.div.iaddn(1)},m.prototype.modn=function(e){p(e<=67108863);for(var t=(1<<26)%e,i=0,r=this.length-1;0<=r;r--)i=(t*i+(0|this.words[r]))%e;return i},m.prototype.idivn=function(e){p(e<=67108863);for(var t=0,i=this.length-1;0<=i;i--){var r=(0|this.words[i])+67108864*t;this.words[i]=r/e|0,t=r%e}return this.strip()},m.prototype.divn=function(e){return this.clone().idivn(e)},m.prototype.egcd=function(e){p(0===e.negative),p(!e.isZero());for(var t=this,i=e.clone(),t=0!==t.negative?t.umod(e):t.clone(),r=new m(1),f=new m(0),d=new m(0),n=new m(1),a=0;t.isEven()&&i.isEven();)t.iushrn(1),i.iushrn(1),++a;for(var s=i.clone(),c=t.clone();!t.isZero();){for(var h=0,o=1;0==(t.words[0]&o)&&h<26;++h,o<<=1);if(0<h)for(t.iushrn(h);0<h--;)(r.isOdd()||f.isOdd())&&(r.iadd(s),f.isub(c)),r.iushrn(1),f.iushrn(1);for(var u=0,b=1;0==(i.words[0]&b)&&u<26;++u,b<<=1);if(0<u)for(i.iushrn(u);0<u--;)(d.isOdd()||n.isOdd())&&(d.iadd(s),n.isub(c)),d.iushrn(1),n.iushrn(1);0<=t.cmp(i)?(t.isub(i),r.isub(d),f.isub(n)):(i.isub(t),d.isub(r),n.isub(f))}return{a:d,b:n,gcd:i.iushln(a)}},m.prototype._invmp=function(e){p(0===e.negative),p(!e.isZero());for(var t,i=this,r=e.clone(),i=0!==i.negative?i.umod(e):i.clone(),f=new m(1),d=new m(0),n=r.clone();0<i.cmpn(1)&&0<r.cmpn(1);){for(var a=0,s=1;0==(i.words[0]&s)&&a<26;++a,s<<=1);if(0<a)for(i.iushrn(a);0<a--;)f.isOdd()&&f.iadd(n),f.iushrn(1);for(var c=0,h=1;0==(r.words[0]&h)&&c<26;++c,h<<=1);if(0<c)for(r.iushrn(c);0<c--;)d.isOdd()&&d.iadd(n),d.iushrn(1);0<=i.cmp(r)?(i.isub(r),f.isub(d)):(r.isub(i),d.isub(f))}return(t=0===i.cmpn(1)?f:d).cmpn(0)<0&&t.iadd(e),t},m.prototype.gcd=function(e){if(this.isZero())return e.abs();if(e.isZero())return this.abs();var t=this.clone(),i=e.clone();t.negative=0;for(var r=i.negative=0;t.isEven()&&i.isEven();r++)t.iushrn(1),i.iushrn(1);for(;;){for(;t.isEven();)t.iushrn(1);for(;i.isEven();)i.iushrn(1);var f=t.cmp(i);if(f<0)var d=t,t=i,i=d;else if(0===f||0===i.cmpn(1))break;t.isub(i)}return i.iushln(r)},m.prototype.invm=function(e){return this.egcd(e).a.umod(e)},m.prototype.isEven=function(){return 0==(1&this.words[0])},m.prototype.isOdd=function(){return 1==(1&this.words[0])},m.prototype.andln=function(e){return this.words[0]&e},m.prototype.bincn=function(e){p("number"==typeof e);var t=e%26,e=(e-t)/26,t=1<<t;if(this.length<=e)return this._expand(1+e),this.words[e]|=t,this;for(var i=t,r=e;0!==i&&r<this.length;r++){var f=0|this.words[r],i=(f+=i)>>>26;f&=67108863,this.words[r]=f}return 0!==i&&(this.words[r]=i,this.length++),this},m.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},m.prototype.cmpn=function(e){var t=e<0;return 0===this.negative||t?0===this.negative&&t?1:(this.strip(),e=1<this.length?1:(p((e=t?-e:e)<=67108863,"Number is too big"),(t=0|this.words[0])===e?0:t<e?-1:1),0!==this.negative?0|-e:e):-1},m.prototype.cmp=function(e){if(0!==this.negative&&0===e.negative)return-1;if(0===this.negative&&0!==e.negative)return 1;e=this.ucmp(e);return 0!==this.negative?0|-e:e},m.prototype.ucmp=function(e){if(this.length>e.length)return 1;if(this.length<e.length)return-1;for(var t=0,i=this.length-1;0<=i;i--){var r=0|this.words[i],f=0|e.words[i];if(r!=f){r<f?t=-1:f<r&&(t=1);break}}return t},m.prototype.gtn=function(e){return 1===this.cmpn(e)},m.prototype.gt=function(e){return 1===this.cmp(e)},m.prototype.gten=function(e){return 0<=this.cmpn(e)},m.prototype.gte=function(e){return 0<=this.cmp(e)},m.prototype.ltn=function(e){return-1===this.cmpn(e)},m.prototype.lt=function(e){return-1===this.cmp(e)},m.prototype.lten=function(e){return this.cmpn(e)<=0},m.prototype.lte=function(e){return this.cmp(e)<=0},m.prototype.eqn=function(e){return 0===this.cmpn(e)},m.prototype.eq=function(e){return 0===this.cmp(e)},m.red=function(e){return new w(e)},m.prototype.toRed=function(e){return p(!this.red,"Already a number in reduction context"),p(0===this.negative,"red works only with positives"),e.convertTo(this)._forceRed(e)},m.prototype.fromRed=function(){return p(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},m.prototype._forceRed=function(e){return this.red=e,this},m.prototype.forceRed=function(e){return p(!this.red,"Already a number in reduction context"),this._forceRed(e)},m.prototype.redAdd=function(e){return p(this.red,"redAdd works only with red numbers"),this.red.add(this,e)},m.prototype.redIAdd=function(e){return p(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,e)},m.prototype.redSub=function(e){return p(this.red,"redSub works only with red numbers"),this.red.sub(this,e)},m.prototype.redISub=function(e){return p(this.red,"redISub works only with red numbers"),this.red.isub(this,e)},m.prototype.redShl=function(e){return p(this.red,"redShl works only with red numbers"),this.red.shl(this,e)},m.prototype.redMul=function(e){return p(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.mul(this,e)},m.prototype.redIMul=function(e){return p(this.red,"redMul works only with red numbers"),this.red._verify2(this,e),this.red.imul(this,e)},m.prototype.redSqr=function(){return p(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},m.prototype.redISqr=function(){return p(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},m.prototype.redSqrt=function(){return p(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},m.prototype.redInvm=function(){return p(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},m.prototype.redNeg=function(){return p(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},m.prototype.redPow=function(e){return p(this.red&&!e.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,e)};var c={k256:null,p224:null,p192:null,p25519:null};function h(e,t){this.name=e,this.p=new m(t,16),this.n=this.p.bitLength(),this.k=new m(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function v(){h.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function g(){h.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function y(){h.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function M(){h.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function w(e){var t;"string"==typeof e?(t=m._prime(e),this.m=t.p,this.prime=t):(p(e.gtn(1),"modulus must be greater than 1"),this.m=e,this.prime=null)}function S(e){w.call(this,e),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new m(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}h.prototype._tmp=function(){var e=new m(null);return e.words=new Array(Math.ceil(this.n/13)),e},h.prototype.ireduce=function(e){for(var t,i=e;this.split(i,this.tmp),t=(i=(i=this.imulK(i)).iadd(this.tmp)).bitLength(),t>this.n;);e=t<this.n?-1:i.ucmp(this.p);return 0===e?(i.words[0]=0,i.length=1):0<e?i.isub(this.p):void 0!==i.strip?i.strip():i._strip(),i},h.prototype.split=function(e,t){e.iushrn(this.n,0,t)},h.prototype.imulK=function(e){return e.imul(this.k)},i(v,h),v.prototype.split=function(e,t){for(var i=Math.min(e.length,9),r=0;r<i;r++)t.words[r]=e.words[r];if(t.length=i,e.length<=9)return e.words[0]=0,void(e.length=1);var f=e.words[9];for(t.words[t.length++]=4194303&f,r=10;r<e.length;r++){var d=0|e.words[r];e.words[r-10]=(4194303&d)<<4|f>>>22,f=d}f>>>=22,0===(e.words[r-10]=f)&&10<e.length?e.length-=10:e.length-=9},v.prototype.imulK=function(e){e.words[e.length]=0,e.words[e.length+1]=0,e.length+=2;for(var t=0,i=0;i<e.length;i++){var r=0|e.words[i];t+=977*r,e.words[i]=67108863&t,t=64*r+(t/67108864|0)}return 0===e.words[e.length-1]&&(e.length--,0===e.words[e.length-1]&&e.length--),e},i(g,h),i(y,h),i(M,h),M.prototype.imulK=function(e){for(var t=0,i=0;i<e.length;i++){var r=19*(0|e.words[i])+t,f=67108863&r;r>>>=26,e.words[i]=f,t=r}return 0!==t&&(e.words[e.length++]=t),e},m._prime=function(e){if(c[e])return c[e];var t;if("k256"===e)t=new v;else if("p224"===e)t=new g;else if("p192"===e)t=new y;else{if("p25519"!==e)throw new Error("Unknown prime "+e);t=new M}return c[e]=t},w.prototype._verify1=function(e){p(0===e.negative,"red works only with positives"),p(e.red,"red works only with red numbers")},w.prototype._verify2=function(e,t){p(0==(e.negative|t.negative),"red works only with positives"),p(e.red&&e.red===t.red,"red works only with red numbers")},w.prototype.imod=function(e){return(this.prime?this.prime.ireduce(e):e.umod(this.m))._forceRed(this)},w.prototype.neg=function(e){return e.isZero()?e.clone():this.m.sub(e)._forceRed(this)},w.prototype.add=function(e,t){this._verify2(e,t);t=e.add(t);return 0<=t.cmp(this.m)&&t.isub(this.m),t._forceRed(this)},w.prototype.iadd=function(e,t){this._verify2(e,t);t=e.iadd(t);return 0<=t.cmp(this.m)&&t.isub(this.m),t},w.prototype.sub=function(e,t){this._verify2(e,t);t=e.sub(t);return t.cmpn(0)<0&&t.iadd(this.m),t._forceRed(this)},w.prototype.isub=function(e,t){this._verify2(e,t);t=e.isub(t);return t.cmpn(0)<0&&t.iadd(this.m),t},w.prototype.shl=function(e,t){return this._verify1(e),this.imod(e.ushln(t))},w.prototype.imul=function(e,t){return this._verify2(e,t),this.imod(e.imul(t))},w.prototype.mul=function(e,t){return this._verify2(e,t),this.imod(e.mul(t))},w.prototype.isqr=function(e){return this.imul(e,e.clone())},w.prototype.sqr=function(e){return this.mul(e,e)},w.prototype.sqrt=function(e){if(e.isZero())return e.clone();var t=this.m.andln(3);if(p(t%2==1),3===t){t=this.m.add(new m(1)).iushrn(2);return this.pow(e,t)}for(var i=this.m.subn(1),r=0;!i.isZero()&&0===i.andln(1);)r++,i.iushrn(1);p(!i.isZero());for(var f=new m(1).toRed(this),d=f.redNeg(),n=this.m.subn(1).iushrn(1),a=new m(2*(a=this.m.bitLength())*a).toRed(this);0!==this.pow(a,n).cmp(d);)a.redIAdd(d);for(var s=this.pow(a,i),c=this.pow(e,i.addn(1).iushrn(1)),h=this.pow(e,i),o=r;0!==h.cmp(f);){for(var u=h,b=0;0!==u.cmp(f);b++)u=u.redSqr();p(b<o);var l=this.pow(s,new m(1).iushln(o-b-1)),c=c.redMul(l),s=l.redSqr(),h=h.redMul(s),o=b}return c},w.prototype.invm=function(e){e=e._invmp(this.m);return 0!==e.negative?(e.negative=0,this.imod(e).redNeg()):this.imod(e)},w.prototype.pow=function(e,t){if(t.isZero())return new m(1).toRed(this);if(0===t.cmpn(1))return e.clone();var i=new Array(16);i[0]=new m(1).toRed(this),i[1]=e;for(var r=2;r<i.length;r++)i[r]=this.mul(i[r-1],e);var f=i[0],d=0,n=0,a=t.bitLength()%26;for(0===a&&(a=26),r=t.length-1;0<=r;r--){for(var s=t.words[r],c=a-1;0<=c;c--){var h=s>>c&1;f!==i[0]&&(f=this.sqr(f)),0!=h||0!==d?(d<<=1,d|=h,(4===++n||0===r&&0===c)&&(f=this.mul(f,i[d]),d=n=0)):n=0}a=26}return f},w.prototype.convertTo=function(e){var t=e.umod(this.m);return t===e?t.clone():t},w.prototype.convertFrom=function(e){e=e.clone();return e.red=null,e},m.mont=function(e){return new S(e)},i(S,w),S.prototype.convertTo=function(e){return this.imod(e.ushln(this.shift))},S.prototype.convertFrom=function(e){e=this.imod(e.mul(this.rinv));return e.red=null,e},S.prototype.imul=function(e,t){if(e.isZero()||t.isZero())return e.words[0]=0,e.length=1,e;e=e.imul(t),t=e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),e=e.isub(t).iushrn(this.shift),t=e;return 0<=e.cmp(this.m)?t=e.isub(this.m):e.cmpn(0)<0&&(t=e.iadd(this.m)),t._forceRed(this)},S.prototype.mul=function(e,t){if(e.isZero()||t.isZero())return new m(0)._forceRed(this);e=e.mul(t),t=e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),e=e.isub(t).iushrn(this.shift),t=e;return 0<=e.cmp(this.m)?t=e.isub(this.m):e.cmpn(0)<0&&(t=e.iadd(this.m)),t._forceRed(this)},S.prototype.invm=function(e){return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)}}(void 0===e||e,this)},{buffer:18}],17:[function(e,t,i){var r;function f(e){this.rand=e}if(t.exports=function(e){return(r=r||new f(null)).generate(e)},(t.exports.Rand=f).prototype.generate=function(e){return this._rand(e)},f.prototype._rand=function(e){if(this.rand.getBytes)return this.rand.getBytes(e);for(var t=new Uint8Array(e),i=0;i<t.length;i++)t[i]=this.rand.getByte();return t},"object"==typeof self)self.crypto&&self.crypto.getRandomValues?f.prototype._rand=function(e){e=new Uint8Array(e);return self.crypto.getRandomValues(e),e}:self.msCrypto&&self.msCrypto.getRandomValues?f.prototype._rand=function(e){e=new Uint8Array(e);return self.msCrypto.getRandomValues(e),e}:"object"==typeof window&&(f.prototype._rand=function(){throw new Error("Not implemented yet")});else try{var d=e("crypto");if("function"!=typeof d.randomBytes)throw new Error("Not supported");f.prototype._rand=function(e){return d.randomBytes(e)}}catch(e){}},{crypto:18}],18:[function(e,t,i){},{}],19:[function(e,t,i){i.utils=e("./hash/utils"),i.common=e("./hash/common"),i.sha=e("./hash/sha"),i.ripemd=e("./hash/ripemd"),i.hmac=e("./hash/hmac"),i.sha1=i.sha.sha1,i.sha256=i.sha.sha256,i.sha224=i.sha.sha224,i.sha384=i.sha.sha384,i.sha512=i.sha.sha512,i.ripemd160=i.ripemd.ripemd160},{"./hash/common":20,"./hash/hmac":21,"./hash/ripemd":22,"./hash/sha":23,"./hash/utils":30}],20:[function(e,t,i){"use strict";var r=e("./utils"),f=e("minimalistic-assert");function d(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}(i.BlockHash=d).prototype.update=function(e,t){if(e=r.toArray(e,t),this.pending?this.pending=this.pending.concat(e):this.pending=e,this.pendingTotal+=e.length,this.pending.length>=this._delta8){t=(e=this.pending).length%this._delta8;this.pending=e.slice(e.length-t,e.length),0===this.pending.length&&(this.pending=null),e=r.join32(e,0,e.length-t,this.endian);for(var i=0;i<e.length;i+=this._delta32)this._update(e,i,i+this._delta32)}return this},d.prototype.digest=function(e){return this.update(this._pad()),f(null===this.pending),this._digest(e)},d.prototype._pad=function(){var e=this.pendingTotal,t=this._delta8,i=t-(e+this.padLength)%t,r=new Array(i+this.padLength);r[0]=128;for(var f=1;f<i;f++)r[f]=0;if(e<<=3,"big"===this.endian){for(var d=8;d<this.padLength;d++)r[f++]=0;r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=e>>>24&255,r[f++]=e>>>16&255,r[f++]=e>>>8&255,r[f++]=255&e}else for(r[f++]=255&e,r[f++]=e>>>8&255,r[f++]=e>>>16&255,r[f++]=e>>>24&255,r[f++]=0,r[f++]=0,r[f++]=0,r[f++]=0,d=8;d<this.padLength;d++)r[f++]=0;return r}},{"./utils":30,"minimalistic-assert":33}],21:[function(e,t,i){"use strict";var r=e("./utils"),f=e("minimalistic-assert");function d(e,t,i){if(!(this instanceof d))return new d(e,t,i);this.Hash=e,this.blockSize=e.blockSize/8,this.outSize=e.outSize/8,this.inner=null,this.outer=null,this._init(r.toArray(t,i))}(t.exports=d).prototype._init=function(e){e.length>this.blockSize&&(e=(new this.Hash).update(e).digest()),f(e.length<=this.blockSize);for(var t=e.length;t<this.blockSize;t++)e.push(0);for(t=0;t<e.length;t++)e[t]^=54;for(this.inner=(new this.Hash).update(e),t=0;t<e.length;t++)e[t]^=106;this.outer=(new this.Hash).update(e)},d.prototype.update=function(e,t){return this.inner.update(e,t),this},d.prototype.digest=function(e){return this.outer.update(this.inner.digest()),this.outer.digest(e)}},{"./utils":30,"minimalistic-assert":33}],22:[function(e,t,i){"use strict";var r=e("./utils"),e=e("./common"),p=r.rotl32,m=r.sum32,v=r.sum32_3,g=r.sum32_4,f=e.BlockHash;function d(){if(!(this instanceof d))return new d;f.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function y(e,t,i,r){return e<=15?t^i^r:e<=31?t&i|~t&r:e<=47?(t|~i)^r:e<=63?t&r|i&~r:t^(i|~r)}r.inherits(d,f),(i.ripemd160=d).blockSize=512,d.outSize=160,d.hmacStrength=192,d.padLength=64,d.prototype._update=function(e,t){for(var i,r=h=this.h[0],f=l=this.h[1],d=b=this.h[2],n=u=this.h[3],a=o=this.h[4],s=0;s<80;s++)var c=m(p(g(h,y(s,l,b,u),e[M[s]+t],(i=s)<=15?0:i<=31?1518500249:i<=47?1859775393:i<=63?2400959708:2840853838),S[s]),o),h=o,o=u,u=p(b,10),b=l,l=c,c=m(p(g(r,y(79-s,f,d,n),e[w[s]+t],(i=s)<=15?1352829926:i<=31?1548603684:i<=47?1836072691:i<=63?2053994217:0),_[s]),a),r=a,a=n,n=p(d,10),d=f,f=c;c=v(this.h[1],b,n),this.h[1]=v(this.h[2],u,a),this.h[2]=v(this.h[3],o,r),this.h[3]=v(this.h[4],h,f),this.h[4]=v(this.h[0],l,d),this.h[0]=c},d.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h,"little"):r.split32(this.h,"little")};var M=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],w=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],S=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],_=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},{"./common":20,"./utils":30}],23:[function(e,t,i){"use strict";i.sha1=e("./sha/1"),i.sha224=e("./sha/224"),i.sha256=e("./sha/256"),i.sha384=e("./sha/384"),i.sha512=e("./sha/512")},{"./sha/1":24,"./sha/224":25,"./sha/256":26,"./sha/384":27,"./sha/512":28}],24:[function(e,t,i){"use strict";var r=e("../utils"),f=e("../common"),e=e("./common"),h=r.rotl32,o=r.sum32,u=r.sum32_5,b=e.ft_1,d=f.BlockHash,l=[1518500249,1859775393,2400959708,3395469782];function n(){if(!(this instanceof n))return new n;d.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=new Array(80)}r.inherits(n,d),(t.exports=n).blockSize=512,n.outSize=160,n.hmacStrength=80,n.padLength=64,n.prototype._update=function(e,t){for(var i=this.W,r=0;r<16;r++)i[r]=e[t+r];for(;r<i.length;r++)i[r]=h(i[r-3]^i[r-8]^i[r-14]^i[r-16],1);for(var f=this.h[0],d=this.h[1],n=this.h[2],a=this.h[3],s=this.h[4],r=0;r<i.length;r++)var c=~~(r/20),c=u(h(f,5),b(c,d,n,a),s,i[r],l[c]),s=a,a=n,n=h(d,30),d=f,f=c;this.h[0]=o(this.h[0],f),this.h[1]=o(this.h[1],d),this.h[2]=o(this.h[2],n),this.h[3]=o(this.h[3],a),this.h[4]=o(this.h[4],s)},n.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},{"../common":20,"../utils":30,"./common":29}],25:[function(e,t,i){"use strict";var r=e("../utils"),f=e("./256");function d(){if(!(this instanceof d))return new d;f.call(this),this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}r.inherits(d,f),(t.exports=d).blockSize=512,d.outSize=224,d.hmacStrength=192,d.padLength=64,d.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h.slice(0,7),"big"):r.split32(this.h.slice(0,7),"big")}},{"../utils":30,"./256":26}],26:[function(e,t,i){"use strict";var r=e("../utils"),f=e("../common"),d=e("./common"),l=e("minimalistic-assert"),p=r.sum32,m=r.sum32_4,v=r.sum32_5,g=d.ch32,y=d.maj32,M=d.s0_256,w=d.s1_256,S=d.g0_256,_=d.g1_256,n=f.BlockHash,a=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function s(){if(!(this instanceof s))return new s;n.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=a,this.W=new Array(64)}r.inherits(s,n),(t.exports=s).blockSize=512,s.outSize=256,s.hmacStrength=192,s.padLength=64,s.prototype._update=function(e,t){for(var i=this.W,r=0;r<16;r++)i[r]=e[t+r];for(;r<i.length;r++)i[r]=m(_(i[r-2]),i[r-7],S(i[r-15]),i[r-16]);var f=this.h[0],d=this.h[1],n=this.h[2],a=this.h[3],s=this.h[4],c=this.h[5],h=this.h[6],o=this.h[7];for(l(this.k.length===i.length),r=0;r<i.length;r++)var u=v(o,w(s),g(s,c,h),this.k[r],i[r]),b=p(M(f),y(f,d,n)),o=h,h=c,c=s,s=p(a,u),a=n,n=d,d=f,f=p(u,b);this.h[0]=p(this.h[0],f),this.h[1]=p(this.h[1],d),this.h[2]=p(this.h[2],n),this.h[3]=p(this.h[3],a),this.h[4]=p(this.h[4],s),this.h[5]=p(this.h[5],c),this.h[6]=p(this.h[6],h),this.h[7]=p(this.h[7],o)},s.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},{"../common":20,"../utils":30,"./common":29,"minimalistic-assert":33}],27:[function(e,t,i){"use strict";var r=e("../utils"),f=e("./512");function d(){if(!(this instanceof d))return new d;f.call(this),this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}r.inherits(d,f),(t.exports=d).blockSize=1024,d.outSize=384,d.hmacStrength=192,d.padLength=128,d.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h.slice(0,12),"big"):r.split32(this.h.slice(0,12),"big")}},{"../utils":30,"./512":28}],28:[function(e,t,i){"use strict";var r=e("../utils"),f=e("../common"),P=e("minimalistic-assert"),j=r.rotr64_hi,N=r.rotr64_lo,u=r.shr64_hi,b=r.shr64_lo,E=r.sum64,B=r.sum64_hi,L=r.sum64_lo,l=r.sum64_4_hi,p=r.sum64_4_lo,O=r.sum64_5_hi,F=r.sum64_5_lo,d=f.BlockHash,n=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function a(){if(!(this instanceof a))return new a;d.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=n,this.W=new Array(160)}r.inherits(a,d),(t.exports=a).blockSize=1024,a.outSize=512,a.hmacStrength=192,a.padLength=128,a.prototype._prepareBlock=function(e,t){for(var i=this.W,r=0;r<32;r++)i[r]=e[t+r];for(;r<i.length;r+=2){var f=function(e,t){var i=j(e,t,19),r=j(t,e,29),t=u(e,t,6),t=i^r^t;t<0&&(t+=4294967296);return t}(i[r-4],i[r-3]),d=function(e,t){var i=N(e,t,19),r=N(t,e,29),t=b(e,t,6),t=i^r^t;t<0&&(t+=4294967296);return t}(i[r-4],i[r-3]),n=i[r-14],a=i[r-13],s=function(e,t){var i=j(e,t,1),r=j(e,t,8),t=u(e,t,7),t=i^r^t;t<0&&(t+=4294967296);return t}(i[r-30],i[r-29]),c=function(e,t){var i=N(e,t,1),r=N(e,t,8),t=b(e,t,7),t=i^r^t;t<0&&(t+=4294967296);return t}(i[r-30],i[r-29]),h=i[r-32],o=i[r-31];i[r]=l(f,d,n,a,s,c,h,o),i[r+1]=p(f,d,n,a,s,c,h,o)}},a.prototype._update=function(e,t){this._prepareBlock(e,t);var i=this.W,r=this.h[0],f=this.h[1],d=this.h[2],n=this.h[3],a=this.h[4],s=this.h[5],c=this.h[6],h=this.h[7],o=this.h[8],u=this.h[9],b=this.h[10],l=this.h[11],p=this.h[12],m=this.h[13],v=this.h[14],g=this.h[15];P(this.k.length===i.length);for(var y=0;y<i.length;y+=2)var M=v,w=g,S=function(e,t){var i=j(e,t,14),r=j(e,t,18),e=j(t,e,9),e=i^r^e;e<0&&(e+=4294967296);return e}(o,u),_=function(e,t){var i=N(e,t,14),r=N(e,t,18),e=N(t,e,9),e=i^r^e;e<0&&(e+=4294967296);return e}(o,u),A=function(e,t,i){i=e&t^~e&i;i<0&&(i+=4294967296);return i}(o,b,p),x=function(e,t,i){i=e&t^~e&i;i<0&&(i+=4294967296);return i}(u,l,m),I=this.k[y],z=this.k[y+1],q=i[y],R=i[y+1],k=O(M,w,S,_,A,x,I,z,q,R),q=F(M,w,S,_,A,x,I,z,q,R),M=function(e,t){var i=j(e,t,28),r=j(t,e,2),e=j(t,e,7),e=i^r^e;e<0&&(e+=4294967296);return e}(r,f),w=function(e,t){var i=N(e,t,28),r=N(t,e,2),e=N(t,e,7),e=i^r^e;e<0&&(e+=4294967296);return e}(r,f),S=function(e,t,i){i=e&t^e&i^t&i;i<0&&(i+=4294967296);return i}(r,d,a),_=function(e,t,i){i=e&t^e&i^t&i;i<0&&(i+=4294967296);return i}(f,n,s),R=B(M,w,S,_),_=L(M,w,S,_),v=p,g=m,p=b,m=l,b=o,l=u,o=B(c,h,k,q),u=L(h,h,k,q),c=a,h=s,a=d,s=n,d=r,n=f,r=B(k,q,R,_),f=L(k,q,R,_);E(this.h,0,r,f),E(this.h,2,d,n),E(this.h,4,a,s),E(this.h,6,c,h),E(this.h,8,o,u),E(this.h,10,b,l),E(this.h,12,p,m),E(this.h,14,v,g)},a.prototype._digest=function(e){return"hex"===e?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},{"../common":20,"../utils":30,"minimalistic-assert":33}],29:[function(e,t,i){"use strict";var r=e("../utils").rotr32;function f(e,t,i){return e&t^~e&i}function d(e,t,i){return e&t^e&i^t&i}function n(e,t,i){return e^t^i}i.ft_1=function(e,t,i,r){return 0===e?f(t,i,r):1===e||3===e?t^i^r:2===e?d(t,i,r):void 0},i.ch32=f,i.maj32=d,i.p32=n,i.s0_256=function(e){return r(e,2)^r(e,13)^r(e,22)},i.s1_256=function(e){return r(e,6)^r(e,11)^r(e,25)},i.g0_256=function(e){return r(e,7)^r(e,18)^e>>>3},i.g1_256=function(e){return r(e,17)^r(e,19)^e>>>10}},{"../utils":30}],30:[function(e,t,i){"use strict";var s=e("minimalistic-assert"),e=e("inherits");function d(e){return(e>>>24|e>>>8&65280|e<<8&16711680|(255&e)<<24)>>>0}function r(e){return 1===e.length?"0"+e:e}function n(e){return 7===e.length?"0"+e:6===e.length?"00"+e:5===e.length?"000"+e:4===e.length?"0000"+e:3===e.length?"00000"+e:2===e.length?"000000"+e:1===e.length?"0000000"+e:e}i.inherits=e,i.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var i,r,f=[];if("string"==typeof e)if(t){if("hex"===t)for((e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e),n=0;n<e.length;n+=2)f.push(parseInt(e[n]+e[n+1],16))}else for(var d=0,n=0;n<e.length;n++){var a=e.charCodeAt(n);a<128?f[d++]=a:a<2048?(f[d++]=a>>6|192,f[d++]=63&a|128):(r=n,55296!=(64512&(i=e).charCodeAt(r))||r<0||r+1>=i.length||56320!=(64512&i.charCodeAt(r+1))?f[d++]=a>>12|224:(a=65536+((1023&a)<<10)+(1023&e.charCodeAt(++n)),f[d++]=a>>18|240,f[d++]=a>>12&63|128),f[d++]=a>>6&63|128,f[d++]=63&a|128)}else for(n=0;n<e.length;n++)f[n]=0|e[n];return f},i.toHex=function(e){for(var t="",i=0;i<e.length;i++)t+=r(e[i].toString(16));return t},i.htonl=d,i.toHex32=function(e,t){for(var i="",r=0;r<e.length;r++){var f=e[r];i+=n((f="little"===t?d(f):f).toString(16))}return i},i.zero2=r,i.zero8=n,i.join32=function(e,t,i,r){s((i-=t)%4==0);for(var f=new Array(i/4),d=0,n=t;d<f.length;d++,n+=4){var a="big"===r?e[n]<<24|e[n+1]<<16|e[n+2]<<8|e[n+3]:e[n+3]<<24|e[n+2]<<16|e[n+1]<<8|e[n];f[d]=a>>>0}return f},i.split32=function(e,t){for(var i=new Array(4*e.length),r=0,f=0;r<e.length;r++,f+=4){var d=e[r];"big"===t?(i[f]=d>>>24,i[f+1]=d>>>16&255,i[f+2]=d>>>8&255,i[f+3]=255&d):(i[f+3]=d>>>24,i[f+2]=d>>>16&255,i[f+1]=d>>>8&255,i[f]=255&d)}return i},i.rotr32=function(e,t){return e>>>t|e<<32-t},i.rotl32=function(e,t){return e<<t|e>>>32-t},i.sum32=function(e,t){return e+t>>>0},i.sum32_3=function(e,t,i){return e+t+i>>>0},i.sum32_4=function(e,t,i,r){return e+t+i+r>>>0},i.sum32_5=function(e,t,i,r,f){return e+t+i+r+f>>>0},i.sum64=function(e,t,i,r){var f=e[t],d=r+e[t+1]>>>0,f=(d<r?1:0)+i+f;e[t]=f>>>0,e[t+1]=d},i.sum64_hi=function(e,t,i,r){return(t+r>>>0<t?1:0)+e+i>>>0},i.sum64_lo=function(e,t,i,r){return t+r>>>0},i.sum64_4_hi=function(e,t,i,r,f,d,n,a){var s=0,c=t;return s+=(c=c+r>>>0)<t?1:0,s+=(c=c+d>>>0)<d?1:0,e+i+f+n+(s+=(c=c+a>>>0)<a?1:0)>>>0},i.sum64_4_lo=function(e,t,i,r,f,d,n,a){return t+r+d+a>>>0},i.sum64_5_hi=function(e,t,i,r,f,d,n,a,s,c){var h=0,o=t;return h+=(o=o+r>>>0)<t?1:0,h+=(o=o+d>>>0)<d?1:0,h+=(o=o+a>>>0)<a?1:0,e+i+f+n+s+(h+=(o=o+c>>>0)<c?1:0)>>>0},i.sum64_5_lo=function(e,t,i,r,f,d,n,a,s,c){return t+r+d+a+c>>>0},i.rotr64_hi=function(e,t,i){return(t<<32-i|e>>>i)>>>0},i.rotr64_lo=function(e,t,i){return(e<<32-i|t>>>i)>>>0},i.shr64_hi=function(e,t,i){return e>>>i},i.shr64_lo=function(e,t,i){return(e<<32-i|t>>>i)>>>0}},{inherits:32,"minimalistic-assert":33}],31:[function(e,t,i){"use strict";var r=e("hash.js"),d=e("minimalistic-crypto-utils"),f=e("minimalistic-assert");function n(e){if(!(this instanceof n))return new n(e);this.hash=e.hash,this.predResist=!!e.predResist,this.outLen=this.hash.outSize,this.minEntropy=e.minEntropy||this.hash.hmacStrength,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var t=d.toArray(e.entropy,e.entropyEnc||"hex"),i=d.toArray(e.nonce,e.nonceEnc||"hex"),e=d.toArray(e.pers,e.persEnc||"hex");f(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(t,i,e)}(t.exports=n).prototype._init=function(e,t,i){i=e.concat(t).concat(i);this.K=new Array(this.outLen/8),this.V=new Array(this.outLen/8);for(var r=0;r<this.V.length;r++)this.K[r]=0,this.V[r]=1;this._update(i),this._reseed=1,this.reseedInterval=281474976710656},n.prototype._hmac=function(){return new r.hmac(this.hash,this.K)},n.prototype._update=function(e){var t=this._hmac().update(this.V).update([0]);e&&(t=t.update(e)),this.K=t.digest(),this.V=this._hmac().update(this.V).digest(),e&&(this.K=this._hmac().update(this.V).update([1]).update(e).digest(),this.V=this._hmac().update(this.V).digest())},n.prototype.reseed=function(e,t,i,r){"string"!=typeof t&&(r=i,i=t,t=null),e=d.toArray(e,t),i=d.toArray(i,r),f(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(e.concat(i||[])),this._reseed=1},n.prototype.generate=function(e,t,i,r){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");"string"!=typeof t&&(r=i,i=t,t=null),i&&(i=d.toArray(i,r||"hex"),this._update(i));for(var f=[];f.length<e;)this.V=this._hmac().update(this.V).digest(),f=f.concat(this.V);r=f.slice(0,e);return this._update(i),this._reseed++,d.encode(r,t)}},{"hash.js":19,"minimalistic-assert":33,"minimalistic-crypto-utils":34}],32:[function(e,t,i){"function"==typeof Object.create?t.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(e,t){var i;t&&(e.super_=t,(i=function(){}).prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e)}},{}],33:[function(e,t,i){function r(e,t){if(!e)throw new Error(t||"Assertion failed")}(t.exports=r).equal=function(e,t,i){if(e!=t)throw new Error(i||"Assertion failed: "+e+" != "+t)}},{}],34:[function(e,t,i){"use strict";function r(e){return 1===e.length?"0"+e:e}function f(e){for(var t="",i=0;i<e.length;i++)t+=r(e[i].toString(16));return t}i.toArray=function(e,t){if(Array.isArray(e))return e.slice();if(!e)return[];var i=[];if("string"!=typeof e){for(var r=0;r<e.length;r++)i[r]=0|e[r];return i}if("hex"===t){(e=e.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(e="0"+e);for(r=0;r<e.length;r+=2)i.push(parseInt(e[r]+e[r+1],16))}else for(r=0;r<e.length;r++){var f=e.charCodeAt(r),d=f>>8,f=255&f;d?i.push(d,f):i.push(f)}return i},i.zero2=r,i.toHex=f,i.encode=function(e,t){return"hex"===t?f(e):e}},{}],35:[function(e,t,i){t.exports={name:"elliptic",version:"6.5.4",description:"EC cryptography",main:"lib/elliptic.js",files:["lib"],scripts:{lint:"eslint lib test","lint:fix":"npm run lint -- --fix",unit:"istanbul test _mocha --reporter=spec test/index.js",test:"npm run lint && npm run unit",version:"grunt dist && git add dist/"},repository:{type:"git",url:"git@github.com:indutny/elliptic"},keywords:["EC","Elliptic","curve","Cryptography"],author:"Fedor Indutny <fedor@indutny.com>",license:"MIT",bugs:{url:"https://github.com/indutny/elliptic/issues"},homepage:"https://github.com/indutny/elliptic",devDependencies:{brfs:"^2.0.2",coveralls:"^3.1.0",eslint:"^7.6.0",grunt:"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1",istanbul:"^0.4.5",mocha:"^8.0.1"},dependencies:{"bn.js":"^4.11.9",brorand:"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1",inherits:"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}},{}]},{},[1])(1)});
    </script>
    
    <!-- 
    Library: QRCode.js v1.0.0
    Description: Cross-browser QRCode generator for JavaScript
    Source: https://github.com/davidshimjs/qrcodejs
    License: MIT License
    Downloaded from: https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js
    Last verified: April 23, 2025
    -->
    <script>
        var QRCode;!function(){function a(a){this.mode=c.MODE_8BIT_BYTE,this.data=a,this.parsedData=[];for(var b=[],d=0,e=this.data.length;e>d;d++){var f=this.data.charCodeAt(d);f>65536?(b[0]=240|(1835008&f)>>>18,b[1]=128|(258048&f)>>>12,b[2]=128|(4032&f)>>>6,b[3]=128|63&f):f>2048?(b[0]=224|(61440&f)>>>12,b[1]=128|(4032&f)>>>6,b[2]=128|63&f):f>128?(b[0]=192|(1984&f)>>>6,b[1]=128|63&f):b[0]=f,this.parsedData=this.parsedData.concat(b)}this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function b(a,b){this.typeNumber=a,this.errorCorrectLevel=b,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}function i(a,b){if(void 0==a.length)throw new Error(a.length+"/"+b);for(var c=0;c<a.length&&0==a[c];)c++;this.num=new Array(a.length-c+b);for(var d=0;d<a.length-c;d++)this.num[d]=a[d+c]}function j(a,b){this.totalCount=a,this.dataCount=b}function k(){this.buffer=[],this.length=0}function m(){return"undefined"!=typeof CanvasRenderingContext2D}function n(){var a=!1,b=navigator.userAgent;return/android/i.test(b)&&(a=!0,aMat=b.toString().match(/android ([0-9]\.[0-9])/i),aMat&&aMat[1]&&(a=parseFloat(aMat[1]))),a}function r(a,b){for(var c=1,e=s(a),f=0,g=l.length;g>=f;f++){var h=0;switch(b){case d.L:h=l[f][0];break;case d.M:h=l[f][1];break;case d.Q:h=l[f][2];break;case d.H:h=l[f][3]}if(h>=e)break;c++}if(c>l.length)throw new Error("Too long data");return c}function s(a){var b=encodeURI(a).toString().replace(/\%[0-9a-fA-F]{2}/g,"a");return b.length+(b.length!=a?3:0)}a.prototype={getLength:function(){return this.parsedData.length},write:function(a){for(var b=0,c=this.parsedData.length;c>b;b++)a.put(this.parsedData[b],8)}},b.prototype={addData:function(b){var c=new a(b);this.dataList.push(c),this.dataCache=null},isDark:function(a,b){if(0>a||this.moduleCount<=a||0>b||this.moduleCount<=b)throw new Error(a+","+b);return this.modules[a][b]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(a,c){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var d=0;d<this.moduleCount;d++){this.modules[d]=new Array(this.moduleCount);for(var e=0;e<this.moduleCount;e++)this.modules[d][e]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(a,c),this.typeNumber>=7&&this.setupTypeNumber(a),null==this.dataCache&&(this.dataCache=b.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,c)},setupPositionProbePattern:function(a,b){for(var c=-1;7>=c;c++)if(!(-1>=a+c||this.moduleCount<=a+c))for(var d=-1;7>=d;d++)-1>=b+d||this.moduleCount<=b+d||(this.modules[a+c][b+d]=c>=0&&6>=c&&(0==d||6==d)||d>=0&&6>=d&&(0==c||6==c)||c>=2&&4>=c&&d>=2&&4>=d?!0:!1)},getBestMaskPattern:function(){for(var a=0,b=0,c=0;8>c;c++){this.makeImpl(!0,c);var d=f.getLostPoint(this);(0==c||a>d)&&(a=d,b=c)}return b},createMovieClip:function(a,b,c){var d=a.createEmptyMovieClip(b,c),e=1;this.make();for(var f=0;f<this.modules.length;f++)for(var g=f*e,h=0;h<this.modules[f].length;h++){var i=h*e,j=this.modules[f][h];j&&(d.beginFill(0,100),d.moveTo(i,g),d.lineTo(i+e,g),d.lineTo(i+e,g+e),d.lineTo(i,g+e),d.endFill())}return d},setupTimingPattern:function(){for(var a=8;a<this.moduleCount-8;a++)null==this.modules[a][6]&&(this.modules[a][6]=0==a%2);for(var b=8;b<this.moduleCount-8;b++)null==this.modules[6][b]&&(this.modules[6][b]=0==b%2)},setupPositionAdjustPattern:function(){for(var a=f.getPatternPosition(this.typeNumber),b=0;b<a.length;b++)for(var c=0;c<a.length;c++){var d=a[b],e=a[c];if(null==this.modules[d][e])for(var g=-2;2>=g;g++)for(var h=-2;2>=h;h++)this.modules[d+g][e+h]=-2==g||2==g||-2==h||2==h||0==g&&0==h?!0:!1}},setupTypeNumber:function(a){for(var b=f.getBCHTypeNumber(this.typeNumber),c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[Math.floor(c/3)][c%3+this.moduleCount-8-3]=d}for(var c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[c%3+this.moduleCount-8-3][Math.floor(c/3)]=d}},setupTypeInfo:function(a,b){for(var c=this.errorCorrectLevel<<3|b,d=f.getBCHTypeInfo(c),e=0;15>e;e++){var g=!a&&1==(1&d>>e);6>e?this.modules[e][8]=g:8>e?this.modules[e+1][8]=g:this.modules[this.moduleCount-15+e][8]=g}for(var e=0;15>e;e++){var g=!a&&1==(1&d>>e);8>e?this.modules[8][this.moduleCount-e-1]=g:9>e?this.modules[8][15-e-1+1]=g:this.modules[8][15-e-1]=g}this.modules[this.moduleCount-8][8]=!a},mapData:function(a,b){for(var c=-1,d=this.moduleCount-1,e=7,g=0,h=this.moduleCount-1;h>0;h-=2)for(6==h&&h--;;){for(var i=0;2>i;i++)if(null==this.modules[d][h-i]){var j=!1;g<a.length&&(j=1==(1&a[g]>>>e));var k=f.getMask(b,d,h-i);k&&(j=!j),this.modules[d][h-i]=j,e--,-1==e&&(g++,e=7)}if(d+=c,0>d||this.moduleCount<=d){d-=c,c=-c;break}}}},b.PAD0=236,b.PAD1=17,b.createData=function(a,c,d){for(var e=j.getRSBlocks(a,c),g=new k,h=0;h<d.length;h++){var i=d[h];g.put(i.mode,4),g.put(i.getLength(),f.getLengthInBits(i.mode,a)),i.write(g)}for(var l=0,h=0;h<e.length;h++)l+=e[h].dataCount;if(g.getLengthInBits()>8*l)throw new Error("code length overflow. ("+g.getLengthInBits()+">"+8*l+")");for(g.getLengthInBits()+4<=8*l&&g.put(0,4);0!=g.getLengthInBits()%8;)g.putBit(!1);for(;;){if(g.getLengthInBits()>=8*l)break;if(g.put(b.PAD0,8),g.getLengthInBits()>=8*l)break;g.put(b.PAD1,8)}return b.createBytes(g,e)},b.createBytes=function(a,b){for(var c=0,d=0,e=0,g=new Array(b.length),h=new Array(b.length),j=0;j<b.length;j++){var k=b[j].dataCount,l=b[j].totalCount-k;d=Math.max(d,k),e=Math.max(e,l),g[j]=new Array(k);for(var m=0;m<g[j].length;m++)g[j][m]=255&a.buffer[m+c];c+=k;var n=f.getErrorCorrectPolynomial(l),o=new i(g[j],n.getLength()-1),p=o.mod(n);h[j]=new Array(n.getLength()-1);for(var m=0;m<h[j].length;m++){var q=m+p.getLength()-h[j].length;h[j][m]=q>=0?p.get(q):0}}for(var r=0,m=0;m<b.length;m++)r+=b[m].totalCount;for(var s=new Array(r),t=0,m=0;d>m;m++)for(var j=0;j<b.length;j++)m<g[j].length&&(s[t++]=g[j][m]);for(var m=0;e>m;m++)for(var j=0;j<b.length;j++)m<h[j].length&&(s[t++]=h[j][m]);return s};for(var c={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},d={L:1,M:0,Q:3,H:2},e={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},f={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(a){for(var b=a<<10;f.getBCHDigit(b)-f.getBCHDigit(f.G15)>=0;)b^=f.G15<<f.getBCHDigit(b)-f.getBCHDigit(f.G15);return(a<<10|b)^f.G15_MASK},getBCHTypeNumber:function(a){for(var b=a<<12;f.getBCHDigit(b)-f.getBCHDigit(f.G18)>=0;)b^=f.G18<<f.getBCHDigit(b)-f.getBCHDigit(f.G18);return a<<12|b},getBCHDigit:function(a){for(var b=0;0!=a;)b++,a>>>=1;return b},getPatternPosition:function(a){return f.PATTERN_POSITION_TABLE[a-1]},getMask:function(a,b,c){switch(a){case e.PATTERN000:return 0==(b+c)%2;case e.PATTERN001:return 0==b%2;case e.PATTERN010:return 0==c%3;case e.PATTERN011:return 0==(b+c)%3;case e.PATTERN100:return 0==(Math.floor(b/2)+Math.floor(c/3))%2;case e.PATTERN101:return 0==b*c%2+b*c%3;case e.PATTERN110:return 0==(b*c%2+b*c%3)%2;case e.PATTERN111:return 0==(b*c%3+(b+c)%2)%2;default:throw new Error("bad maskPattern:"+a)}},getErrorCorrectPolynomial:function(a){for(var b=new i([1],0),c=0;a>c;c++)b=b.multiply(new i([1,g.gexp(c)],0));return b},getLengthInBits:function(a,b){if(b>=1&&10>b)switch(a){case c.MODE_NUMBER:return 10;case c.MODE_ALPHA_NUM:return 9;case c.MODE_8BIT_BYTE:return 8;case c.MODE_KANJI:return 8;default:throw new Error("mode:"+a)}else if(27>b)switch(a){case c.MODE_NUMBER:return 12;case c.MODE_ALPHA_NUM:return 11;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 10;default:throw new Error("mode:"+a)}else{if(!(41>b))throw new Error("type:"+b);switch(a){case c.MODE_NUMBER:return 14;case c.MODE_ALPHA_NUM:return 13;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 12;default:throw new Error("mode:"+a)}}},getLostPoint:function(a){for(var b=a.getModuleCount(),c=0,d=0;b>d;d++)for(var e=0;b>e;e++){for(var f=0,g=a.isDark(d,e),h=-1;1>=h;h++)if(!(0>d+h||d+h>=b))for(var i=-1;1>=i;i++)0>e+i||e+i>=b||(0!=h||0!=i)&&g==a.isDark(d+h,e+i)&&f++;f>5&&(c+=3+f-5)}for(var d=0;b-1>d;d++)for(var e=0;b-1>e;e++){var j=0;a.isDark(d,e)&&j++,a.isDark(d+1,e)&&j++,a.isDark(d,e+1)&&j++,a.isDark(d+1,e+1)&&j++,(0==j||4==j)&&(c+=3)}for(var d=0;b>d;d++)for(var e=0;b-6>e;e++)a.isDark(d,e)&&!a.isDark(d,e+1)&&a.isDark(d,e+2)&&a.isDark(d,e+3)&&a.isDark(d,e+4)&&!a.isDark(d,e+5)&&a.isDark(d,e+6)&&(c+=40);for(var e=0;b>e;e++)for(var d=0;b-6>d;d++)a.isDark(d,e)&&!a.isDark(d+1,e)&&a.isDark(d+2,e)&&a.isDark(d+3,e)&&a.isDark(d+4,e)&&!a.isDark(d+5,e)&&a.isDark(d+6,e)&&(c+=40);for(var k=0,e=0;b>e;e++)for(var d=0;b>d;d++)a.isDark(d,e)&&k++;var l=Math.abs(100*k/b/b-50)/5;return c+=10*l}},g={glog:function(a){if(1>a)throw new Error("glog("+a+")");return g.LOG_TABLE[a]},gexp:function(a){for(;0>a;)a+=255;for(;a>=256;)a-=255;return g.EXP_TABLE[a]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},h=0;8>h;h++)g.EXP_TABLE[h]=1<<h;for(var h=8;256>h;h++)g.EXP_TABLE[h]=g.EXP_TABLE[h-4]^g.EXP_TABLE[h-5]^g.EXP_TABLE[h-6]^g.EXP_TABLE[h-8];for(var h=0;255>h;h++)g.LOG_TABLE[g.EXP_TABLE[h]]=h;i.prototype={get:function(a){return this.num[a]},getLength:function(){return this.num.length},multiply:function(a){for(var b=new Array(this.getLength()+a.getLength()-1),c=0;c<this.getLength();c++)for(var d=0;d<a.getLength();d++)b[c+d]^=g.gexp(g.glog(this.get(c))+g.glog(a.get(d)));return new i(b,0)},mod:function(a){if(this.getLength()-a.getLength()<0)return this;for(var b=g.glog(this.get(0))-g.glog(a.get(0)),c=new Array(this.getLength()),d=0;d<this.getLength();d++)c[d]=this.get(d);for(var d=0;d<a.getLength();d++)c[d]^=g.gexp(g.glog(a.get(d))+b);return new i(c,0).mod(a)}},j.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],j.getRSBlocks=function(a,b){var c=j.getRsBlockTable(a,b);if(void 0==c)throw new Error("bad rs block @ typeNumber:"+a+"/errorCorrectLevel:"+b);for(var d=c.length/3,e=[],f=0;d>f;f++)for(var g=c[3*f+0],h=c[3*f+1],i=c[3*f+2],k=0;g>k;k++)e.push(new j(h,i));return e},j.getRsBlockTable=function(a,b){switch(b){case d.L:return j.RS_BLOCK_TABLE[4*(a-1)+0];case d.M:return j.RS_BLOCK_TABLE[4*(a-1)+1];case d.Q:return j.RS_BLOCK_TABLE[4*(a-1)+2];case d.H:return j.RS_BLOCK_TABLE[4*(a-1)+3];default:return void 0}},k.prototype={get:function(a){var b=Math.floor(a/8);return 1==(1&this.buffer[b]>>>7-a%8)},put:function(a,b){for(var c=0;b>c;c++)this.putBit(1==(1&a>>>b-c-1))},getLengthInBits:function(){return this.length},putBit:function(a){var b=Math.floor(this.length/8);this.buffer.length<=b&&this.buffer.push(0),a&&(this.buffer[b]|=128>>>this.length%8),this.length++}};var l=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]],o=function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){function g(a,b){var c=document.createElementNS("http://www.w3.org/2000/svg",a);for(var d in b)b.hasOwnProperty(d)&&c.setAttribute(d,b[d]);return c}var b=this._htOption,c=this._el,d=a.getModuleCount();Math.floor(b.width/d),Math.floor(b.height/d),this.clear();var h=g("svg",{viewBox:"0 0 "+String(d)+" "+String(d),width:"100%",height:"100%",fill:b.colorLight});h.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink","http://www.w3.org/1999/xlink"),c.appendChild(h),h.appendChild(g("rect",{fill:b.colorDark,width:"1",height:"1",id:"template"}));for(var i=0;d>i;i++)for(var j=0;d>j;j++)if(a.isDark(i,j)){var k=g("use",{x:String(i),y:String(j)});k.setAttributeNS("http://www.w3.org/1999/xlink","href","#template"),h.appendChild(k)}},a.prototype.clear=function(){for(;this._el.hasChildNodes();)this._el.removeChild(this._el.lastChild)},a}(),p="svg"===document.documentElement.tagName.toLowerCase(),q=p?o:m()?function(){function a(){this._elImage.src=this._elCanvas.toDataURL("image/png"),this._elImage.style.display="block",this._elCanvas.style.display="none"}function d(a,b){var c=this;if(c._fFail=b,c._fSuccess=a,null===c._bSupportDataURI){var d=document.createElement("img"),e=function(){c._bSupportDataURI=!1,c._fFail&&_fFail.call(c)},f=function(){c._bSupportDataURI=!0,c._fSuccess&&c._fSuccess.call(c)};return d.onabort=e,d.onerror=e,d.onload=f,d.src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==",void 0}c._bSupportDataURI===!0&&c._fSuccess?c._fSuccess.call(c):c._bSupportDataURI===!1&&c._fFail&&c._fFail.call(c)}if(this._android&&this._android<=2.1){var b=1/window.devicePixelRatio,c=CanvasRenderingContext2D.prototype.drawImage;CanvasRenderingContext2D.prototype.drawImage=function(a,d,e,f,g,h,i,j){if("nodeName"in a&&/img/i.test(a.nodeName))for(var l=arguments.length-1;l>=1;l--)arguments[l]=arguments[l]*b;else"undefined"==typeof j&&(arguments[1]*=b,arguments[2]*=b,arguments[3]*=b,arguments[4]*=b);c.apply(this,arguments)}}var e=function(a,b){this._bIsPainted=!1,this._android=n(),this._htOption=b,this._elCanvas=document.createElement("canvas"),this._elCanvas.width=b.width,this._elCanvas.height=b.height,a.appendChild(this._elCanvas),this._el=a,this._oContext=this._elCanvas.getContext("2d"),this._bIsPainted=!1,this._elImage=document.createElement("img"),this._elImage.style.display="none",this._el.appendChild(this._elImage),this._bSupportDataURI=null};return e.prototype.draw=function(a){var b=this._elImage,c=this._oContext,d=this._htOption,e=a.getModuleCount(),f=d.width/e,g=d.height/e,h=Math.round(f),i=Math.round(g);b.style.display="none",this.clear();for(var j=0;e>j;j++)for(var k=0;e>k;k++){var l=a.isDark(j,k),m=k*f,n=j*g;c.strokeStyle=l?d.colorDark:d.colorLight,c.lineWidth=1,c.fillStyle=l?d.colorDark:d.colorLight,c.fillRect(m,n,f,g),c.strokeRect(Math.floor(m)+.5,Math.floor(n)+.5,h,i),c.strokeRect(Math.ceil(m)-.5,Math.ceil(n)-.5,h,i)}this._bIsPainted=!0},e.prototype.makeImage=function(){this._bIsPainted&&d.call(this,a)},e.prototype.isPainted=function(){return this._bIsPainted},e.prototype.clear=function(){this._oContext.clearRect(0,0,this._elCanvas.width,this._elCanvas.height),this._bIsPainted=!1},e.prototype.round=function(a){return a?Math.floor(1e3*a)/1e3:a},e}():function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){for(var b=this._htOption,c=this._el,d=a.getModuleCount(),e=Math.floor(b.width/d),f=Math.floor(b.height/d),g=['<table style="border:0;border-collapse:collapse;">'],h=0;d>h;h++){g.push("<tr>");for(var i=0;d>i;i++)g.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:'+e+"px;height:"+f+"px;background-color:"+(a.isDark(h,i)?b.colorDark:b.colorLight)+';"></td>');g.push("</tr>")}g.push("</table>"),c.innerHTML=g.join("");var j=c.childNodes[0],k=(b.width-j.offsetWidth)/2,l=(b.height-j.offsetHeight)/2;k>0&&l>0&&(j.style.margin=l+"px "+k+"px")},a.prototype.clear=function(){this._el.innerHTML=""},a}();QRCode=function(a,b){if(this._htOption={width:256,height:256,typeNumber:4,colorDark:"#000000",colorLight:"#ffffff",correctLevel:d.H},"string"==typeof b&&(b={text:b}),b)for(var c in b)this._htOption[c]=b[c];"string"==typeof a&&(a=document.getElementById(a)),this._android=n(),this._el=a,this._oQRCode=null,this._oDrawing=new q(this._el,this._htOption),this._htOption.text&&this.makeCode(this._htOption.text)},QRCode.prototype.makeCode=function(a){this._oQRCode=new b(r(a,this._htOption.correctLevel),this._htOption.correctLevel),this._oQRCode.addData(a),this._oQRCode.make(),this._el.title=a,this._oDrawing.draw(this._oQRCode),this.makeImage()},QRCode.prototype.makeImage=function(){"function"==typeof this._oDrawing.makeImage&&(!this._android||this._android>=3)&&this._oDrawing.makeImage()},QRCode.prototype.clear=function(){this._oDrawing.clear()},QRCode.CorrectLevel=d}();
    </script>
    <style>
        :root {
            --primary-color: #3a86ff;
            --secondary-color: #8338ec;
            --accent-color: #ffbe0b;
            --danger-color: #ff006e;
            --success-color: #06d6a0;
            --light-bg: #f8f9fa;
            --dark-bg: #212529;
            --text-color: #212529;
            --light-text: #f8f9fa;
            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--light-bg);
            color: var(--text-color);
            line-height: 1.6;
        }
        .wallet-container {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--box-shadow);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .header h1 {
            color: var(--primary-color);
            font-weight: 700;
            margin-bottom: 10px;
        }
        .key-display {
            margin: 20px 0;
            padding: 15px;
            background-color: var(--light-bg);
            border-radius: var(--border-radius);
            word-break: break-all;
            border: 1px solid #e9ecef;
            font-family: monospace;
            font-size: 14px;
        }
        .button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
            font-weight: 600;
            transition: var(--transition);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .button:hover {
            background-color: #2878f0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .button:disabled {
            background-color: #d0d0d0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .delete-btn {
            background-color: var(--danger-color);
        }
        .delete-btn:disabled {
            background-color: #d0d0d0;
        }
        .button-container {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .wallet-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 10px;
            margin-right: 3px;
            margin-bottom: 3px;
            font-weight: 600;
            transition: var(--transition);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .wallet-button:hover {
            background-color: #2878f0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .wallet-button:disabled {
            background-color: #d0d0d0 !important;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.6;
        }
        .wallet-button.delete-btn {
            background-color: var(--danger-color);
        }
        .wallet-button.encrypt-btn {
            background-color: #06d6a0;
        }
        .wallet-button.restore-btn {
            background-color: #8338ec;
        }
        .wallet-button.migrate-btn {
            background-color: #666;
        }
        .wallet-button svg {
            width: 10px;
            height: 10px;
        }
        .wallet-actions-container {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-top: 20px;
            align-items: center;
        }
        .warning {
            color: var(--danger-color);
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            background-color: rgba(255, 0, 110, 0.05);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--danger-color);
        }
        .masked {
            filter: blur(8px);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .key-display-container {
            display: flex;
            align-items: center;
        }
        
        @media (max-width: 600px) {
            .key-display-container {
                flex-direction: column;
                align-items: stretch;
            }
            .key-display-container .key-display {
                margin-bottom: 15px;
            }
            .key-display-container .small-button {
                margin-left: 0;
                align-self: center;
            }
        }
        .small-button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
            min-width: 120px;
            transition: var(--transition);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .small-button:hover {
            background-color: #722fd3;
            transform: translateY(-1px);
        }
        .small-button:disabled {
            background-color: #7a7a7a;
            cursor: not-allowed;
            transform: none;
        }
        .input-group {
            margin-bottom: 20px;
        }
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #444;
        }
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 16px;
            transition: var(--transition);
        }
        .input-group input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(58, 134, 255, 0.2);
            outline: none;
        }
        .address-list {
            margin-top: 25px;
        }
        .address-item {
            background-color: var(--light-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            word-break: break-all;
            border: 1px solid #e9ecef;
            transition: var(--transition);
        }
        .address-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }
        .address-item button {
            min-width: auto;
            margin-left: 10px;
            white-space: nowrap;
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 600px) {
            .address-item {
                flex-direction: column;
                align-items: flex-start;
            }
            .address-item > div:first-child {
                margin-bottom: 15px;
                width: 100%;
            }
            .address-item button {
                margin-left: 0;
                align-self: center;
            }
        }
        .path-info {
            margin-top: 8px;
            font-size: 13px;
            color: #666;
            font-family: monospace;
        }
        .qr-modal {
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        .qr-content {
            background-color: #fff;
            padding: 30px;
            border-radius: var(--border-radius);
            text-align: center;
            max-width: 90%;
            box-shadow: var(--box-shadow);
            animation: modalFadeIn 0.3s ease;
        }
        @keyframes modalFadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .qr-content h3 {
            margin-top: 0;
            color: var(--primary-color);
        }
        .close-modal {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 30px;
            color: #fff;
            cursor: pointer;
            transition: var(--transition);
        }
        .close-modal:hover {
            transform: scale(1.1);
        }
        .qr-container {
            margin: 25px auto;
            padding: 0;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .qr-container img {
            width: 100%;
            height: 100%;
            display: block;
        }
        .info-box {
            background-color: rgba(58, 134, 255, 0.1);
            border-left: 4px solid var(--primary-color);
            border-radius: var(--border-radius);
            padding: 15px 20px;
            margin: 20px 0;
            font-size: 15px;
            line-height: 1.6;
            color: #444;
        }
        .info-box h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--primary-color);
            font-weight: 600;
        }
        .card-section {
            margin-top: 30px;
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
        }
        .card-section h2 {
            color: var(--primary-color);
            margin-top: 0;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        #passwordStrength {
            margin-top: 8px;
            font-size: 14px;
            font-weight: 600;
        }
        /* In-browser notifications */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
        }
        
        .notification {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 16px 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
            animation: slideIn 0.3s ease-out;
            transition: all 0.3s ease;
            border-left: 4px solid #3a86ff;
            min-width: 320px;
        }
        
        .notification.success {
            border-left-color: #06d6a0;
        }
        
        .notification.error {
            border-left-color: #ef476f;
        }
        
        .notification.warning {
            border-left-color: #ffba08;
        }
        
        .notification.info {
            border-left-color: #3a86ff;
        }
        
        .notification-icon {
            font-size: 24px;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .notification-content {
            flex: 1;
            margin-right: 12px;
        }
        
        .notification-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
        }
        
        .notification-message {
            font-size: 14px;
            color: #666;
            line-height: 1.4;
        }
        
        .notification-close {
            background: none;
            border: none;
            font-size: 20px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .notification-close:hover {
            background-color: #f0f0f0;
            color: #333;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .notification.removing {
            animation: slideOut 0.3s ease-in;
        }
        
        /* Mobile responsive */
        @media (max-width: 600px) {
            .notification-container {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
            }
            
            .notification {
                min-width: auto;
            }
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
        }
        
        .close-modal:hover,
        .close-modal:focus {
            color: #000;
            text-decoration: none;
        }
        
        .help-link {
            color: #3b82f6;
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .help-link:hover {
            text-decoration: underline;
        }

        /* Vesting Balance Styles */
        .vesting-balance-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .vesting-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .vesting-row:hover {
            background-color: rgba(0, 0, 0, 0.03);
        }

        .vesting-radio-label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            margin: 0;
            min-width: 90px;
        }

        .vesting-radio-label input[type="radio"] {
            cursor: pointer;
            margin: 0;
            width: 14px;
            height: 14px;
        }

        .vesting-mode-name {
            font-weight: 500;
            font-size: 13px;
        }

        .vesting-amount {
            font-size: 14px;
        }

        .vesting-unconfirmed {
            font-size: 12px;
        }

        .vesting-color-vested {
            color: #ef4444;
        }

        .vesting-color-unvested {
            color: #4CAF50;
        }

        .vesting-row-all .vesting-mode-name {
            color: #2196F3;
        }

        /* Highlight selected vesting mode */
        .vesting-row.selected {
            background-color: rgba(33, 150, 243, 0.08);
        }

        .vesting-row-vested.selected {
            background-color: rgba(239, 68, 68, 0.08);
        }

        .vesting-row-unvested.selected {
            background-color: rgba(76, 175, 80, 0.08);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Version Number -->
    <div style="position: fixed; top: 10px; right: 10px; font-size: 10px; color: #999; z-index: 1000; font-family: monospace;">v0.5.0</div>
    
    <!-- Notification Container -->
    <div id="notificationContainer" class="notification-container"></div>
    
    <!-- QR Code Modal -->
    <div id="qrModal" class="qr-modal" style="display: none;">
        <span class="close-modal" onclick="document.getElementById('qrModal').style.display='none'; document.body.style.overflow='';">&times;</span>
        <div class="qr-content">
            <h3>Address QR Code</h3>
            <p style="font-family: monospace; margin: 15px 0; font-size: 15px; word-break: break-all; background: var(--light-bg); padding: 10px; border-radius: var(--border-radius); border: 1px solid #e9ecef;" id="qrAddress"></p>
            <div id="qrContainer" class="qr-container"></div>
            <p style="margin-top: 15px; color: #666;">Use this QR code to share your address with mining services</p>
            <button class="button" onclick="document.getElementById('qrModal').style.display='none'; document.body.style.overflow='';">Close</button>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="passwordModal" class="qr-modal" style="display: none;">
        <div class="qr-content" style="max-width: 400px;">
            <h3 id="passwordModalTitle">Enter Password</h3>
            <p id="passwordModalMessage" style="margin: 15px 0; color: #666;">Please enter your wallet password:</p>
            
            <div class="input-group" style="margin-bottom: 15px;">
                <input type="password" id="passwordModalInput" placeholder="Enter your password" style="width: 100%;">
                <div id="passwordStrength" class="password-strength"></div>
            </div>
            
            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button class="button" style="background-color: #d0d0d0;" id="passwordModalCancelBtn">Cancel</button>
                <button class="button" id="passwordModalSubmitBtn">Submit</button>
            </div>
        </div>
    </div>

    <!-- Password Verification Modal -->
    <div id="passwordVerificationModal" class="qr-modal" style="display: none;">
        <div class="qr-content" style="max-width: 400px;">
            <h3> Verify Password Required</h3>
            <p style="margin: 15px 0; color: #dc2626; font-weight: bold;">You MUST verify your password to ensure you can decrypt your wallet!</p>
            <p style="margin: 15px 0; color: #666;">Please re-enter your password to confirm the wallet was encrypted correctly and can be recovered:</p>
            
            <div class="input-group" style="margin-bottom: 15px;">
                <input type="password" id="passwordVerificationInput" placeholder="Re-enter your password" style="width: 100%;">
            </div>
            
            <div style="padding: 10px; background-color: #fef2f2; border: 1px solid #fecaca; border-radius: 4px; margin-bottom: 15px;">
                <strong style="color: #dc2626;"> Warning:</strong> Without verification, you risk losing access to your funds if the password is incorrect or the file is corrupted.
            </div>
            
            <div style="display: flex; justify-content: center;">
                <button class="button" id="passwordVerificationSubmitBtn" style="width: 100%;">Verify Password</button>
            </div>
        </div>
    </div>

    <!-- Save Modal -->
    <div id="saveModal" class="qr-modal" style="display: none;">
        <div class="qr-content" style="max-width: 500px;">
            <h3 style="margin: 0 0 10px 0;">Save Wallet to File</h3>
            <p style="margin: 0 0 10px 0; color: #666; font-size: 14px;">Save your wallet with optional password protection.</p>
            
            <div class="input-group" style="margin-bottom: 10px;">
                <label for="savePasswordInput" style="font-size: 14px;">Password (optional):</label>
                <input type="password" id="savePasswordInput" placeholder="Leave empty for no encryption" style="width: 100%; font-size: 14px;">
                <div id="savePasswordStrength" style="margin-top: 5px;"></div>
            </div>
            
            <div class="input-group" style="margin-bottom: 10px;">
                <label for="saveFilenameInput" style="font-size: 14px;">Filename:</label>
                <input type="text" id="saveFilenameInput" value="alpha_wallet_backup.txt" style="width: 100%; font-size: 14px;">
            </div>
            
            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button class="button" style="background-color: #d0d0d0; font-size: 14px;" onclick="closeSaveModal()">Cancel</button>
                <button class="button" style="font-size: 14px;" onclick="saveWallet()">Save</button>
            </div>
        </div>
    </div>

    <!-- Restore Modal -->
    <div id="restoreModal" class="qr-modal" style="display: none;">
        <div class="qr-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <h3 style="margin: 0 0 10px 0;">Load Wallet from File</h3>
            <p style="margin: 0 0 10px 0; color: #666; font-size: 14px;">Upload a wallet backup file (.txt) or BIP32 wallet.dat file to load your wallet.</p>
            
            <div class="input-group" style="margin-bottom: 10px;">
                <label for="restoreFileInput" style="font-size: 14px;">Backup File:</label>
                <input type="file" id="restoreFileInput" accept=".txt,.dat" style="width: 100%; font-size: 14px;">
            </div>
            
            <div class="input-group" style="margin-bottom: 10px;">
                <label for="restorePasswordInput" style="font-size: 14px;">Password (if encrypted):</label>
                <input type="password" id="restorePasswordInput" placeholder="Enter wallet password" style="width: 100%; font-size: 14px;">
            </div>
            
            <!-- Wallet Scan Results -->
            <div id="walletScanResults" style="display: none; margin: 10px 0;">
                <h4 style="margin: 0 0 8px 0; font-size: 16px;">Found Wallets</h4>
                <div id="scanProgressBar" style="margin-bottom: 10px;">
                    <div style="height: 16px; background-color: #e9e9e9; border-radius: 8px; overflow: hidden;">
                        <div id="scanProgress" style="width: 0%; height: 100%; background-color: var(--primary-color); transition: width 0.3s;"></div>
                    </div>
                    <div style="margin-top: 4px; font-size: 11px; color: #666;">
                        <span id="scanStatus">Scanning...</span>
                        <span id="scanCounter" style="float: right;">0 / 100</span>
                    </div>
                    <div style="margin-top: 8px; text-align: center;">
                        <button class="button" id="stopScanBtn" onclick="scanningActive = false;" style="background-color: #d0d0d0; padding: 4px 12px; font-size: 12px;">Stop Scan</button>
                    </div>
                </div>
                <div id="foundWalletsList" style="max-height: 250px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; padding: 8px; margin-top: 10px;">
                    <!-- Found wallets will be listed here -->
                </div>
            </div>
            
            <div id="restoreStatus" class="info-box" style="display: none; margin-bottom: 10px;"></div>
            
            <div style="display: flex; justify-content: space-between; gap: 10px; margin-bottom: 10px;">
                <button class="button" style="background-color: #d0d0d0; font-size: 14px;" id="restoreModalCancelBtn">Cancel</button>
                <button class="button" id="restoreModalSubmitBtn" style="font-size: 14px;">Load</button>
                <button class="button" id="scanWalletsBtn" style="display: none; font-size: 14px;">Rescan Wallets</button>
            </div>
            
            <!-- Wallet Scanning Options -->
            <div id="walletScanOptions" style="display: none; margin: 10px 0; padding: 10px; background-color: #f8f9fa; border-radius: 6px;">
                <h4 style="margin: 0 0 8px 0; font-size: 14px;">Wallet Discovery Settings</h4>
                <div class="input-group" style="margin-bottom: 8px;">
                    <label for="scanCountInput" style="font-size: 13px;">Number of addresses to scan:</label>
                    <input type="number" id="scanCountInput" value="100" min="1" max="1000" style="width: 80px; font-size: 13px;">
                    <span style="margin-left: 8px; color: #666; font-size: 11px;">Scan multiple addresses to find wallets with funds</span>
                </div>
                <div style="margin-top: 6px;">
                    <label style="font-size: 13px;">
                        <input type="checkbox" id="scanChangeAddresses" checked>
                        Also scan change addresses (internal chain)
                    </label>
                </div>
                <div style="margin-top: 6px;">
                    <label style="font-size: 13px;">
                        <input type="checkbox" id="scanOnlineCheckbox" checked>
                        Check balances online (requires Fulcrum connection)
                    </label>
                </div>
            </div>
        </div>
    </div>

    <div class="wallet-container">
        <div class="header">
            <h1>
                <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="var(--primary-color)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 10px;">
                    <rect x="2" y="6" width="20" height="12" rx="2"></rect>
                    <circle cx="12" cy="12" r="2"></circle>
                    <path d="M6 12h.01M18 12h.01"></path>
                </svg>
                Unicity WEB GUI Wallet v0.5.0
            </h1>
        </div>
        
        <div style="text-align: right; margin-bottom: 5px; margin-top: -5px;">
            <a href="#" class="help-link" onclick="showHelpModal(); return false;" style="font-size: 12px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                    <line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>
                How to use
            </a>
            <a href="#" class="help-link" onclick="openDisclaimerModal(); return false;" style="font-size: 12px; margin-left: 20px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
                Disclaimer
            </a>
            <a href="#" class="help-link" onclick="openSecurityNotesModal(); return false;" style="font-size: 12px; margin-left: 20px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0110 0v4"></path>
                </svg>
                Security Notes
            </a>
        </div>
        
        <!-- Main Tab Navigation -->
        <div style="display: flex; gap: 0; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0; background-color: white; border-radius: 8px 8px 0 0;">
            <button id="walletTabBtn" class="main-tab-button active" onclick="switchMainTab('wallet')" style="flex: 1; padding: 12px 20px; background: white; border: none; border-bottom: 3px solid #4CAF50; color: #333; font-weight: 600; cursor: pointer; font-size: 14px; transition: all 0.3s;">Wallet</button>
            <button id="coldWalletTabBtn" class="main-tab-button" onclick="switchMainTab('coldWallet')" style="flex: 1; padding: 12px 20px; background: white; border: none; border-bottom: 3px solid transparent; color: #666; cursor: pointer; font-size: 14px; transition: all 0.3s;">Cold Wallet Tools</button>
        </div>

        <!-- Wallet Tab Content -->
        <div id="walletTabContent" class="main-tab-content" style="display: block;">
        <div id="wallet-section" class="card-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">My Wallet</h2>
                <div id="walletQrCode" style="display: none;">
                    <!-- QR code will be generated here -->
                </div>
            </div>
            
            <!-- Compact Endpoint Section -->
            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 15px; padding: 6px 8px; background-color: #f8f9fa; border-radius: 4px;">
                <label for="rpcServer" style="margin: 0; font-weight: 600; white-space: nowrap; font-size: 10px;">Endpoint:</label>
                <input type="text" id="rpcServer" placeholder="wss://fulcrum.unicity.network:50004" value="wss://fulcrum.unicity.network:50004" style="flex: 1; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 10px;">
                <button id="connectRpcBtn" class="wallet-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                    </svg>
                    Connect
                </button>
                <button id="disconnectRpcBtn" class="wallet-button" style="display: none; background-color: #ff006e;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"></path>
                        <path d="m6 6 12 12"></path>
                    </svg>
                    Disconnect
                </button>
            </div>
            
            <!-- Wallet Info Section -->
            <div id="walletInfo" style="display: none; margin-bottom: 15px; padding: 15px; background-color: rgba(52, 211, 153, 0.05); border-radius: 8px; border: 1px solid rgba(52, 211, 153, 0.2);">
                <!-- Address Row -->
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px; margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <a id="walletAddressLink" href="#" target="_blank" style="color: var(--primary-color); text-decoration: none; font-family: monospace;">
                            <span id="walletAddress">-</span>
                        </a>
                        <button onclick="copyAddress('wallet')" style="background: none; border: none; cursor: pointer; padding: 4px; display: flex; align-items: center;" title="Copy address">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                        </button>
                    </div>
                    <div>
                        <span style="font-size: 12px; color: #999;">Last update: <span id="lastUpdateTime">-</span></span>
                    </div>
                </div>

                <!-- Vesting Balance Display -->
                <div id="vestingBalanceSection" class="vesting-balance-section">
                    <!-- All Balance Row -->
                    <div class="vesting-row vesting-row-all">
                        <label class="vesting-radio-label">
                            <input type="radio" name="vestingMode" value="all" checked onchange="setVestingMode('all')">
                            <span class="vesting-mode-name">All:</span>
                        </label>
                        <span id="walletBalance" class="vesting-amount" style="font-weight: 600;">0 ALPHA</span>
                        <span id="balanceVerificationSpinner" style="display: none; margin-left: 5px;">
                            <span style="display: inline-block; width: 12px; height: 12px;
                                  border: 2px solid #f3f3f3; border-top: 2px solid #2196F3;
                                  border-radius: 50%; animation: spin 1s linear infinite;"></span>
                        </span>
                        <span id="walletUnconfirmed" class="vesting-unconfirmed" style="color: #999;">(0)</span>
                    </div>

                    <!-- Vested Balance Row -->
                    <div class="vesting-row vesting-row-vested">
                        <label class="vesting-radio-label">
                            <input type="radio" name="vestingMode" value="vested" onchange="setVestingMode('vested')">
                            <span class="vesting-mode-name vesting-color-vested">Vested (locked after TGE):</span>
                        </label>
                        <span id="vestedBalance" class="vesting-amount vesting-color-vested">0 ALPHA</span>
                        <span id="vestedUnconfirmed" class="vesting-unconfirmed" style="color: #999;"></span>
                    </div>

                    <!-- Unvested Balance Row -->
                    <div class="vesting-row vesting-row-unvested">
                        <label class="vesting-radio-label">
                            <input type="radio" name="vestingMode" value="unvested" onchange="setVestingMode('unvested')">
                            <span class="vesting-mode-name vesting-color-unvested">Unvested (not locked):</span>
                        </label>
                        <span id="unvestedBalance" class="vesting-amount vesting-color-unvested">0 ALPHA</span>
                        <span id="unvestedUnconfirmed" class="vesting-unconfirmed" style="color: #999;"></span>
                    </div>

                    <!-- Classification Progress -->
                    <div id="vestingClassificationProgress" style="display: none; margin-top: 8px; padding: 6px 10px; background-color: rgba(33, 150, 243, 0.1); border-radius: 4px;">
                        <span style="font-size: 12px; color: #666;">
                            Classifying coins... <span id="vestingProgressText">0/0</span>
                            <span style="display: inline-block; width: 10px; height: 10px; border: 2px solid #f3f3f3; border-top: 2px solid #2196F3; border-radius: 50%; animation: spin 1s linear infinite; margin-left: 5px;"></span>
                        </span>
                    </div>

                    <!-- Total Scanned Balance (BIP32 wallets) -->
                    <div id="totalScannedBalanceRow" style="display: none; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(0,0,0,0.1);">
                        <span id="totalScannedBalance" style="font-size: 13px;">
                            Total (all addresses): <span style="font-weight: 600;" id="totalScannedAmount">0 ALPHA</span>
                            <a href="#" onclick="showScannedWalletsDialog(); return false;" style="color: var(--primary-color); text-decoration: none; margin-left: 5px;" title="View all scanned wallets">[view all]</a>
                        </span>
                        <span id="totalScannedLoading" style="display: none; margin-left: 10px; color: #666; font-size: 12px;">
                            <span id="scanStatusText">Scanning <span id="scanPercentage">0%</span></span>
                            <span style="display: inline-block; width: 10px; height: 10px; border: 2px solid #f3f3f3; border-top: 2px solid #666; border-radius: 50%; animation: spin 1s linear infinite; margin-left: 3px;"></span>
                        </span>
                    </div>
                </div>
            </div>
            
            <!-- Watch-Only Address Input -->
            <div id="watchOnlySection" style="display: none; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 6px; padding: 6px 8px; background-color: #f8f9fa; border-radius: 4px;">
                    <label style="margin: 0; font-weight: 600; white-space: nowrap; font-size: 10px;">Watch:</label>
                    <input type="text" id="watchOnlyAddress" placeholder="alpha1..." style="flex: 1; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-family: monospace; font-size: 10px;">
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <span id="watchOnlyBalance" style="font-weight: 600; font-size: 10px;">-</span>
                        <span id="watchOnlyUnconfirmed" style="color: #999; font-size: 10px;"></span>
                    </div>
                </div>
                <div style="margin-top: 4px; padding-left: 8px;">
                    <span style="font-size: 9px; color: #666;">Enter any Alpha address to monitor its balance and UTXOs</span>
                </div>
            </div>
            
            <div class="wallet-actions-container">
                <button id="initializeWalletBtn" class="wallet-button" title="Creates a new wallet with a secure private key. This is the first step to use this wallet.">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    Create
                </button>
                <button id="restoreWalletBtn" class="wallet-button restore-btn" title="Load wallet from file">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Load
                </button>
                <button id="saveWalletBtn" class="wallet-button" disabled title="Save wallet to file with optional encryption">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    Save
                </button>
                <button id="switchWalletBtn" class="wallet-button" title="Switch between multiple wallets">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                        <polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline>
                        <polyline points="7.5 19.79 7.5 14.6 3 12"></polyline>
                        <polyline points="21 12 16.5 14.6 16.5 19.79"></polyline>
                        <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                        <line x1="12" y1="22.08" x2="12" y2="12"></line>
                    </svg>
                    Switch
                </button>
                <button id="deleteWalletBtn" class="wallet-button delete-btn" disabled title="Reset wallet data in your browser. This will clear the current wallet.">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path>
                        <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M14 3h7v7"></path>
                        <path d="M10 21H3v-7"></path>
                    </svg>
                    Reset
                </button>
                <button id="importBroadcastBtn" onclick="document.getElementById('txFileInput').click()" class="wallet-button" style="background-color: #fbbf24;" disabled title="Import and broadcast signed transactions">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"></path>
                        <path d="M12 12v9"></path>
                        <path d="m8 17 4 4 4-4"></path>
                    </svg>
                    Broadcast
                </button>
            </div>
            
            <!-- Hidden file input for transaction import -->
            <input type="file" id="txFileInput" accept=".json" style="display: none;">

            <!-- Compact Send Transaction -->
            <div id="sendTransactionSection" style="margin-top: 15px; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 6px; padding: 6px 8px; background-color: #f8f9fa; border-radius: 4px;">
                    <label for="recipientAddress" style="margin: 0; font-weight: 600; white-space: nowrap; font-size: 10px;">Destination:</label>
                    <input type="text" id="recipientAddress" placeholder="alpha1..." style="flex: 1; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 10px; font-family: monospace;">
                    <input type="number" id="sendAmount" placeholder="0.00000000" step="0.00000001" min="0" style="width: 100px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 10px;">
                    <button onclick="calculateMaxAmount()" class="wallet-button" style="background-color: #60a5fa; font-size: 9px; padding: 4px 8px;" title="Calculate maximum sendable amount">Max</button>
                    <button id="sendTransactionBtn" onclick="prepareSendTransaction()" class="wallet-button" style="background-color: #34d399;">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                        Send
                    </button>
                </div>
            </div>

            <!-- Transaction History -->
            <div id="transactionHistoryContainer" style="margin-top: 20px; display: none;">
                <h4 style="margin-bottom: 10px;">Transaction History</h4>
                <div id="transactionHistoryList" style="max-height: 400px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 8px; padding: 10px; background-color: #f9fafb;">
                    <p style="color: #999; text-align: center;">Loading transactions...</p>
                </div>
            </div>
        </div>
        </div>
        <!-- End Wallet Tab Content -->
        
        <!-- Cold Wallet Tab Content -->
        <div id="coldWalletTabContent" class="main-tab-content" style="display: none;">
        <div id="rpc-section" class="card-section">
            <h2>Cold Wallet Tools</h2>
            
            <div id="connectionStatus" style="margin-top: 20px; display: none;">
                <div class="info-box" style="background-color: rgba(255, 186, 8, 0.1); border-left: 4px solid #ffba08;">
                    <p id="connectionStatusText">Connecting...</p>
                </div>
            </div>
            
            
            <!-- UTXO List Display -->
            <div id="utxoListContainer" style="margin-top: 15px;">
                <h4 style="margin-bottom: 10px;">Loaded UTXOs</h4>
                <div id="currentUtxoList" style="max-height: 300px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 8px; padding: 10px; background-color: #f9fafb; font-size: 12px; font-family: monospace;">
                    <p style="color: #999; text-align: center;">No UTXOs loaded</p>
                </div>
            </div>
            
            <!-- UTXO Import/Export Buttons -->
            <div style="margin-top: 15px; display: flex; gap: 3px;">
                <button id="exportUtxoBtn" onclick="exportUtxoData()" class="wallet-button" style="background-color: #06d6a0;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Export UTXO Data
                </button>
                <button id="importUtxoBtn" onclick="importUtxoData()" class="wallet-button" style="background-color: #8338ec;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Import UTXO Data
                </button>
                <button id="clearUtxoBtn" onclick="clearOfflineUtxoData()" class="wallet-button" style="background-color: #ef476f; display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    Clear UTXOs
                </button>
            </div>
            
            <!-- Hidden file input for UTXO import -->
            <input type="file" id="utxoFileInput" accept=".json" style="display: none;">
        </div>
        </div>
        <!-- End Cold Wallet Tab Content -->
        
    </div>


    <script>
        // Character set for Bech32 encoding
        const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
        
        // Save Modal Functions (global scope for onclick handlers)
        function showSaveModal() {
            const saveModal = document.getElementById('saveModal');
            const savePasswordInput = document.getElementById('savePasswordInput');
            const saveFilenameInput = document.getElementById('saveFilenameInput');
            
            // Generate filename from first address if available
            let filename = 'alpha_wallet_backup.txt';
            const wallet = window.walletGlobal;
            if (wallet && wallet.addresses && wallet.addresses.length > 0) {
                const firstAddress = wallet.addresses[0].address;
                // Get first 10 letters and last 6 letters
                const first10 = firstAddress.substring(0, 10);
                const last6 = firstAddress.substring(firstAddress.length - 6);
                
                // Add wallet type suffix
                let walletType = '_wif'; // Default for standard wallets
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    walletType = '_bip32';
                }
                
                filename = `${first10}_${last6}${walletType}.txt`;
            }
            
            saveModal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            savePasswordInput.value = '';
            saveFilenameInput.value = filename;
            savePasswordInput.focus();
        }
        
        function closeSaveModal() {
            const saveModal = document.getElementById('saveModal');
            saveModal.style.display = 'none';
            document.body.style.overflow = '';
        }
        
        function showPasswordVerificationModal(callback) {
            const modal = document.getElementById('passwordVerificationModal');
            const input = document.getElementById('passwordVerificationInput');
            const submitBtn = document.getElementById('passwordVerificationSubmitBtn');
            
            // Clear previous input
            input.value = '';
            
            // Show modal
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            input.focus();
            
            // Handle submit
            const handleSubmit = () => {
                const password = input.value;
                if (!password) {
                    // Don't allow empty password
                    input.style.borderColor = '#dc2626';
                    input.placeholder = 'Password is required for verification';
                    return;
                }
                modal.style.display = 'none';
                document.body.style.overflow = '';
                callback(password);
            };
            
            // Set up event listeners
            submitBtn.onclick = handleSubmit;
            
            // Handle Enter key
            input.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    handleSubmit();
                }
            };
            
            // Reset border color when typing
            input.oninput = () => {
                input.style.borderColor = '';
                input.placeholder = 'Re-enter your password';
            };
        }
        
        function saveWallet() {
            const savePasswordInput = document.getElementById('savePasswordInput');
            const saveFilenameInput = document.getElementById('saveFilenameInput');
            const password = savePasswordInput.value;
            const filename = saveFilenameInput.value || 'alpha_wallet_backup.txt';
            
            // Access wallet from global scope or window
            const wallet = window.walletGlobal;
            
            if (!wallet || !wallet.masterPrivateKey) {
                window.showInAppNotification('No Wallet', 'No wallet to save', 'error');
                closeSaveModal();
                return;
            }
            
            let content;
            
            if (password) {
                // Encrypt the wallet with password
                const walletData = {
                    masterPrivateKey: wallet.masterPrivateKey,
                    masterChainCode: wallet.masterChainCode,
                    isImportedAlphaWallet: wallet.isImportedAlphaWallet,
                    addresses: wallet.addresses
                };
                
                // Use same encryption method as old format for backward compatibility
                const salt = "alpha_wallet_salt";
                const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                
                // Encrypt only the master private key for backward compatibility
                const encryptedMasterKey = CryptoJS.AES.encrypt(wallet.masterPrivateKey, passwordKey).toString();
                
                // Get addresses text - different format for BIP32 vs standard wallets
                let addressesText;
                if (wallet.isImportedAlphaWallet) {
                    addressesText = wallet.addresses.map((addr, index) => 
                        `Address ${index + 1}: ${addr.address}`
                    ).join('\n');
                } else {
                    addressesText = wallet.addresses.map(a => 
                        `Address ${a.index + 1}: ${a.address} (Path: ${a.path})`
                    ).join('\n');
                }
                
                // Build content with wallet type info
                let encryptedContent = `ENCRYPTED MASTER KEY (password protected):
${encryptedMasterKey}`;
                
                // Add chain code and wallet type for BIP32 wallets
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    encryptedContent += `

MASTER CHAIN CODE (for BIP32 HD wallet compatibility):
${wallet.masterChainCode}

WALLET TYPE: BIP32 hierarchical deterministic wallet`;
                } else {
                    encryptedContent += `

WALLET TYPE: Standard wallet (HMAC-based)`;
                }
                
                content = `UNICITY WALLET DETAILS
===========================

${encryptedContent}

ENCRYPTION STATUS: Encrypted with password
To use this key, you will need the password you set in the wallet.

YOUR ADDRESSES:
${addressesText}

Generated on: ${new Date().toLocaleString()}

WARNING: Keep your master private key safe and secure.
Anyone with your master private key can access all your funds.`;
            } else {
                // Save unencrypted wallet
                const masterKeyWIF = window.hexToWIF ? window.hexToWIF(wallet.masterPrivateKey) : wallet.masterPrivateKey;
                
                let masterKeySection;
                let addressesText;
                
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    // Format for imported Alpha wallet.dat files - save HEX first for internal use
                    masterKeySection = `MASTER PRIVATE KEY (keep secret!):
${wallet.masterPrivateKey}

MASTER PRIVATE KEY IN WIF FORMAT (for importprivkey command):
${masterKeyWIF}

MASTER CHAIN CODE (for BIP32 HD wallet compatibility):
${wallet.masterChainCode}

WALLET TYPE: BIP32 hierarchical deterministic wallet

ENCRYPTION STATUS: Not encrypted
This key is in plaintext and not protected. Anyone with this file can access your wallet.`;
                    
                    addressesText = wallet.addresses.map((addr, index) => 
                        `Address ${index + 1}: ${addr.address}`
                    ).join('\n');
                } else {
                    // Format for HTML wallet app created wallets - use old format exactly
                    addressesText = wallet.addresses.map(a => 
                        `Address ${a.index + 1}: ${a.address} (Path: ${a.path})`
                    ).join('\n');
                    
                    masterKeySection = 
`MASTER PRIVATE KEY (keep secret!):
${wallet.masterPrivateKey}

MASTER PRIVATE KEY IN WIF FORMAT (for importprivkey command):
${masterKeyWIF}

WALLET TYPE: Standard wallet (HMAC-based)

ENCRYPTION STATUS: Not encrypted
This key is in plaintext and not protected. Anyone with this file can access your wallet.`;
                }
                
                content = `UNICITY WALLET DETAILS
===========================

${masterKeySection}

YOUR ADDRESSES:
${addressesText}

Generated on: ${new Date().toLocaleString()}

WARNING: Keep your master private key safe and secure.
Anyone with your master private key can access all your funds.`;
            }
            
            // Create and download the file
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const finalFilename = filename.endsWith('.txt') ? filename : filename + '.txt';
            a.download = finalFilename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            closeSaveModal();
            
            // Automatically verify the content before user relies on it
            setTimeout(() => {
                if (password) {
                    // For encrypted wallets, ALWAYS require password verification
                    showPasswordVerificationModal((verifyPassword) => {
                        // verifyPassword will never be null/empty now since we require it
                        // Simulate reading the saved file by using the exact content we saved
                        verifyEncryptedWalletContent(content, password, verifyPassword, wallet);
                    });
                } else {
                    // For unencrypted wallets, verify immediately
                    verifyUnencryptedWalletContent(content, wallet);
                }
            }, 300);
        }
        
        // Verify encrypted wallet content (same process as loading from file)
        function verifyEncryptedWalletContent(savedContent, originalPassword, verifyPassword, originalWallet) {
            // This simulates the exact same process as loading the wallet from a file
            try {
                // Extract encrypted master key using the old format pattern
                const encryptedKeyMatch = savedContent.match(/ENCRYPTED MASTER KEY \(password protected\):\s*([^\n]+)/);
                
                if (!encryptedKeyMatch || !encryptedKeyMatch[1]) {
                    throw new Error('Invalid encrypted wallet format - would fail to load from file');
                }
                
                const encryptedMasterKey = encryptedKeyMatch[1].trim();
                
                // Try to decrypt using the same method as wallet loading
                try {
                    // Use PBKDF2 for backward compatibility
                    const salt = "alpha_wallet_salt";
                    const passwordKey = CryptoJS.PBKDF2(verifyPassword, salt, { keySize: 256/32, iterations: 100000 }).toString();
                    
                    // Decrypt the master key
                    const decryptedBytes = CryptoJS.AES.decrypt(encryptedMasterKey, passwordKey);
                    const decryptedMasterKey = decryptedBytes.toString(CryptoJS.enc.Utf8);
                    
                    // Check if decryption produced empty result (wrong password)
                    if (!decryptedMasterKey) {
                        if (verifyPassword !== originalPassword) {
                            window.showInAppNotification('Incorrect Password', 
                                'The verification password is incorrect. The wallet was encrypted with the first password.', 
                                'error');
                        } else {
                            // This shouldn't happen - same password but can't decrypt
                            showCriticalError('Encryption verification failed - unable to decrypt with the same password');
                        }
                        return;
                    }
                    
                    // Check if passwords match
                    if (originalPassword !== verifyPassword) {
                        window.showInAppNotification('Password Mismatch', 
                            'The verification password does not match. The wallet was encrypted with the first password you entered.', 
                            'warning');
                        return;
                    }
                    
                    // Verify master key matches
                    if (decryptedMasterKey !== originalWallet.masterPrivateKey) {
                        showCriticalError('Master key mismatch after decryption');
                        return;
                    }
                    
                    // Also verify addresses from the file content
                    const addressMatches = savedContent.match(/Address \d+: (alpha1[a-z0-9]{38,})/g);
                    if (addressMatches) {
                        const savedAddresses = addressMatches.map(match => {
                            const addrMatch = match.match(/Address \d+: (alpha1[a-z0-9]{38,})/);
                            return addrMatch ? addrMatch[1] : null;
                        }).filter(a => a).sort();
                        
                        const currentAddresses = originalWallet.addresses.map(a => a.address).sort();
                    
                        if (JSON.stringify(savedAddresses) !== JSON.stringify(currentAddresses)) {
                            showCriticalError('Address mismatch detected during verification');
                            return;
                        }
                    }
                    
                    window.showInAppNotification(' Wallet Verified', 
                        'Encrypted wallet saved successfully! Decryption and address derivation verified.', 
                        'success');
                        
                } catch (decryptError) {
                    console.error('Decryption error:', decryptError);
                    
                    // Check if it's a UTF-8 error (usually means wrong password or corrupted data)
                    if (decryptError.message && decryptError.message.includes('UTF-8')) {
                        if (verifyPassword !== originalPassword) {
                            window.showInAppNotification('Incorrect Password', 
                                'The verification password is incorrect. The wallet was encrypted with the first password.', 
                                'error');
                        } else {
                            // Both passwords are the same but still can't decrypt - this is a critical error
                            showCriticalError('Encryption failed - unable to decrypt with the correct password. Error: ' + decryptError.message);
                        }
                    } else if (decryptError.message && decryptError.message.includes('JSON')) {
                        showCriticalError('Decrypted data is not valid JSON: ' + decryptError.message);
                    } else {
                        showCriticalError('Decryption failed during verification: ' + decryptError.message);
                    }
                }
            } catch (error) {
                showCriticalError('Failed to verify encrypted wallet: ' + error.message);
            }
        }
        
        // Verify unencrypted wallet content
        function verifyUnencryptedWalletContent(savedContent, originalWallet) {
            try {
                // Extract addresses from saved content (same as file loading would do)
                const addressMatches = savedContent.match(/Address \d+: (alpha1[a-z0-9]{38,})/g);
                if (!addressMatches) {
                    showCriticalError('No addresses found in saved wallet content');
                    return;
                }
                
                const savedAddresses = addressMatches.map(match => {
                    const addrMatch = match.match(/Address \d+: (alpha1[a-z0-9]{38,})/);
                    return addrMatch ? addrMatch[1] : null;
                }).filter(a => a).sort();
                
                const currentAddresses = originalWallet.addresses.map(a => a.address).sort();
                
                if (JSON.stringify(savedAddresses) !== JSON.stringify(currentAddresses)) {
                    showCriticalError('Address mismatch detected in saved content');
                    return;
                }
                
                // Extract and verify master key
                const masterKeyMatch = savedContent.match(/MASTER PRIVATE KEY \(keep secret!\):\s*([^\n]+)/);
                if (masterKeyMatch) {
                    const savedMasterKey = masterKeyMatch[1].trim();
                    // The saved file has the hex key, we need to verify it matches
                    if (savedMasterKey !== originalWallet.masterPrivateKey && 
                        !verifyKeyEquivalence(savedMasterKey, originalWallet.masterPrivateKey)) {
                        showCriticalError('Master key mismatch detected in saved content');
                        return;
                    }
                }
                
                window.showInAppNotification(' Wallet Verified', 
                    'Wallet saved successfully! All addresses verified.', 
                    'success');
                    
            } catch (error) {
                showCriticalError('Failed to verify wallet: ' + error.message);
            }
        }
        
        // Helper to verify if two keys are equivalent (one might be WIF, other hex)
        function verifyKeyEquivalence(key1, key2) {
            // If they're exactly the same, they're equivalent
            if (key1 === key2) return true;
            
            // Try converting hex to WIF if one is hex
            if (key1.length === 64 && window.hexToWIF) {
                return window.hexToWIF(key1) === key2;
            }
            if (key2.length === 64 && window.hexToWIF) {
                return key1 === window.hexToWIF(key2);
            }
            
            return false;
        }
        
        // Keep old function for backward compatibility but it's not used anymore
        function verifyEncryptedWallet(savedContent, originalPassword, verifyPassword, originalWallet, isFromFile = false) {
            try {
                // Extract encrypted data from saved content
                const encryptedMatch = savedContent.match(/ENCRYPTED UNICITY WALLET[\s\S]*?\n\n([\s\S]+?)\n\nGenerated on:/);
                
                if (!encryptedMatch || !encryptedMatch[1]) {
                    throw new Error('Could not extract encrypted data from saved file');
                }
                
                const encryptedData = encryptedMatch[1].trim();
                
                // Try to decrypt with the verify password
                try {
                    const decryptedData = CryptoJS.AES.decrypt(encryptedData, verifyPassword).toString(CryptoJS.enc.Utf8);
                    const walletData = JSON.parse(decryptedData);
                    
                    // Check if passwords match
                    if (originalPassword !== verifyPassword) {
                        window.showInAppNotification('Password Mismatch', 
                            'The verification password does not match the encryption password. The wallet was saved with the first password you entered.', 
                            'warning');
                        return;
                    }
                    
                    // Verify addresses match
                    const savedAddresses = walletData.addresses.map(a => a.address).sort();
                    const currentAddresses = originalWallet.addresses.map(a => a.address).sort();
                    
                    if (JSON.stringify(savedAddresses) !== JSON.stringify(currentAddresses)) {
                        showCriticalError('Address mismatch detected');
                        return;
                    }
                    
                    // Verify master key matches
                    if (walletData.masterPrivateKey !== originalWallet.masterPrivateKey) {
                        showCriticalError('Master key mismatch detected');
                        return;
                    }
                    
                    window.showInAppNotification('Wallet Verified', 
                        isFromFile ? 'Encrypted wallet file read and verified successfully!' : 'Encrypted wallet saved and verified successfully!', 
                        'success');
                        
                } catch (decryptError) {
                    if (verifyPassword !== originalPassword) {
                        window.showInAppNotification('Incorrect Password', 
                            'The verification password is incorrect. The wallet was saved with the first password you entered.', 
                            'error');
                    } else {
                        showCriticalError('Decryption failed during verification');
                    }
                }
            } catch (error) {
                showCriticalError('Failed to verify encrypted wallet: ' + error.message);
            }
        }
        
        // Verify unencrypted wallet addresses match
        function verifyUnencryptedWallet(savedContent, originalWallet, isFromFile = false) {
            try {
                // Extract addresses from saved content
                const addressMatches = savedContent.match(/Address \d+: (alpha1[a-z0-9]{38,})/g);
                if (!addressMatches) {
                    showCriticalError('No addresses found in saved wallet file');
                    return;
                }
                
                const savedAddresses = addressMatches.map(match => {
                    const addrMatch = match.match(/Address \d+: (alpha1[a-z0-9]{38,})/);
                    return addrMatch ? addrMatch[1] : null;
                }).filter(a => a).sort();
                
                const currentAddresses = originalWallet.addresses.map(a => a.address).sort();
                
                if (JSON.stringify(savedAddresses) !== JSON.stringify(currentAddresses)) {
                    showCriticalError('Address mismatch detected in saved file');
                    return;
                }
                
                // Extract and verify master key
                const masterKeyMatch = savedContent.match(/MASTER PRIVATE KEY \(keep secret!\):\s*([^\n]+)/);
                if (masterKeyMatch) {
                    const savedMasterKey = masterKeyMatch[1].trim();
                    // Compare hex format if both are hex, or WIF if needed
                    if (savedMasterKey !== originalWallet.masterPrivateKey && 
                        savedMasterKey !== (window.hexToWIF ? window.hexToWIF(originalWallet.masterPrivateKey) : originalWallet.masterPrivateKey)) {
                        // It's OK if one is WIF and other is hex, as long as they represent the same key
                        // For now, we'll just log a warning
                        console.log('Master key format difference detected (hex vs WIF)');
                    }
                }
                
                window.showInAppNotification('Wallet Verified', 
                    isFromFile ? 'Wallet file read and verified successfully!' : 'Wallet saved and verified successfully!', 
                    'success');
                    
            } catch (error) {
                showCriticalError('Failed to verify wallet: ' + error.message);
            }
        }
        
        // Show critical error dialog
        function showCriticalError(details) {
            const errorModal = document.createElement('div');
            errorModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            errorModal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; max-width: 600px; text-align: center;">
                    <div style="font-size: 48px; color: #ff0000; margin-bottom: 20px;"> CRITICAL ERROR</div>
                    <h2 style="color: #ff0000; margin-bottom: 20px;">WALLET SAVE VERIFICATION FAILED</h2>
                    <p style="font-size: 18px; margin-bottom: 20px; color: #333;">
                        The saved wallet file could not be verified. This is an internal application error.
                    </p>
                    <p style="font-size: 16px; margin-bottom: 20px; color: #666;">
                        <strong>Error details:</strong> ${details}
                    </p>
                    <div style="background: #ffe0e0; padding: 20px; border-radius: 5px; margin-bottom: 20px;">
                        <p style="font-size: 16px; color: #cc0000; margin: 0;">
                            <strong>IMPORTANT:</strong> Do not rely on this backup file!<br>
                            Please report this issue immediately to the developer (cryptohog) 
                            on the Discord helpdesk channel.
                        </p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" 
                            style="background: #ff0000; color: white; border: none; padding: 10px 30px; 
                                   border-radius: 5px; font-size: 16px; cursor: pointer;">
                        Close
                    </button>
                </div>
            `;
            
            document.body.appendChild(errorModal);
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Global variables that need to be available throughout the app
            let currentBlockHeight = null;
            let currentBlockTime = null;
            let lastUpdateBlockHeight = null;
            let currentUtxos = [];
            let currentTransactions = [];
            let currentTransactionPage = 1;
            let currentUtxoPage = 1;
            let offlineUtxoData = null;
            let electrumConnected = false;
            let broadcastQueue = [];
            let isQueueProcessing = false;
            let lastBroadcastBlock = null;
            let transactionsInCurrentBlock = 0;
            const MAX_TRANSACTIONS_PER_BLOCK = 30;
            let queueStatusElement = null;
            let autoClearTimeout = null;

            // Vesting classification state
            const VESTING_THRESHOLD = 280000;  // Block 280000 is the cutoff
            let vestingMode = 'all';  // 'all', 'vested', 'unvested'
            let vestingClassificationInProgress = false;

            // Per-address vesting cache: address -> { classifiedUtxos, vestingBalances }
            window.addressVestingCache = new Map();
            let addressVestingCache = window.addressVestingCache;

            // ===== TXO Classification Queue System =====
            // Permanent TXO-level cache: "txhash:vout" -> {isVested, coinbaseHeight}
            // This cache persists to IndexedDB and includes ALL TXOs visited during tracing
            const txoClassificationCache = new Map();
            window.txoClassificationCache = txoClassificationCache;  // Make globally accessible

            // IndexedDB configuration for TXO cache
            const TXO_CACHE_DB = 'TxoClassifications';
            const TXO_CACHE_STORE = 'txoCache';
            let txoCacheDB = null;

            // Processing queue for unclassified UTXOs
            const utxoProcessingQueue = [];
            let isProcessingUtxoQueue = false;

            // Running balance totals (BigInt for precision) - updated during classification
            let runningVestedBalance = 0n;
            let runningUnvestedBalance = 0n;
            // Unconfirmed (mempool) portions of vested/unvested balances
            let unconfirmedVestedBalance = 0n;
            let unconfirmedUnvestedBalance = 0n;

            // Direct balance from Fulcrum for verification
            let fulcrumDirectBalance = 0n;

            // Server-side vesting: true when connected Fulcrum provides vesting fields
            let serverProvidesVesting = false;
            let balanceRetryCount = 0;
            const MAX_BALANCE_RETRIES = 10;
            const BALANCE_RETRY_INTERVAL = 2000;

            // HTML elements
            // const masterKeyElement = document.getElementById('masterKey'); // Removed with Security section
            const addressList = document.getElementById('addressList');
            const passwordStrength = document.getElementById('passwordStrength');
            // const encryptionStatus = document.getElementById('encryptionStatus'); // Removed with Security section
            const walletInfo = document.getElementById('walletInfo');
            const walletAddress = document.getElementById('walletAddress');
            const walletAddressLink = document.getElementById('walletAddressLink');
            const walletBalance = document.getElementById('walletBalance');
            const walletUnconfirmed = document.getElementById('walletUnconfirmed');
            const lastUpdateTime = document.getElementById('lastUpdateTime');
            const walletQrCode = document.getElementById('walletQrCode');
            
            // Watch-only elements
            const watchOnlySection = document.getElementById('watchOnlySection');
            const watchOnlyAddress = document.getElementById('watchOnlyAddress');
            const watchOnlyBalance = document.getElementById('watchOnlyBalance');
            const watchOnlyUnconfirmed = document.getElementById('watchOnlyUnconfirmed');
            const sendTransactionBtn = document.getElementById('sendTransactionBtn');
            
            // Watch-only state
            let watchOnlyMode = false;
            let watchOnlyAddressValue = null;
            
            // Buttons
            const initializeWalletBtn = document.getElementById('initializeWalletBtn');
            const generateAddressBtn = document.getElementById('generateAddressBtn');
            // const toggleMasterKeyBtn = document.getElementById('toggleMasterKeyBtn'); // Removed with Security section
            const deleteWalletBtn = document.getElementById('deleteWalletBtn');
            const saveWalletBtn = document.getElementById('saveWalletBtn');
            const restoreWalletBtn = document.getElementById('restoreWalletBtn');
            const importUtxoBtn = document.getElementById('importUtxoBtn');
            const clearUtxoBtn = document.getElementById('clearUtxoBtn');
            
            // Password Modal Elements
            const passwordModal = document.getElementById('passwordModal');
            const passwordModalTitle = document.getElementById('passwordModalTitle');
            const passwordModalMessage = document.getElementById('passwordModalMessage');
            const passwordModalInput = document.getElementById('passwordModalInput');
            const passwordModalCancelBtn = document.getElementById('passwordModalCancelBtn');
            const passwordModalSubmitBtn = document.getElementById('passwordModalSubmitBtn');
            
            // Password Modal Promise Resolution
            let resolvePasswordPromise = null;

            // Wallet data
            let wallet = {
                masterPrivateKey: '',
                addresses: [],
                isEncrypted: false,
                encryptedMasterKey: ''
            };
            
            // Make wallet globally accessible for save modal
            window.walletGlobal = wallet;
            
            // Transaction debugging system - make these global for debug modal
            window.transactionDebugLog = [];
            window.currentTransactionDebug = null;
            const MAX_DEBUG_LOGS = 100;

            console.log('[DEBUG] ========================================');
            console.log('[DEBUG] Debug system initialized at page load');
            console.log('[DEBUG] Initial transactionDebugLog:', window.transactionDebugLog);
            console.log('[DEBUG] ========================================');
            
            // Ensure encryption status is hidden by default
            // encryptionStatus.style.display = 'none'; // Removed with Security section
            
            // Helper function to update enabled/disabled state of buttons based on wallet state
            function updateButtonStates(walletExists) {
                saveWalletBtn.disabled = !walletExists;
                deleteWalletBtn.disabled = !walletExists;
                initializeWalletBtn.disabled = walletExists;
                restoreWalletBtn.disabled = walletExists;
                
                // Update button tooltips
                if (walletExists) {
                    initializeWalletBtn.title = "Wallet already created";
                    saveWalletBtn.title = "Save wallet to file with optional encryption";
                } else {
                    initializeWalletBtn.title = "Creates a new wallet with a secure private key. This is the first step to use this wallet.";
                    saveWalletBtn.title = "Create a wallet first";
                }
            }
            
            // Password modal functions
            function showPasswordModal(title, message) {
                return new Promise((resolve, reject) => {
                    // Set the title and message
                    passwordModalTitle.textContent = title || "Enter Password";
                    passwordModalMessage.textContent = message || "Please enter your wallet password:";
                    
                    // Clear any previous password
                    passwordModalInput.value = "";
                    
                    // Store the resolve function
                    resolvePasswordPromise = resolve;
                    
                    // Show the modal
                    passwordModal.style.display = "flex";
                    document.body.style.overflow = "hidden"; // Prevent scrolling
                    
                    // Focus the input field
                    passwordModalInput.focus();
                });
            }
            
            function closePasswordModal(success) {
                // Hide the modal
                passwordModal.style.display = "none";
                document.body.style.overflow = ""; // Restore scrolling
                
                // Resolve the promise with success/failure
                if (resolvePasswordPromise) {
                    if (success) {
                        resolvePasswordPromise(passwordModalInput.value);
                    } else {
                        resolvePasswordPromise(null);
                    }
                    resolvePasswordPromise = null;
                }
            }
            
            // Set up password modal event listeners
            passwordModalCancelBtn.addEventListener('click', () => closePasswordModal(false));
            passwordModalSubmitBtn.addEventListener('click', () => closePasswordModal(true));
            
            // Handle Enter key in password modal
            passwordModalInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    closePasswordModal(true);
                }
            });
            
            // Load wallet data from localStorage with multi-wallet support
            function loadWalletData() {
                // Start with buttons disabled by default
                updateButtonStates(false);
                
                // Get all stored wallets
                const storedWallets = getAllStoredWallets();
                
                if (storedWallets.length === 0) {
                    // No wallets found
                    console.log('No wallets found in storage');
                    return;
                }
                
                if (storedWallets.length === 1) {
                    // Single wallet - load it directly
                    loadWalletByKey(storedWallets[0].key);
                } else {
                    // Multiple wallets - check if there's a current wallet set
                    const currentWalletKey = localStorage.getItem('currentWalletKey');
                    if (currentWalletKey && storedWallets.find(w => w.key === currentWalletKey)) {
                        // Load the current wallet
                        loadWalletByKey(currentWalletKey);
                    } else {
                        // Show wallet selector
                        showWalletSelector(storedWallets, (selectedKey) => {
                            if (selectedKey === 'new') {
                                // User wants to create new wallet - do nothing, let them use the UI
                                console.log('User selected to create new wallet');
                            } else if (selectedKey) {
                                loadWalletByKey(selectedKey);
                            }
                        });
                    }
                }
            }
            
            // Load wallet by storage key
            function loadWalletByKey(storageKey) {
                try {
                    const walletData = localStorage.getItem(storageKey);
                    if (walletData) {
                        const parsedWallet = JSON.parse(walletData);
                        wallet = parsedWallet;
                        // Update global reference
                        window.walletGlobal = wallet;
                        // Set as current wallet
                        localStorage.setItem('currentWalletKey', storageKey);
                        updateUIFromWallet();
                        console.log(`Loaded wallet from key: ${storageKey}`);
                    }
                } catch (e) {
                    console.error('Error loading wallet:', e);
                    // Try IndexedDB as fallback
                    loadFromIndexedDB(storageKey);
                }
            }
            
            // Fallback to IndexedDB
            function loadFromIndexedDB(storageKey) {
                try {
                    const request = indexedDB.open("AlphaWalletDB", 1);
                    
                    request.onupgradeneeded = function(event) {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('wallet')) {
                            db.createObjectStore('wallet', { keyPath: 'id' });
                        }
                    };
                    
                    request.onerror = function(event) {
                        console.error("IndexedDB error:", event.target.error);
                        // Fall back to legacy localStorage
                        loadFromLocalStorage();
                    };
                    
                    request.onsuccess = function(event) {
                        const db = event.target.result;
                        const transaction = db.transaction(['wallet'], 'readonly');
                        const store = transaction.objectStore('wallet');
                        const getRequest = store.get(storageKey || 'main-wallet');
                        
                        getRequest.onsuccess = function(event) {
                            if (event.target.result) {
                                // Data found in IndexedDB
                                const savedWallet = event.target.result;
                                // Remove the ID property we added for IndexedDB
                                delete savedWallet.id;
                                wallet = savedWallet;
                                // Update global reference
                                window.walletGlobal = wallet;
                                updateUIFromWallet();
                            } else {
                                // No data in IndexedDB, try localStorage
                                loadFromLocalStorage();
                            }
                        };
                        
                        getRequest.onerror = function() {
                            // Error getting data from IndexedDB, fall back to localStorage
                            loadFromLocalStorage();
                        };
                    };
                } catch (e) {
                    console.error("Error accessing IndexedDB:", e);
                    // Fall back to localStorage
                    loadFromLocalStorage();
                }
                
                // Helper function to load from localStorage
                function loadFromLocalStorage() {
                    const savedWallet = localStorage.getItem('alphaWallet');
                    if (savedWallet) {
                        try {
                            const parsedWallet = JSON.parse(savedWallet);
                            wallet = parsedWallet;
                            // Update global reference
                            window.walletGlobal = wallet;
                            updateUIFromWallet();
                        } catch (e) {
                            console.error("Error parsing wallet data from localStorage", e);
                        }
                    }
                }
            }
            
            // Helper function to update UI based on wallet data
            function updateUIFromWallet() {
                    // Recover childPrivateKey if missing but address exists (fix for corrupted wallets)
                    if (!wallet.childPrivateKey && wallet.addresses && wallet.addresses.length > 0 && wallet.masterPrivateKey) {
                        console.log('Recovering missing childPrivateKey for loaded wallet...');
                        
                        // For standard wallets, recover the child key
                        if (!wallet.isImportedAlphaWallet || !wallet.masterChainCode) {
                            const addressIndex = wallet.addresses[0].index || 0;
                            const derivationPath = `m/44'/0'/${addressIndex}'`;
                            
                            // Derive child key using HMAC (standard wallet method)
                            const hmacInput = CryptoJS.enc.Hex.parse(wallet.masterPrivateKey);
                            const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                            const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                            const recoveredChildKey = hmacOutput.substring(0, 64);
                            
                            // Verify it matches the address
                            const ec = new elliptic.ec('secp256k1');
                            const keyPair = ec.keyFromPrivate(recoveredChildKey);
                            const publicKey = keyPair.getPublic(true, 'hex');
                            const sha256Hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey));
                            const ripemd160Hash = CryptoJS.RIPEMD160(sha256Hash);
                            const programData = ripemd160Hash.toString();
                            const witnessVersion = 0;
                            const derivedAddress = createBech32('alpha', witnessVersion, hexToBytes(programData));
                            
                            if (derivedAddress === wallet.addresses[0].address) {
                                console.log(' Successfully recovered childPrivateKey for address:', wallet.addresses[0].address);
                                wallet.childPrivateKey = recoveredChildKey;
                                // Save the fixed wallet
                                saveWalletData();
                            } else {
                                console.error(' Address mismatch during recovery!');
                                console.error('Expected:', wallet.addresses[0].address);
                                console.error('Derived:', derivedAddress);
                                
                                // Try scanning for correct index
                                for (let i = 0; i < 100; i++) {
                                    const testPath = `m/44'/0'/${i}'`;
                                    const testHmac = CryptoJS.HmacSHA512(hmacInput, CryptoJS.enc.Utf8.parse(testPath)).toString();
                                    const testChildKey = testHmac.substring(0, 64);
                                    const testKeyPair = ec.keyFromPrivate(testChildKey);
                                    const testPublicKey = testKeyPair.getPublic(true, 'hex');
                                    const testSha256 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(testPublicKey));
                                    const testRipemd = CryptoJS.RIPEMD160(testSha256);
                                    const testAddress = createBech32('alpha', witnessVersion, hexToBytes(testRipemd.toString()));
                                    
                                    if (testAddress === wallet.addresses[0].address) {
                                        console.log(` Found correct key at index ${i}!`);
                                        wallet.childPrivateKey = testChildKey;
                                        wallet.addresses[0].index = i;
                                        wallet.addresses[0].path = testPath;
                                        saveWalletData();
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Update UI if wallet exists
                    if (wallet.masterPrivateKey) {
                        // Update regular master key display
                        // masterKeyElement.textContent = wallet.masterPrivateKey; // Removed with Security section
                        // masterKeyElement.classList.add('masked'); // Removed with Security section
                        
                        // Generate the child key for the first address
                        let childPrivateKey;
                        let wifKey;
                        
                        if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                            // For BIP32 wallets, don't generate here - it's already in the address
                            if (wallet.addresses && wallet.addresses.length > 0 && wallet.childPrivateKey) {
                                childPrivateKey = wallet.childPrivateKey;
                                wifKey = hexToWIF(childPrivateKey);
                            } else {
                                // If no address yet, we'll generate one later
                                wifKey = "Generate an address to see the key";
                            }
                        } else {
                            // For standard wallets, use HMAC derivation
                            const addressIndex = 0;
                            const derivationPath = `m/44'/0'/${addressIndex}'`;
                            const hmacInput = CryptoJS.enc.Hex.parse(wallet.masterPrivateKey);
                            const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                            const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                            childPrivateKey = hmacOutput.substring(0, 64);
                            wifKey = hexToWIF(childPrivateKey);
                        }
                        // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                        // wifKeyElement.textContent = wifKey; // Removed with Security section
                        // wifKeyElement.classList.add('masked'); // Removed with Security section
                        
                        // Enable buttons
                        updateButtonStates(true);
                        
                        // Render address (just the first one)
                        if (wallet.addresses && wallet.addresses.length > 0) {
                            addAddressToUI(wallet.addresses[0]);
                            
                            // Check if this wallet is part of scanned wallets and sync balance
                            if (lastScannedWalletData && lastScannedWalletData.wallets) {
                                const currentAddress = wallet.addresses[0].address;
                                const scannedWallet = lastScannedWalletData.wallets.find(w => w.address === currentAddress);
                                
                                if (scannedWallet) {
                                    
                                    // Update master keys if not already set
                                    if (!lastScannedWalletData.masterKey && wallet.masterPrivateKey) {
                                        lastScannedWalletData.masterKey = wallet.masterPrivateKey;
                                        lastScannedWalletData.masterChainCode = wallet.masterChainCode;
                                        lastScannedWalletData.isAlphaWallet = wallet.isImportedAlphaWallet;
                                        
                                        // Save updated data with master keys
                                        const fingerprint = generateWalletFingerprint(
                                            lastScannedWalletData.masterKey,
                                            lastScannedWalletData.masterChainCode
                                        );
                                        if (fingerprint) {
                                            saveScanResultsToCache(fingerprint, lastScannedWalletData);
                                        }
                                    }
                                }
                            }
                            
                            // Update balance display
                            updateCommonBalance();
                            
                            // If already connected to Fulcrum, refresh balance
                            if (electrumConnected) {
                                refreshBalance();
                                updateTransactionHistory();
                            }
                        }
                    } else {
                        // No wallet, disable buttons
                        updateButtonStates(false);
                    }
                    
                    // Check if wallet is encrypted and update UI
                    if (wallet.isEncrypted) {
                        // encryptionStatus.style.display = 'block'; // Removed with Security section
                        // Hide password strength indicator when wallet is encrypted
                        passwordStrength.innerHTML = '';
                    } else {
                        // encryptionStatus.style.display = 'none'; // Removed with Security section
                    }
            }

            // Initialize wallet with master key using secure randomness
            function initializeWallet() {
                // Add confirmation dialog if wallet is being re-created
                if (wallet.masterPrivateKey) {
                    const confirmReset = confirm("This will reset your wallet and generate a new private key. Any existing addresses will be lost. Are you sure you want to continue?");
                    if (!confirmReset) {
                        return;
                    }
                }
                
                // Use Web Crypto API for cryptographically secure random number generation
                const randomBytes = new Uint8Array(32); // 256 bits for the private key
                window.crypto.getRandomValues(randomBytes);
                
                // Convert random bytes to hex string
                const randomHex = Array.from(randomBytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                
                // Create key pair from the secure random bytes
                const ec = new elliptic.ec('secp256k1');
                const keyPair = ec.keyFromPrivate(randomHex);
                
                wallet.masterPrivateKey = randomHex;
                wallet.addresses = [];
                wallet.isEncrypted = false;
                wallet.encryptedMasterKey = '';
                wallet.childPrivateKey = null; // Will be set when generating first address
                
                // Update global reference
                window.walletGlobal = wallet;
                
                // masterKeyElement.textContent = wallet.masterPrivateKey; // Removed with Security section
                // masterKeyElement.classList.add('masked'); // Removed with Security section
                // toggleMasterKeyBtn.textContent = 'Show'; // Removed with Security section
                
                // We'll update the WIF key after generating an address
                // This placeholder will be replaced with the child key's WIF
                // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                // wifKeyElement.textContent = "Generate an address to see the key"; // Removed with Security section
                // wifKeyElement.classList.add('masked'); // Removed with Security section
                
                
                // Enable/disable buttons
                updateButtonStates(true);
                
                // Generate first address
                generateNewAddress();
                
                // Save wallet to local storage
                saveWalletData();
                
                // Close any open sections to maintain a clean UI
                // document.getElementById('keys-section').style.display = 'none'; // Removed with Security section
                
                // Make sure encryption status is hidden for new wallets
                // encryptionStatus.style.display = 'none'; // Removed with Security section
                
                
                // Reset section button text - Removed with Security section
                /*
                document.getElementById('showEncryptionBtn').innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    Encrypt`;
                    
                document.getElementById('showRestoreBtn').innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Restore Wallet`;
                */
                    
                /* // Removed with Security section
                document.getElementById('showAdvancedBtn').innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                    </svg>
                    Migrate Wallet`;
                */
            }
            
            // BIP32 key derivation for imported wallets
            function deriveKeyBIP32(parentKey, parentChainCode, index, hardened = false) {
                // Proper BIP32 child key derivation
                const secp256k1_n = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
                
                // Create data for HMAC
                let data;
                if (hardened) {
                    // Hardened: 0x00 || parentKey || index
                    data = new Uint8Array(37);
                    data[0] = 0x00;
                    const keyBytes = hexToBytes(parentKey);
                    data.set(keyBytes, 1);
                    // Set index as big-endian 32-bit integer with hardened bit
                    const indexBytes = new Uint8Array(4);
                    const hardenedIndex = index + 0x80000000;
                    indexBytes[0] = (hardenedIndex >> 24) & 0xff;
                    indexBytes[1] = (hardenedIndex >> 16) & 0xff;
                    indexBytes[2] = (hardenedIndex >> 8) & 0xff;
                    indexBytes[3] = hardenedIndex & 0xff;
                    data.set(indexBytes, 33);
                } else {
                    // Non-hardened: publicKey || index
                    const ec = new elliptic.ec('secp256k1');
                    const keyPair = ec.keyFromPrivate(parentKey);
                    const pubKey = keyPair.getPublic(true, 'hex');
                    const pubKeyBytes = hexToBytes(pubKey);
                    
                    data = new Uint8Array(37);
                    data.set(pubKeyBytes, 0);
                    // Set index as big-endian 32-bit integer
                    const indexBytes = new Uint8Array(4);
                    indexBytes[0] = (index >> 24) & 0xff;
                    indexBytes[1] = (index >> 16) & 0xff;
                    indexBytes[2] = (index >> 8) & 0xff;
                    indexBytes[3] = index & 0xff;
                    data.set(indexBytes, 33);
                }
                
                // HMAC-SHA512 with parent chain code
                const hmacKey = CryptoJS.enc.Hex.parse(parentChainCode);
                const hmacData = CryptoJS.enc.Hex.parse(bytesToHex(data));
                const I = CryptoJS.HmacSHA512(hmacData, hmacKey).toString();
                
                const IL = I.substring(0, 64);  // Left 32 bytes (256 bits)
                const IR = I.substring(64);      // Right 32 bytes (chain code)
                
                // Calculate child private key: (IL + parentKey) mod n
                const ILBigInt = BigInt('0x' + IL);
                const parentKeyBigInt = BigInt('0x' + parentKey);
                const childKeyBigInt = (ILBigInt + parentKeyBigInt) % secp256k1_n;
                
                // Convert back to hex string (padded to 64 chars)
                const childKey = childKeyBigInt.toString(16).padStart(64, '0');
                
                return {
                    key: childKey,
                    chainCode: IR
                };
            }
            
            // Derive HD wallet path
            function deriveHDPath(masterKey, masterChainCode, path) {
                // Parse path like "m/84'/1'/0'/0/0"
                const parts = path.split('/').slice(1); // Remove 'm'
                
                let currentKey = masterKey;
                let currentChainCode = masterChainCode;
                
                for (const part of parts) {
                    const hardened = part.endsWith("'");
                    const index = parseInt(hardened ? part.slice(0, -1) : part);
                    
                    const result = deriveKeyBIP32(currentKey, currentChainCode, index, hardened);
                    currentKey = result.key;
                    currentChainCode = result.chainCode;
                }
                
                return currentKey;
            }
            
            // Generate a new address from master key
            function generateNewAddress() {
                if (!wallet.masterPrivateKey) {
                    alert('Please create a wallet first');
                    return;
                }
                
                const addressIndex = wallet.addresses.length;
                const ec = new elliptic.ec('secp256k1');
                
                let childPrivateKey;
                let derivationPath;
                let publicKey;
                
                // Check if this is an imported Alpha wallet
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    // For imported BIP32 HD wallets, use proper BIP32 derivation
                    // Use the derivation path from the wallet if available, otherwise default
                    
                    // Derive the path step by step
                    let key = wallet.masterPrivateKey;
                    let chainCode = wallet.masterChainCode;
                    
                    // Check if we have a stored derivation path from the descriptor
                    let purpose = 84; // Default to BIP84 for native SegWit
                    let coinType = 1; // Default to testnet (1) for Alpha network
                    let account = 0;  // Default account
                    
                    // If wallet has descriptor info, use it
                    if (wallet.descriptorPath) {
                        // Parse path like "84'/0'/0'" or "44'/0'/0'"
                        const pathMatch = wallet.descriptorPath.match(/(\d+)'\/(\d+)'\/(\d+)'/);
                        if (pathMatch) {
                            purpose = parseInt(pathMatch[1]);
                            coinType = parseInt(pathMatch[2]);
                            account = parseInt(pathMatch[3]);
                        }
                    }

                    // m/purpose' (e.g., 84' for native SegWit, 44' for legacy)
                    let result = deriveKeyBIP32(key, chainCode, purpose, true);
                    key = result.key;
                    chainCode = result.chainCode;

                    // m/purpose'/coinType' (0 = mainnet, 1 = testnet)
                    result = deriveKeyBIP32(key, chainCode, coinType, true);
                    key = result.key;
                    chainCode = result.chainCode;

                    // m/purpose'/coinType'/account'
                    result = deriveKeyBIP32(key, chainCode, account, true);
                    key = result.key;
                    chainCode = result.chainCode;

                    // m/purpose'/coinType'/account'/0 - External chain
                    result = deriveKeyBIP32(key, chainCode, 0, false);
                    key = result.key;
                    chainCode = result.chainCode;

                    // m/purpose'/coinType'/account'/0/index - Address index
                    result = deriveKeyBIP32(key, chainCode, addressIndex, false);
                    childPrivateKey = result.key;
                    
                    derivationPath = `m/${purpose}'/${coinType}'/${account}'/0/${addressIndex}`;
                    
                    const keyPair = ec.keyFromPrivate(childPrivateKey);
                    publicKey = keyPair.getPublic(true, 'hex');
                } else {
                    // Original HMAC-based derivation for wallets created in this app
                    derivationPath = `m/44'/0'/${addressIndex}'`;
                    
                    // Improved HMAC-based derivation for better security
                    // Using HMAC-SHA512 for more secure key derivation
                    const hmacInput = CryptoJS.enc.Hex.parse(wallet.masterPrivateKey);
                    const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                    const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                    
                    // Use left 32 bytes for private key, right 32 bytes could be used for chain code in a full HD wallet
                    childPrivateKey = hmacOutput.substring(0, 64);
                    
                    // Generate key pair from the derived key
                    const keyPair = ec.keyFromPrivate(childPrivateKey);
                    publicKey = keyPair.getPublic(true, 'hex');
                }
                
                // Store the child private key for the first address (used for transactions)
                if (addressIndex === 0) {
                    wallet.childPrivateKey = childPrivateKey;
                }
                
                // Generate address according to BIP-173 SegWit standard
                const sha256Hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey));
                const ripemd160Hash = CryptoJS.RIPEMD160(sha256Hash);
                const programData = ripemd160Hash.toString();
                
                // According to BIP-173, for P2WPKH (witness version 0), the witness program must be exactly 20 bytes
                // For other witness versions (1-16), the program can be 2-40 bytes
                const witnessVersion = 0;
                
                // Create the standard compliant bech32 address
                const address = createBech32('alpha', witnessVersion, hexToBytes(programData));
                
                // Add to wallet with additional security metadata
                wallet.addresses.push({
                    index: addressIndex,
                    address: address,
                    publicKey: publicKey,
                    path: derivationPath,
                    createdAt: new Date().toISOString()
                });
                
                // Add to UI
                addAddressToUI(wallet.addresses[addressIndex]);
                
                // Save wallet to local storage
                saveWalletData();
                
                // Show notification
                if (addressIndex === 0) {
                    showInAppNotification('Wallet Created', 'Your new wallet has been created successfully', 'success');
                } else {
                    showInAppNotification('Address Generated', `New address generated at index ${addressIndex}`, 'success');
                }
                
                // If already connected to Fulcrum, refresh balance for new address
                if (electrumConnected) {
                    setTimeout(() => {
                        refreshBalance();
                        updateTransactionHistory();
                    }, 500); // Small delay to ensure UI is updated
                }
            }
            
            // Add address to UI
            function addAddressToUI(addressInfo) {
                console.log('addAddressToUI called with:', addressInfo);
                
                // Validate addressInfo
                if (!addressInfo || !addressInfo.address) {
                    console.error('Invalid addressInfo provided to addAddressToUI:', addressInfo);
                    return;
                }
                
                // Show wallet info section
                walletInfo.style.display = 'block';
                
                // Update address - show BIP32 indicator if it's a BIP32 wallet
                if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                    walletAddress.innerHTML = `${addressInfo.address} <span style="color: #06d6a0; font-size: 12px; font-weight: bold;">[BIP32]</span>`;
                    walletAddress.dataset.address = addressInfo.address; // Store plain address for copying
                } else {
                    walletAddress.textContent = addressInfo.address;
                    walletAddress.dataset.address = addressInfo.address;
                }
                walletAddressLink.href = `https://www.unicity.network/address/${addressInfo.address}`;
                
                // Generate QR code
                generateWalletQRCode(addressInfo.address);
                
                // Update balance display
                updateCommonBalance();
                
                // Update UTXO list display
                updateUtxoListDisplay();
                
                // If already connected to Fulcrum, refresh balance
                if (electrumConnected && !wallet.addresses.find(a => a && a.address && addressInfo && addressInfo.address && a.address.toLowerCase() === addressInfo.address.toLowerCase())) {
                    setTimeout(() => {
                        refreshBalance();
                        updateTransactionHistory();
                    }, 500);
                }
            }
            
            // Generate QR code for wallet address
            function generateWalletQRCode(address) {
                // Clear existing QR code
                walletQrCode.innerHTML = '';
                
                // Create QR code with smaller size
                new QRCode(walletQrCode, {
                    text: address,
                    width: 100,
                    height: 100,
                    colorDark: "#3a86ff",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.M
                });
                
                walletQrCode.style.display = 'block';
            }
            
            
            // Show QR code for an address
            function showQRCode(address) {
                const modal = document.getElementById('qrModal');
                const qrAddress = document.getElementById('qrAddress');
                const qrContainer = document.getElementById('qrContainer');
                
                // Display the address without spacing
                qrAddress.textContent = address;
                
                // Clear previous QR code
                qrContainer.innerHTML = '';
                
                // Generate QR code with improved styling
                const qrCode = new QRCode(qrContainer, {
                    text: address,
                    width: 320,
                    height: 320,
                    colorDark: "#3a86ff",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
                
                // Show modal with animation
                modal.style.display = 'flex';
                document.body.style.overflow = 'hidden'; // Prevent scrolling while modal is open
                
                // Add event listener to close modal when clicking outside
                modal.onclick = function(e) {
                    if (e.target === modal) {
                        document.getElementById('qrModal').style.display = 'none';
                        document.body.style.overflow = '';
                    }
                };
                
                // Add escape key listener
                document.onkeydown = function(e) {
                    if (e.key === 'Escape') {
                        document.getElementById('qrModal').style.display = 'none';
                        document.body.style.overflow = '';
                    }
                };
            }
            
            // Close QR modal
            function closeQRModal() {
                const modal = document.getElementById('qrModal');
                modal.style.display = 'none';
                document.body.style.overflow = ''; // Restore scrolling
            }
            
            // Toggle master key visibility
            /* // Removed with Security section
            async function toggleMasterKey() {
                if (masterKeyElement.classList.contains('masked')) {
                    // Check if wallet is encrypted
                    if (wallet.isEncrypted) {
                        // Ask for password with custom modal
                        const password = await showPasswordModal(
                            "Enter Password",
                            "Your wallet is encrypted. Please enter your password to view the private key:"
                        );
                        
                        if (!password) {
                            return; // User cancelled
                        }
                        
                        try {
                            // Generate key from password
                            const salt = "alpha_wallet_salt";
                            const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                            
                            // Try to decrypt the master key
                            const decryptedKey = CryptoJS.AES.decrypt(wallet.encryptedMasterKey, passwordKey).toString(CryptoJS.enc.Utf8);
                            
                            // If decryption failed, this will be an empty string
                            if (!decryptedKey) {
                                alert("Incorrect password. Access denied.");
                                return;
                            }
                            
                            // Check if the decrypted key matches our stored key
                            if (decryptedKey !== wallet.masterPrivateKey) {
                                alert("Incorrect password. Access denied.");
                                return;
                            }
                            
                            // Password verified, proceed with normal confirmation
                        } catch (e) {
                            console.error("Error decrypting private key:", e);
                            alert("Error verifying password. Access denied.");
                            return;
                        }
                    }
                    
                    // Show a confirmation dialog
                    const shouldShow = confirm("You are about to reveal your private key. Make sure no one is looking at your screen. Continue?");
                    
                    if (shouldShow) {
                        masterKeyElement.classList.remove('masked');
                        // toggleMasterKeyBtn.textContent = 'Hide'; // Removed with Security section
                        
                        // Auto-hide after 30 seconds for security
                        setTimeout(() => {
                            if (!masterKeyElement.classList.contains('masked')) {
                                masterKeyElement.classList.add('masked');
                                // toggleMasterKeyBtn.textContent = 'Show'; // Removed with Security section
                            }
                        }, 30000);
                    }
                } else {
                    masterKeyElement.classList.add('masked');
                    // toggleMasterKeyBtn.textContent = 'Show'; // Removed with Security section
                }
            }
            */ // End of removed toggleMasterKey function
            
            // Convert hex private key to WIF format for importprivkey compatibility
            function hexToWIF(hexPrivateKey) {
                // Version byte for mainnet private key
                const versionByte = "80";
                
                // Add version byte
                let extendedKey = versionByte + hexPrivateKey;
                
                // Add compression flag (optional - for compressed keys)
                const compressionFlag = "01";
                extendedKey = extendedKey + compressionFlag;
                
                // Calculate SHA-256 hash
                const firstSHA = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(extendedKey));
                
                // Calculate SHA-256 hash again
                const secondSHA = CryptoJS.SHA256(firstSHA);
                
                // Get checksum (first 4 bytes of double-SHA)
                const checksum = secondSHA.toString().substring(0, 8);
                
                // Append checksum to extended key
                const keyWithChecksum = extendedKey + checksum;
                
                // Convert to Base58
                // We need to convert hex to bytes first
                const bytes = [];
                for (let i = 0; i < keyWithChecksum.length; i += 2) {
                    bytes.push(parseInt(keyWithChecksum.substr(i, 2), 16));
                }
                
                // Base58 encoding
                const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                
                // Count leading zeros
                let zeros = 0;
                for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
                    zeros++;
                }
                
                // Convert to base58
                let val = BigInt(0);
                for (let i = 0; i < bytes.length; i++) {
                    val = val * BigInt(256) + BigInt(bytes[i]);
                }
                
                let result = '';
                while (val > 0) {
                    const remainder = Number(val % BigInt(58));
                    val = val / BigInt(58);
                    result = ALPHABET[remainder] + result;
                }
                
                // Add leading '1's for each leading zero byte
                for (let i = 0; i < zeros; i++) {
                    result = '1' + result;
                }
                
                return result;
            }
            
            // Make hexToWIF globally accessible
            window.hexToWIF = hexToWIF;

            // Download wallet info (replaced by saveWallet)
            /* function downloadWallet() {
                // Convert the master key to WIF format
                const masterKeyWIF = hexToWIF(wallet.masterPrivateKey);
                
                // Get addresses info
                const addressesText = wallet.addresses.map(a => 
                    `Address ${a.index + 1}: ${a.address} (Path: ${a.path})`
                ).join('\n');
                
                // Determine what to include based on encryption status
                let masterKeySection;
                
                if (wallet.isEncrypted) {
                    masterKeySection = 
`ENCRYPTED MASTER KEY (password protected):
${wallet.encryptedMasterKey}

ENCRYPTION STATUS: Encrypted with password
To use this key, you will need the password you set in the wallet.`;
                } else {
                    masterKeySection = 
`MASTER PRIVATE KEY (keep secret!):
${wallet.masterPrivateKey}

MASTER PRIVATE KEY IN WIF FORMAT (for importprivkey command):
${masterKeyWIF}

${wallet.isImportedAlphaWallet && wallet.masterChainCode ? `MASTER CHAIN CODE (for BIP32 HD wallet compatibility):
${wallet.masterChainCode}

WALLET TYPE: BIP32 hierarchical deterministic wallet` : 'WALLET TYPE: Standard wallet (HMAC-based)'}

ENCRYPTION STATUS: Not encrypted
This key is in plaintext and not protected. Anyone with this file can access your wallet.`;
                }
                
                const content = 
`UNICITY WALLET DETAILS
===========================

${masterKeySection}

YOUR ADDRESSES:
${addressesText}

Generated on: ${new Date().toLocaleString()}

WARNING: Keep your master private key safe and secure.
Anyone with your master private key can access all your funds.`;
                
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'alpha-wallet.txt';
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                showInAppNotification('Wallet Backed Up', 'Wallet backup file has been downloaded', 'success');
            } */
            
            // Check password strength
            function checkPasswordStrength(password) {
                let strength = 0;
                
                if (password.length >= 8) strength += 1;
                if (password.length >= 12) strength += 1;
                if (/[A-Z]/.test(password)) strength += 1;
                if (/[a-z]/.test(password)) strength += 1;
                if (/[0-9]/.test(password)) strength += 1;
                if (/[^A-Za-z0-9]/.test(password)) strength += 1;
                
                let strengthText = '';
                let color = '';
                let strengthBar = '';
                
                if (strength < 3) {
                    strengthText = 'Weak';
                    color = 'var(--danger-color)';
                    strengthBar = '<div style="width: 30%; background-color: var(--danger-color);"></div>';
                } else if (strength < 5) {
                    strengthText = 'Medium';
                    color = 'var(--accent-color)';
                    strengthBar = '<div style="width: 60%; background-color: var(--accent-color);"></div>';
                } else {
                    strengthText = 'Strong';
                    color = 'var(--success-color)';
                    strengthBar = '<div style="width: 100%; background-color: var(--success-color);"></div>';
                }
                
                // Visual password strength meter
                const meterHTML = `
                    <div style="margin-top: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="color: ${color}; font-weight: 600;">Password Strength: ${strengthText}</span>
                            <span style="font-size: 12px; color: #666;">${strength}/6 criteria met</span>
                        </div>
                        <div style="height: 6px; background-color: #e9e9e9; border-radius: 3px; overflow: hidden;">
                            ${strengthBar}
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #666;">
                            <span>Weak</span>
                            <span>Medium</span>
                            <span>Strong</span>
                        </div>
                    </div>
                `;
                
                passwordStrength.innerHTML = meterHTML;
            }
            
            // Encrypt wallet with password (replaced by saveWallet)
            /* function encryptWallet(password) {
                if (!password) {
                    alert('Please enter a password');
                    return;
                }
                
                if (!wallet.masterPrivateKey) {
                    alert('Please initialize a wallet first');
                    return;
                }
                
                try {
                    // Generate a key from the password
                    const salt = "alpha_wallet_salt"; // In a real app, use a random salt and store it
                    const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                    
                    // Encrypt the master private key
                    const encryptedKey = CryptoJS.AES.encrypt(wallet.masterPrivateKey, passwordKey).toString();
                    
                    // Update wallet object
                    wallet.encryptedMasterKey = encryptedKey;
                    wallet.isEncrypted = true;
                    
                    // Save to local storage
                    saveWalletData();
                    
                    // Update UI
                    // encryptionStatus.style.display = 'block'; // Removed with Security section
                    // Clear password strength indicator when wallet is encrypted
                    if (passwordStrength) {
                        passwordStrength.innerHTML = '';
                    }
                    
                    showInAppNotification('Wallet Encrypted', 'Your private key is now protected by your password', 'success');
                } catch (e) {
                    console.error("Error encrypting wallet", e);
                    showInAppNotification('Encryption Error', e.message, 'error');
                }
            } */
            
            // Reset wallet
            function deleteWallet() {
                if (!wallet.masterPrivateKey) {
                    alert('No wallet to reset');
                    return;
                }
                
                const confirmation = confirm('WARNING: You are about to reset your wallet. This will clear the current wallet from your browser. Make sure you have saved your wallet data before proceeding.\n\nAre you sure you want to reset your wallet?');
                
                if (confirmation) {
                    // Get the current wallet's storage key
                    const storageKey = getWalletStorageKey(wallet);
                    
                    // Clear wallet data
                    wallet = {
                        masterPrivateKey: '',
                        addresses: [],
                        isEncrypted: false,
                        encryptedMasterKey: '',
                        childPrivateKey: null
                    };
                    
                    // Update global reference
                    window.walletGlobal = wallet;
                    
                    // Remove from storage
                    if (storageKey) {
                        localStorage.removeItem(storageKey);
                        console.log(`Removed wallet with key: ${storageKey}`);
                    }
                    
                    // Clear current wallet key
                    localStorage.removeItem('currentWalletKey');
                    
                    // Clear UI for both key displays
                    // masterKeyElement.textContent = 'Generate a wallet to see your private key'; // Removed with Security section
                    // masterKeyElement.classList.add('masked'); // Removed with Security section
                    
                    // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                    // wifKeyElement.textContent = 'Generate a wallet to see your private key'; // Removed with Security section
                    // wifKeyElement.classList.add('masked'); // Removed with Security section
                    
                    // Hide wallet info and QR code
                    walletInfo.style.display = 'none';
                    walletQrCode.style.display = 'none';
                    
                    // Clear transaction history and UTXOs
                    currentTransactions = [];
                    currentUtxos = [];
                    offlineUtxoData = null;
                    // Clear vesting classification state
                    addressVestingCache.clear();
                    VestingClassifier.clearCache();
                    // Reset pagination
                    currentTransactionPage = 1;
                    currentUtxoPage = 1;
                    updateTransactionHistory();
                    updateCommonBalance();
                    updateVestingBalanceDisplay();
                    updateUtxoListDisplay();
                    document.getElementById('transactionHistoryContainer').style.display = 'none';
                    
                    // Reset button text for toggle buttons
                    // toggleMasterKeyBtn.textContent = 'Show'; // Removed with Security section
                    // toggleWifKeyBtn.textContent = 'Show'; // Removed with Security section
                    
                    // Update all button states
                    updateButtonStates(false);
                    
                    // Hide encryption status message
                    // encryptionStatus.style.display = 'none'; // Removed with Security section
                    
                    // Clear password strength indicator
                    passwordStrength.innerHTML = '';
                    
                    
                    // Close all open sections
                    // document.getElementById('keys-section').style.display = 'none'; // Removed with Security section
                    
                    // Reset toggle buttons text
                    // document.getElementById('showEncryptionBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                        </svg>
                        Encrypt Wallet`; */
                        
                    // document.getElementById('showRestoreBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        Restore Wallet`; */
                        
                    // document.getElementById('showAdvancedBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                        Migrate Wallet`; */
                    
                    try {
                        // Remove from IndexedDB
                        const request = indexedDB.open("AlphaWalletDB", 1);
                        
                        request.onsuccess = function(event) {
                            const db = event.target.result;
                            const transaction = db.transaction(['wallet'], 'readwrite');
                            const store = transaction.objectStore('wallet');
                            store.delete('main-wallet');
                        };
                        
                        // Also remove from localStorage as fallback
                        localStorage.removeItem('alphaWallet');
                    } catch (e) {
                        console.error("Error removing wallet data", e);
                        // Fallback to just localStorage
                        localStorage.removeItem('alphaWallet');
                    }
                    
                    // Clear cached scan data
                    if (lastScannedWalletData && lastScannedWalletData.masterKey) {
                        const fingerprint = generateWalletFingerprint(
                            lastScannedWalletData.masterKey,
                            lastScannedWalletData.masterChainCode
                        );
                        if (fingerprint) {
                            const cacheKey = `walletScanCache_${fingerprint}`;
                            localStorage.removeItem(cacheKey);
                        }
                    }
                    
                    // Clear scan data from memory
                    lastScannedWalletData = null;
                    updateScannedWalletsDisplay(); // This will hide the total balance display
                    
                    // Clear lazy scan interval if running
                    if (lazyScanInterval) {
                        clearInterval(lazyScanInterval);
                        lazyScanInterval = null;
                    }
                    
                    // Also hide loading indicator
                    document.getElementById('totalScannedLoading').style.display = 'none';
                    
                    showInAppNotification('Wallet Reset', 'Your wallet has been reset successfully', 'success');
                }
            }
            
            // Bech32 implementation for segwit addresses (following BIP-173 standard)
            function createBech32(hrp, witnessVersion, data) {
                // BIP-173 constraints:
                // 1. Witness version must be between 0 and 16
                if (witnessVersion < 0 || witnessVersion > 16) {
                    throw new Error('Invalid witness version');
                }
                
                // 2. For version 0, program length must be 20 or 32 bytes
                if (witnessVersion === 0 && data.length !== 20 && data.length !== 32) {
                    console.warn(`Warning: For witness version 0, program length should be 20 or 32 bytes, but got ${data.length} bytes`);
                }
                
                // 3. For version 1-16, program length must be 2-40 bytes
                if (witnessVersion > 0 && (data.length < 2 || data.length > 40)) {
                    throw new Error(`Invalid program length for witness version ${witnessVersion}`);
                }
                
                // 4. Convert 8-bit program data to 5-bit values according to BIP-173
                const data5bit = convertBits(Array.from(data), 8, 5, true);
                
                // 5. The final data to encode starts with the witness version
                const values = [witnessVersion].concat(data5bit);
                
                // 6. Calculate checksum according to BIP-173
                const checksum = bech32Checksum(hrp, values);
                const combined = values.concat(checksum);
                
                // 7. Encode as per BIP-173: hrp + '1' + data + checksum
                let result = hrp + '1';
                for (let i = 0; i < combined.length; i++) {
                    result += CHARSET.charAt(combined[i]);
                }
                
                return result;
            }
            
            // Convert between bit sizes
            function convertBits(data, fromBits, toBits, pad) {
                let acc = 0;
                let bits = 0;
                const ret = [];
                const maxv = (1 << toBits) - 1;
                
                for (let i = 0; i < data.length; i++) {
                    const value = data[i];
                    acc = (acc << fromBits) | value;
                    bits += fromBits;
                    
                    while (bits >= toBits) {
                        bits -= toBits;
                        ret.push((acc >> bits) & maxv);
                    }
                }
                
                if (pad && bits > 0) {
                    ret.push((acc << (toBits - bits)) & maxv);
                }
                
                return ret;
            }
            
            // Generate Bech32 checksum
            function bech32Checksum(hrp, data) {
                const values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
                const polymod = bech32Polymod(values) ^ 1;
                const result = [];
                for (let i = 0; i < 6; i++) {
                    result.push((polymod >> 5 * (5 - i)) & 31);
                }
                return result;
            }
            
            // Expand the HRP into values for checksum computation
            function hrpExpand(hrp) {
                const result = [];
                for (let i = 0; i < hrp.length; i++) {
                    result.push(hrp.charCodeAt(i) >> 5);
                }
                result.push(0);
                for (let i = 0; i < hrp.length; i++) {
                    result.push(hrp.charCodeAt(i) & 31);
                }
                return result;
            }
            
            // Bech32 checksum computation
            function bech32Polymod(values) {
                const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
                let chk = 1;
                for (let i = 0; i < values.length; i++) {
                    const top = chk >> 25;
                    chk = (chk & 0x1ffffff) << 5 ^ values[i];
                    for (let j = 0; j < 5; j++) {
                        if ((top >> j) & 1) {
                            chk ^= GENERATOR[j];
                        }
                    }
                }
                return chk;
            }
            
            // ============================================
            // BigInt Utility Library for Satoshi Math
            // ============================================
            const SatoshiMath = {
                SATOSHI_PER_ALPHA: 100000000n,
                DUST_THRESHOLD: 546n,
                FEE_PER_TX: 10000n,

                /**
                 * Parse ALPHA string to satoshis (BigInt)
                 * Example: "0.12345678" -> 12345678n
                 */
                alphaToSatoshis: function(alphaString) {
                    if (!alphaString || alphaString === '') return 0n;

                    // Remove whitespace and validate format
                    const cleaned = alphaString.trim();
                    const match = cleaned.match(/^(\d+)(?:\.(\d{0,8}))?$/);

                    if (!match) {
                        throw new Error('Invalid ALPHA amount format: ' + alphaString);
                    }

                    const wholePart = BigInt(match[1] || '0');
                    const fractionalPart = (match[2] || '').padEnd(8, '0');

                    return wholePart * this.SATOSHI_PER_ALPHA + BigInt(fractionalPart);
                },

                /**
                 * Convert satoshis (BigInt) to ALPHA string
                 * Example: 12345678n -> "0.12345678"
                 */
                satoshisToAlpha: function(satoshisBigInt, options = {}) {
                    const {
                        showSymbol = false,
                        minDecimals = 0,
                        maxDecimals = 8,
                        removeTrailingZeros = false
                    } = options;

                    const satoshis = BigInt(satoshisBigInt);

                    // Handle negative values
                    const isNegative = satoshis < 0n;
                    const absSatoshis = isNegative ? -satoshis : satoshis;

                    const str = absSatoshis.toString().padStart(9, '0');
                    let integerPart = str.slice(0, -8) || '0';
                    let decimalPart = str.slice(-8);

                    // Apply decimal constraints
                    if (removeTrailingZeros) {
                        decimalPart = decimalPart.replace(/0+$/, '');
                    }
                    if (decimalPart.length < minDecimals) {
                        decimalPart = decimalPart.padEnd(minDecimals, '0');
                    }
                    if (decimalPart.length > maxDecimals) {
                        decimalPart = decimalPart.slice(0, maxDecimals);
                    }

                    const sign = isNegative ? '-' : '';
                    const formatted = decimalPart
                        ? `${sign}${integerPart}.${decimalPart}`
                        : `${sign}${integerPart}`;

                    return showSymbol ? `${formatted} ALPHA` : formatted;
                },

                /**
                 * Safe conversion from Number to BigInt
                 */
                fromNumber: function(num) {
                    if (!Number.isInteger(num)) {
                        console.warn('Converting non-integer to BigInt:', num);
                        return BigInt(Math.floor(num));
                    }
                    return BigInt(num);
                },

                /**
                 * Safe conversion from BigInt to Number (for display only)
                 */
                toNumber: function(bigint) {
                    const num = Number(bigint);
                    if (bigint > Number.MAX_SAFE_INTEGER) {
                        console.warn('BigInt exceeds MAX_SAFE_INTEGER, precision may be lost');
                    }
                    return num;
                },

                /**
                 * Sum array of values (Numbers or BigInts)
                 */
                sum: function(values) {
                    return values.reduce((acc, val) => acc + BigInt(val), 0n);
                }
            };

            // Enable JSON serialization for BigInt
            if (!BigInt.prototype.toJSON) {
                BigInt.prototype.toJSON = function() {
                    return this.toString();
                };
            }

            /**
             * VestingClassifier - Traces UTXOs to their coinbase origin to determine vesting status
             * VESTED: Coins from coinbase transactions in blocks <= VESTING_THRESHOLD (280000)
             * UNVESTED: Coins from coinbase transactions in blocks > VESTING_THRESHOLD
             */
            window.VestingClassifier = {
                // In-memory cache: txid -> { blockHeight, isCoinbase, inputTxId }
                memoryCache: new Map(),

                // IndexedDB cache name
                DB_STORE_NAME: 'vestingCache',

                /**
                 * Trace a UTXO to its coinbase origin and determine vesting status
                 * @param {Object} utxo - The UTXO to classify
                 * @returns {Promise<{isVested: boolean, coinbaseHeight: number, error?: string}>}
                 */
                async classifyUtxo(utxo) {
                    try {
                        const result = await this.traceToOrigin(utxo.tx_hash);
                        if (result.error) {
                            return { isVested: null, coinbaseHeight: null, error: result.error };
                        }
                        return {
                            isVested: result.coinbaseHeight <= VESTING_THRESHOLD,
                            coinbaseHeight: result.coinbaseHeight
                        };
                    } catch (err) {
                        console.error('Error classifying UTXO:', err);
                        return { isVested: null, coinbaseHeight: null, error: err.message };
                    }
                },

                /**
                 * Trace a transaction to its coinbase origin
                 * Alpha blockchain has single-input transactions, making this a linear trace
                 * @param {string} txHash - Transaction hash to trace
                 * @returns {Promise<{coinbaseHeight: number, error?: string}>}
                 */
                async traceToOrigin(txHash) {
                    let currentTxHash = txHash;
                    let iterations = 0;
                    const MAX_ITERATIONS = 10000; // Safety limit

                    while (iterations < MAX_ITERATIONS) {
                        iterations++;

                        // Check memory cache first
                        const cached = this.memoryCache.get(currentTxHash);
                        if (cached) {
                            if (cached.isCoinbase) {
                                // Skip cache if blockHeight is null - needs re-fetch
                                if (cached.blockHeight !== null && cached.blockHeight !== undefined) {
                                    return { coinbaseHeight: cached.blockHeight };
                                }
                                // Fall through to re-fetch
                            } else {
                                // Follow the input chain
                                currentTxHash = cached.inputTxId;
                                continue;
                            }
                        }

                        // Check IndexedDB cache
                        const dbCached = await this.loadFromIndexedDB(currentTxHash);
                        if (dbCached) {
                            // Also store in memory cache
                            this.memoryCache.set(currentTxHash, dbCached);
                            if (dbCached.isCoinbase) {
                                // Skip cache if blockHeight is null - needs re-fetch
                                if (dbCached.blockHeight !== null && dbCached.blockHeight !== undefined) {
                                    return { coinbaseHeight: dbCached.blockHeight };
                                }
                                // Fall through to re-fetch
                            } else {
                                currentTxHash = dbCached.inputTxId;
                                continue;
                            }
                        }

                        // Fetch from Fulcrum
                        const txData = await this.fetchTransaction(currentTxHash);
                        if (txData.error) {
                            return { coinbaseHeight: null, error: txData.error };
                        }

                        // Determine if this is a coinbase transaction
                        const isCoinbase = this.isCoinbaseTransaction(txData);
                        // Calculate block height - need both confirmations and currentBlockHeight
                        let blockHeight = null;
                        if (txData.confirmations && currentBlockHeight !== null && currentBlockHeight !== undefined) {
                            blockHeight = currentBlockHeight - txData.confirmations + 1;
                        }

                        // Get input transaction ID (if not coinbase)
                        let inputTxId = null;
                        if (!isCoinbase && txData.vin && txData.vin.length > 0 && txData.vin[0].txid) {
                            inputTxId = txData.vin[0].txid;
                        }

                        // Cache the result
                        const cacheEntry = {
                            blockHeight: blockHeight,
                            isCoinbase: isCoinbase,
                            inputTxId: inputTxId
                        };
                        this.memoryCache.set(currentTxHash, cacheEntry);
                        await this.saveToIndexedDB(currentTxHash, cacheEntry);

                        if (isCoinbase) {
                            return { coinbaseHeight: blockHeight };
                        }

                        if (!inputTxId) {
                            return { coinbaseHeight: null, error: 'Could not find input transaction' };
                        }

                        currentTxHash = inputTxId;
                    }

                    return { coinbaseHeight: null, error: 'Max iterations exceeded - possible loop' };
                },

                /**
                 * Check if a transaction is a coinbase transaction
                 */
                isCoinbaseTransaction(txData) {
                    // Coinbase transactions have a single input with no txid (or special coinbase field)
                    if (txData.vin && txData.vin.length === 1) {
                        const vin = txData.vin[0];
                        // Check for coinbase field or missing txid
                        if (vin.coinbase || (!vin.txid && vin.coinbase !== undefined)) {
                            return true;
                        }
                        // Some formats use empty txid for coinbase
                        if (vin.txid === '0000000000000000000000000000000000000000000000000000000000000000') {
                            return true;
                        }
                    }
                    return false;
                },

                /**
                 * Fetch transaction data from Fulcrum
                 */
                async fetchTransaction(txHash) {
                    return new Promise((resolve) => {
                        // Note: electrumRequest callback signature is (result, error) - result first on success,
                        // or (null, error) on error
                        electrumRequest('blockchain.transaction.get', [txHash, true], (result, error) => {
                            if (error) {
                                const errorMsg = typeof error === 'object' ? (error.message || JSON.stringify(error)) : String(error);
                                resolve({ error: errorMsg || 'Failed to fetch transaction' });
                            } else if (result && typeof result === 'object' && result.txid) {
                                // Valid transaction data
                                resolve(result);
                            } else {
                                // Unexpected result format
                                resolve({ error: 'Invalid transaction data received' });
                            }
                        });
                    });
                },

                /**
                 * Classify multiple UTXOs with progress callback
                 * @param {Array} utxos - Array of UTXOs to classify
                 * @param {Function} progressCallback - Called with (current, total)
                 * @returns {Promise<{vested: Array, unvested: Array, errors: Array}>}
                 */
                async classifyUtxos(utxos, progressCallback) {
                    const vested = [];
                    const unvested = [];
                    const errors = [];

                    for (let i = 0; i < utxos.length; i++) {
                        const utxo = utxos[i];
                        const result = await this.classifyUtxo(utxo);

                        if (result.error) {
                            errors.push({ utxo, error: result.error });
                            // Default to unvested on error for safety
                            unvested.push({ ...utxo, vestingStatus: 'error', coinbaseHeight: null });
                        } else if (result.isVested) {
                            vested.push({ ...utxo, vestingStatus: 'vested', coinbaseHeight: result.coinbaseHeight });
                        } else {
                            unvested.push({ ...utxo, vestingStatus: 'unvested', coinbaseHeight: result.coinbaseHeight });
                        }

                        if (progressCallback) {
                            progressCallback(i + 1, utxos.length);
                        }

                        // Yield to UI every 5 UTXOs to prevent blocking
                        if (i % 5 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }

                    return { vested, unvested, errors };
                },

                /**
                 * Load cached entry from IndexedDB
                 */
                async loadFromIndexedDB(txHash) {
                    return new Promise((resolve) => {
                        try {
                            const request = indexedDB.open('AlphaWallet', 2);
                            request.onerror = () => resolve(null);
                            request.onsuccess = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains(this.DB_STORE_NAME)) {
                                    db.close();
                                    resolve(null);
                                    return;
                                }
                                const transaction = db.transaction([this.DB_STORE_NAME], 'readonly');
                                const store = transaction.objectStore(this.DB_STORE_NAME);
                                const getRequest = store.get(txHash);
                                getRequest.onsuccess = () => {
                                    db.close();
                                    resolve(getRequest.result || null);
                                };
                                getRequest.onerror = () => {
                                    db.close();
                                    resolve(null);
                                };
                            };
                        } catch (err) {
                            resolve(null);
                        }
                    });
                },

                /**
                 * Save entry to IndexedDB
                 */
                async saveToIndexedDB(txHash, entry) {
                    return new Promise((resolve) => {
                        try {
                            const request = indexedDB.open('AlphaWallet', 2);
                            request.onerror = () => resolve(false);
                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains(this.DB_STORE_NAME)) {
                                    db.createObjectStore(this.DB_STORE_NAME, { keyPath: 'txid' });
                                }
                            };
                            request.onsuccess = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains(this.DB_STORE_NAME)) {
                                    db.close();
                                    resolve(false);
                                    return;
                                }
                                const transaction = db.transaction([this.DB_STORE_NAME], 'readwrite');
                                const store = transaction.objectStore(this.DB_STORE_NAME);
                                store.put({ txid: txHash, ...entry, timestamp: Date.now() });
                                transaction.oncomplete = () => {
                                    db.close();
                                    resolve(true);
                                };
                                transaction.onerror = () => {
                                    db.close();
                                    resolve(false);
                                };
                            };
                        } catch (err) {
                            resolve(false);
                        }
                    });
                },

                /**
                 * Clear all caches
                 */
                clearCache() {
                    this.memoryCache.clear();
                },

                /**
                 * Clear IndexedDB vesting cache (for when cached data is stale)
                 */
                async clearIndexedDBCache() {
                    return new Promise((resolve) => {
                        try {
                            const request = indexedDB.open('AlphaWallet', 2);
                            request.onerror = () => resolve(false);
                            request.onsuccess = (event) => {
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains(this.DB_STORE_NAME)) {
                                    db.close();
                                    resolve(true);
                                    return;
                                }
                                const transaction = db.transaction([this.DB_STORE_NAME], 'readwrite');
                                const store = transaction.objectStore(this.DB_STORE_NAME);
                                const clearRequest = store.clear();
                                clearRequest.onsuccess = () => {
                                    db.close();
                                    console.log('Vesting IndexedDB cache cleared');
                                    resolve(true);
                                };
                                clearRequest.onerror = () => {
                                    db.close();
                                    resolve(false);
                                };
                            };
                        } catch (err) {
                            resolve(false);
                        }
                    });
                },

                /**
                 * Clear all caches (memory and IndexedDB)
                 */
                async clearAllCaches() {
                    this.memoryCache.clear();
                    await this.clearIndexedDBCache();
                }
            };

            // ===== TXO Classification IndexedDB Persistence =====

            /**
             * Initialize IndexedDB for TXO classification cache
             */
            async function initTxoCacheDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(TXO_CACHE_DB, 1);
                    request.onerror = () => {
                        console.warn('[TxoCache] Failed to open IndexedDB:', request.error);
                        resolve(); // Don't fail completely, just proceed without DB
                    };
                    request.onsuccess = () => {
                        txoCacheDB = request.result;
                        console.log('[TxoCache] IndexedDB initialized');
                        resolve();
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(TXO_CACHE_STORE)) {
                            db.createObjectStore(TXO_CACHE_STORE, { keyPath: 'key' });
                            console.log('[TxoCache] Created object store');
                        }
                    };
                });
            }

            /**
             * Load all cached TXO classifications from IndexedDB on startup
             */
            async function loadTxoCacheFromIndexedDB() {
                if (!txoCacheDB) {
                    await initTxoCacheDB();
                }
                if (!txoCacheDB) return; // DB not available

                return new Promise((resolve) => {
                    try {
                        const tx = txoCacheDB.transaction(TXO_CACHE_STORE, 'readonly');
                        const store = tx.objectStore(TXO_CACHE_STORE);
                        const request = store.getAll();

                        request.onsuccess = () => {
                            const entries = request.result || [];
                            for (const entry of entries) {
                                txoClassificationCache.set(entry.key, {
                                    coinbaseHeight: entry.coinbaseHeight,
                                    isVested: entry.isVested
                                });
                            }
                            console.log(`[TxoCache] Loaded ${entries.length} cached TXO classifications`);
                            resolve();
                        };
                        request.onerror = () => {
                            console.warn('[TxoCache] Failed to load from IndexedDB');
                            resolve();
                        };
                    } catch (err) {
                        console.warn('[TxoCache] Error loading from IndexedDB:', err);
                        resolve();
                    }
                });
            }

            /**
             * Persist a TXO classification to IndexedDB
             * @param {string} key - The TXO key (txhash:vout)
             * @param {Object} classification - {coinbaseHeight, isVested}
             */
            async function persistTxoToIndexedDB(key, classification) {
                if (!txoCacheDB) return;

                return new Promise((resolve) => {
                    try {
                        const tx = txoCacheDB.transaction(TXO_CACHE_STORE, 'readwrite');
                        const store = tx.objectStore(TXO_CACHE_STORE);
                        store.put({
                            key: key,
                            coinbaseHeight: classification.coinbaseHeight,
                            isVested: classification.isVested,
                            timestamp: Date.now()
                        });
                        tx.oncomplete = () => resolve(true);
                        tx.onerror = () => resolve(false); // Don't fail on persist errors
                    } catch (err) {
                        resolve(false);
                    }
                });
            }

            /**
             * Batch persist multiple TXO classifications to IndexedDB
             * @param {Array} entries - Array of {key, classification} objects
             */
            async function batchPersistTxosToIndexedDB(entries) {
                if (!txoCacheDB || entries.length === 0) return;

                return new Promise((resolve) => {
                    try {
                        const tx = txoCacheDB.transaction(TXO_CACHE_STORE, 'readwrite');
                        const store = tx.objectStore(TXO_CACHE_STORE);
                        const timestamp = Date.now();

                        for (const { key, classification } of entries) {
                            store.put({
                                key: key,
                                coinbaseHeight: classification.coinbaseHeight,
                                isVested: classification.isVested,
                                timestamp: timestamp
                            });
                        }
                        tx.oncomplete = () => resolve(true);
                        tx.onerror = () => resolve(false);
                    } catch (err) {
                        resolve(false);
                    }
                });
            }

            /**
             * Get stats about the TXO cache
             */
            function getTxoCacheStats() {
                return {
                    memoryCacheSize: txoClassificationCache.size,
                    dbInitialized: txoCacheDB !== null
                };
            }

            // ===== Queue-Based UTXO Classification System =====

            /**
             * Handle incoming UTXOs - check TXO cache, queue unknowns for classification
             * @param {Array} utxos - Array of UTXOs from Fulcrum
             * @param {string} forAddress - The address these UTXOs belong to
             */
            function processIncomingUtxos(utxos, forAddress) {
                // Reset running balances for this batch
                runningVestedBalance = 0n;
                runningUnvestedBalance = 0n;
                unconfirmedVestedBalance = 0n;
                unconfirmedUnvestedBalance = 0n;

                // Clear existing queue (new batch = fresh start)
                utxoProcessingQueue.length = 0;

                // Check if these UTXOs have server-provided vesting fields
                // Use strict boolean check  null/undefined means "not provided"
                const utxosHaveVestingField = utxos.length > 0 && utxos.some(u => typeof u.vested === 'boolean');

                // Auto-detect server vesting support from UTXO data
                if (!serverProvidesVesting && utxosHaveVestingField) {
                    serverProvidesVesting = true;
                    console.log('[ServerVesting] Detected server-side vesting support from UTXO data');
                }

                console.log(`[TxoQueue] Processing ${utxos.length} UTXOs for ${forAddress} (serverVesting=${serverProvidesVesting}, utxosHaveField=${utxosHaveVestingField})`);

                // Fetch Fulcrum direct balance for verification
                fetchFulcrumDirectBalance(forAddress);

                // Show spinner while processing
                const spinner = document.getElementById('balanceVerificationSpinner');
                if (spinner) spinner.style.display = 'inline';

                if (utxosHaveVestingField) {
                    // SERVER-SIDE VESTING: instant classification from Fulcrum data
                    try {
                        for (const utxo of utxos) {
                            const isVested = utxo.vested === true;
                            const isUnconfirmed = !utxo.height || utxo.height <= 0;
                            const classification = {
                                isVested: isVested,
                                coinbaseHeight: utxo.coinbase_height ?? null
                            };
                            // Populate in-memory cache
                            const utxoKey = `${utxo.tx_hash}:${utxo.tx_pos}`;
                            txoClassificationCache.set(utxoKey, classification);
                            const val = BigInt(utxo.value ?? 0);
                            if (isVested) {
                                runningVestedBalance += val;
                                if (isUnconfirmed) unconfirmedVestedBalance += val;
                            } else {
                                runningUnvestedBalance += val;
                                if (isUnconfirmed) unconfirmedUnvestedBalance += val;
                            }
                        }
                    } catch (e) {
                        console.error('[ServerVesting] Error classifying UTXOs:', e);
                    }
                    // Persist batch to IndexedDB
                    const entries = utxos.map(u => ({
                        key: `${u.tx_hash}:${u.tx_pos}`,
                        classification: { isVested: u.vested === true, coinbaseHeight: u.coinbase_height ?? null }
                    }));
                    batchPersistTxosToIndexedDB(entries);

                    updateVestingBalanceDisplayRealtime();
                    syncToAddressVestingCacheFromUtxos(utxos, forAddress);
                    // Refresh UTXO list to show vesting colors
                    updateUtxoListDisplay();
                    // Hide spinner immediately - no async work needed
                    if (spinner) spinner.style.display = 'none';
                    console.log(`[ServerVesting] Instant classification: ${utxos.length} UTXOs (vested: ${SatoshiMath.satoshisToAlpha(runningVestedBalance)}, unvested: ${SatoshiMath.satoshisToAlpha(runningUnvestedBalance)})`);
                    return;
                }

                // UTXOs lack vesting fields  fall through to legacy client-side tracing
                // (even if serverProvidesVesting is true, stale/cached UTXOs still need classification)
                for (const utxo of utxos) {
                    const utxoKey = `${utxo.tx_hash}:${utxo.tx_pos}`;
                    const isUnconfirmed = !utxo.height || utxo.height <= 0;

                    if (txoClassificationCache.has(utxoKey)) {
                        // CACHE HIT - Already classified, use immediately
                        const cached = txoClassificationCache.get(utxoKey);
                        if (cached.isVested) {
                            runningVestedBalance += BigInt(utxo.value);
                            if (isUnconfirmed) unconfirmedVestedBalance += BigInt(utxo.value);
                        } else {
                            runningUnvestedBalance += BigInt(utxo.value);
                            if (isUnconfirmed) unconfirmedUnvestedBalance += BigInt(utxo.value);
                        }
                    } else {
                        // CACHE MISS - Add to queue for async classification
                        utxoProcessingQueue.push({
                            ...utxo,
                            key: utxoKey
                        });
                    }
                }

                const cachedCount = utxos.length - utxoProcessingQueue.length;
                console.log(`[TxoQueue] ${cachedCount} from cache, ${utxoProcessingQueue.length} need classification`);

                // Update display with cached results immediately
                updateVestingBalanceDisplayRealtime();

                // Start continuous queue processing (no debounce needed!)
                startQueueProcessing();
            }

            /**
             * Start queue processing if not already running
             */
            function startQueueProcessing() {
                if (!isProcessingUtxoQueue && utxoProcessingQueue.length > 0) {
                    processClassificationQueue();
                }
            }

            /**
             * Process queued UTXOs one by one with real-time balance updates
             */
            async function processClassificationQueue() {
                if (isProcessingUtxoQueue) return;
                if (utxoProcessingQueue.length === 0) return;
                if (!electrumConnected) {
                    console.log('[TxoQueue] Not connected to Electrum, skipping classification');
                    return;
                }

                isProcessingUtxoQueue = true;

                // Show progress indicator
                const progressEl = document.getElementById('vestingClassificationProgress');
                const progressTextEl = document.getElementById('vestingProgressText');
                if (progressEl) progressEl.style.display = 'block';

                const totalToProcess = utxoProcessingQueue.length;
                let processed = 0;

                console.log(`[TxoQueue] Starting classification of ${totalToProcess} UTXOs`);

                while (utxoProcessingQueue.length > 0) {
                    const utxo = utxoProcessingQueue.shift();
                    processed++;

                    // Update progress indicator
                    if (progressTextEl) {
                        const remaining = utxoProcessingQueue.length;
                        progressTextEl.textContent = `${processed}/${totalToProcess} (${remaining} remaining)`;
                    }

                    const isUnconfirmed = !utxo.height || utxo.height <= 0;

                    // Skip if somehow already cached (could happen during processing)
                    if (txoClassificationCache.has(utxo.key)) {
                        const cached = txoClassificationCache.get(utxo.key);
                        if (cached.isVested) {
                            runningVestedBalance += BigInt(utxo.value);
                            if (isUnconfirmed) unconfirmedVestedBalance += BigInt(utxo.value);
                        } else {
                            runningUnvestedBalance += BigInt(utxo.value);
                            if (isUnconfirmed) unconfirmedUnvestedBalance += BigInt(utxo.value);
                        }
                        updateVestingBalanceDisplayRealtime();
                        continue;
                    }

                    // Classify the UTXO using enhanced tracer with short-circuit
                    try {
                        const result = await traceUtxoWithShortCircuit(utxo.tx_hash, utxo.tx_pos);

                        const classification = {
                            isVested: result.isVested ?? false,
                            coinbaseHeight: result.coinbaseHeight ?? null
                        };

                        // Cache permanently (TXOs never change classification)
                        txoClassificationCache.set(utxo.key, classification);

                        // Persist to IndexedDB (fire and forget)
                        persistTxoToIndexedDB(utxo.key, classification);

                        // Update running balance
                        if (classification.isVested) {
                            runningVestedBalance += BigInt(utxo.value);
                            if (isUnconfirmed) unconfirmedVestedBalance += BigInt(utxo.value);
                        } else {
                            runningUnvestedBalance += BigInt(utxo.value);
                            if (isUnconfirmed) unconfirmedUnvestedBalance += BigInt(utxo.value);
                        }

                        // REAL-TIME UI UPDATE - watch the numbers grow!
                        updateVestingBalanceDisplayRealtime();

                    } catch (err) {
                        console.error(`[TxoQueue] Error classifying ${utxo.key}:`, err);
                        // On error, default to unvested
                        const errorClassification = { isVested: false, coinbaseHeight: null };
                        txoClassificationCache.set(utxo.key, errorClassification);
                        runningUnvestedBalance += BigInt(utxo.value);
                        if (isUnconfirmed) unconfirmedUnvestedBalance += BigInt(utxo.value);
                        updateVestingBalanceDisplayRealtime();
                    }

                    // Yield to UI between UTXOs for smooth updates
                    await new Promise(r => setTimeout(r, 10));
                }

                // Hide progress indicator
                if (progressEl) progressEl.style.display = 'none';

                isProcessingUtxoQueue = false;
                console.log(`[TxoQueue] Classification complete`);

                // Sync running totals to per-address cache
                syncToAddressVestingCache();
            }

            /**
             * Trace UTXO to coinbase with short-circuit on cached TXOs
             * Caches ALL intermediate TXOs for future speedup
             * @param {string} txHash - Transaction hash
             * @param {number} vout - Output index
             * @returns {Promise<{isVested: boolean, coinbaseHeight: number|null}>}
             */
            async function traceUtxoWithShortCircuit(txHash, vout) {
                const txoKey = `${txHash}:${vout}`;

                // Check if this exact TXO is already cached
                if (txoClassificationCache.has(txoKey)) {
                    return txoClassificationCache.get(txoKey);
                }

                // Track the chain we traverse for backfill caching
                const traversedChain = [txoKey];

                let currentTxHash = txHash;
                let iterations = 0;
                const MAX_ITERATIONS = 10000;

                while (iterations < MAX_ITERATIONS) {
                    iterations++;

                    // Fetch transaction data
                    const txData = await VestingClassifier.fetchTransaction(currentTxHash);
                    if (txData.error) {
                        console.warn(`[TxoTrace] Error fetching tx ${currentTxHash}:`, txData.error);
                        return { isVested: false, coinbaseHeight: null };
                    }

                    // Check if this is a coinbase transaction
                    if (VestingClassifier.isCoinbaseTransaction(txData)) {
                        // Calculate block height
                        let blockHeight = null;
                        if (txData.confirmations && currentBlockHeight !== null && currentBlockHeight !== undefined) {
                            blockHeight = currentBlockHeight - txData.confirmations + 1;
                        }

                        const classification = {
                            coinbaseHeight: blockHeight,
                            isVested: blockHeight !== null && blockHeight <= VESTING_THRESHOLD
                        };

                        // Cache ALL traversed TXOs with the same classification
                        const entriesToPersist = [];
                        for (const key of traversedChain) {
                            txoClassificationCache.set(key, classification);
                            entriesToPersist.push({ key, classification });
                        }
                        // Batch persist to IndexedDB
                        batchPersistTxosToIndexedDB(entriesToPersist);

                        return classification;
                    }

                    // Get input transaction
                    if (!txData.vin || txData.vin.length === 0 || !txData.vin[0].txid) {
                        console.warn(`[TxoTrace] No input found for tx ${currentTxHash}`);
                        return { isVested: false, coinbaseHeight: null };
                    }

                    const inputTxid = txData.vin[0].txid;
                    const inputVout = txData.vin[0].vout ?? 0;
                    const inputKey = `${inputTxid}:${inputVout}`;

                    // SHORT-CIRCUIT: If input TXO is cached, we're done!
                    if (txoClassificationCache.has(inputKey)) {
                        const cached = txoClassificationCache.get(inputKey);

                        // Backfill ALL traversed TXOs with same classification
                        const entriesToPersist = [];
                        for (const key of traversedChain) {
                            txoClassificationCache.set(key, cached);
                            entriesToPersist.push({ key, classification: cached });
                        }
                        // Batch persist to IndexedDB
                        batchPersistTxosToIndexedDB(entriesToPersist);

                        return cached;
                    }

                    // Move to input and track it
                    traversedChain.push(inputKey);
                    currentTxHash = inputTxid;
                }

                console.warn(`[TxoTrace] Max iterations exceeded for tx ${txHash}`);
                return { isVested: false, coinbaseHeight: null };
            }

            /**
             * Update the vesting balance display with real-time running totals
             */
            function updateVestingBalanceDisplayRealtime() {
                const vestedEl = document.getElementById('vestedBalance');
                const unvestedEl = document.getElementById('unvestedBalance');
                const totalEl = document.getElementById('walletBalance');
                const vestedUnconfEl = document.getElementById('vestedUnconfirmed');
                const unvestedUnconfEl = document.getElementById('unvestedUnconfirmed');

                if (vestedEl) {
                    vestedEl.textContent = SatoshiMath.satoshisToAlpha(runningVestedBalance) + ' ALPHA';
                }
                if (unvestedEl) {
                    unvestedEl.textContent = SatoshiMath.satoshisToAlpha(runningUnvestedBalance) + ' ALPHA';
                }
                if (totalEl) {
                    // Use Fulcrum's direct balance as authoritative total
                    // Fall back to calculated sum if Fulcrum balance not yet fetched
                    const displayTotal = fulcrumDirectBalance > 0n ? fulcrumDirectBalance : (runningVestedBalance + runningUnvestedBalance);
                    totalEl.textContent = SatoshiMath.satoshisToAlpha(displayTotal) + ' ALPHA';
                }

                // Show unconfirmed vesting portions (matching total unconfirmed display style)
                if (vestedUnconfEl) {
                    if (unconfirmedVestedBalance > 0n) {
                        vestedUnconfEl.style.display = 'inline';
                        vestedUnconfEl.textContent = `(${SatoshiMath.satoshisToAlpha(unconfirmedVestedBalance)})`;
                    } else {
                        vestedUnconfEl.style.display = 'none';
                        vestedUnconfEl.textContent = '';
                    }
                }
                if (unvestedUnconfEl) {
                    if (unconfirmedUnvestedBalance > 0n) {
                        unvestedUnconfEl.style.display = 'inline';
                        unvestedUnconfEl.textContent = `(${SatoshiMath.satoshisToAlpha(unconfirmedUnvestedBalance)})`;
                    } else {
                        unvestedUnconfEl.style.display = 'none';
                        unvestedUnconfEl.textContent = '';
                    }
                }

                // Check balance verification after updating display
                checkBalanceVerification();
            }

            /**
             * Sync running totals to per-address vesting cache
             */
            function syncToAddressVestingCache() {
                const currentAddress = getCurrentVestingAddress();
                if (!currentAddress) return;

                const addressCache = getAddressVestingCache(currentAddress);
                if (addressCache) {
                    addressCache.vestingBalances.vested = runningVestedBalance;
                    addressCache.vestingBalances.unvested = runningUnvestedBalance;
                    // Use Fulcrum's direct balance as authoritative total
                    addressCache.vestingBalances.all = fulcrumDirectBalance > 0n ? fulcrumDirectBalance : (runningVestedBalance + runningUnvestedBalance);
                }
            }

            /**
             * Sync addressVestingCache from server-classified UTXOs (no tracing needed)
             * @param {Array} utxos - UTXOs with server-provided vested field
             * @param {string} address - The address these UTXOs belong to
             */
            function syncToAddressVestingCacheFromUtxos(utxos, address) {
                if (!address) return;
                const addressCache = getAddressVestingCache(address);
                if (!addressCache) return;
                const vested = [];
                const unvested = [];
                const all = [];

                for (const utxo of utxos) {
                    all.push(utxo);
                    if (utxo.vested === true) {
                        vested.push(utxo);
                    } else {
                        unvested.push(utxo);
                    }
                }

                addressCache.classifiedUtxos = { vested, unvested, all };
                addressCache.vestingBalances = {
                    vested: runningVestedBalance,
                    unvested: runningUnvestedBalance,
                    all: fulcrumDirectBalance > 0n ? fulcrumDirectBalance : (runningVestedBalance + runningUnvestedBalance)
                };

                // Update static display
                updateVestingBalanceDisplay();
            }

            /**
             * Clear classification queue (e.g., on wallet switch)
             */
            function clearClassificationQueue() {
                utxoProcessingQueue.length = 0;
                isProcessingUtxoQueue = false;  // Stop any ongoing processing
                runningVestedBalance = 0n;
                runningUnvestedBalance = 0n;
                unconfirmedVestedBalance = 0n;
                unconfirmedUnvestedBalance = 0n;
                // Note: Do NOT clear txoClassificationCache - it's permanent!
                console.log('[TxoQueue] Queue cleared');
            }

            /**
             * Get or initialize vesting cache for a specific address
             * @param {string} address - The address to get cache for
             * @returns {Object} { classifiedUtxos, vestingBalances }
             */
            function getAddressVestingCache(address) {
                if (!address) return null;
                if (!addressVestingCache.has(address)) {
                    addressVestingCache.set(address, {
                        classifiedUtxos: { vested: [], unvested: [], all: [] },
                        vestingBalances: { vested: 0n, unvested: 0n, all: 0n }
                    });
                }
                return addressVestingCache.get(address);
            }

            /**
             * Get the current address for vesting operations
             * @returns {string|null} Current wallet or watch-only address
             */
            function getCurrentVestingAddress() {
                if (watchOnlyMode && watchOnlyAddressValue) {
                    return watchOnlyAddressValue;
                } else if (wallet && wallet.addresses && wallet.addresses.length > 0) {
                    return wallet.addresses[0].address;
                }
                return null;
            }

            /**
             * Fetch balance directly from Fulcrum for verification
             * @param {string} address - The address to fetch balance for
             */
            function fetchFulcrumDirectBalance(address) {
                if (!electrumConnected) {
                    console.log('[BalanceVerify] Not connected to Fulcrum, skipping direct balance fetch');
                    return;
                }

                const scriptHash = addressToScriptHash(address);
                if (!scriptHash) {
                    console.error('[BalanceVerify] Failed to convert address to script hash');
                    return;
                }

                electrumRequest('blockchain.scripthash.get_balance', [scriptHash], (result, error) => {
                    if (error) {
                        console.error('[BalanceVerify] Error fetching Fulcrum balance:', error);
                        return;
                    }
                    if (result && result.confirmed != null) {
                        // Include unconfirmed so total matches listunspent (which includes mempool UTXOs)
                        try {
                            fulcrumDirectBalance = BigInt(result.confirmed) + BigInt(result.unconfirmed || 0);
                        } catch (e) {
                            console.error('[BalanceVerify] Invalid balance value from server:', result, e);
                            return;
                        }
                        console.log(`[BalanceVerify] Fulcrum direct balance: ${SatoshiMath.satoshisToAlpha(fulcrumDirectBalance)} ALPHA`);

                        // Note: serverProvidesVesting is set exclusively from UTXO data in
                        // processIncomingUtxos to avoid race conditions where get_balance
                        // arrives before listunspent with vesting fields.

                        checkBalanceVerification();
                    }
                });
            }

            /**
             * Check if counted balance matches Fulcrum balance
             */
            function checkBalanceVerification() {
                const countedBalance = runningVestedBalance + runningUnvestedBalance;
                const spinner = document.getElementById('balanceVerificationSpinner');

                // Skip verification until Fulcrum direct balance has been fetched.
                // Without this guard, the async fetchFulcrumDirectBalance hasn't returned yet
                // and fulcrumDirectBalance is 0n, causing a false "overshoot" retry cascade.
                if (fulcrumDirectBalance === 0n && countedBalance > 0n) {
                    console.log('[BalanceVerify] Waiting for Fulcrum direct balance fetch...');
                    return;
                }

                console.log(`[BalanceVerify] Counted: ${SatoshiMath.satoshisToAlpha(countedBalance)} ALPHA, Fulcrum: ${SatoshiMath.satoshisToAlpha(fulcrumDirectBalance)} ALPHA`);

                if (countedBalance === fulcrumDirectBalance) {
                    // Perfect match - hide spinner
                    if (spinner) spinner.style.display = 'none';
                    balanceRetryCount = 0;
                    console.log('[BalanceVerify] Balance verified - perfect match');
                } else if (countedBalance < fulcrumDirectBalance) {
                    // Still processing - show spinner
                    if (spinner) spinner.style.display = 'inline';
                    console.log('[BalanceVerify] Still processing UTXOs...');
                } else {
                    // Overshoot - trigger retry
                    console.warn('[BalanceVerify] Counted balance exceeds Fulcrum balance - triggering retry');
                    triggerBalanceRetry();
                }
            }

            /**
             * Retry fetching balance and UTXOs from Fulcrum
             */
            function triggerBalanceRetry() {
                if (balanceRetryCount >= MAX_BALANCE_RETRIES) {
                    showBalanceIntegrityWarning();
                    return;
                }

                balanceRetryCount++;
                console.log(`[BalanceVerify] Retry ${balanceRetryCount}/${MAX_BALANCE_RETRIES} - rescanning UTXOs`);

                setTimeout(() => {
                    const currentAddress = getCurrentVestingAddress();
                    if (currentAddress) {
                        // Re-fetch Fulcrum direct balance
                        fetchFulcrumDirectBalance(currentAddress);
                        // Force reclassification from current UTXOs (processIncomingUtxos
                        // resets running balances internally). This bypasses the
                        // hasUtxoArrayChanged guard which would otherwise skip reprocessing.
                        if (currentUtxos && currentUtxos.length > 0) {
                            processIncomingUtxos(currentUtxos, currentAddress);
                        }
                    }
                }, BALANCE_RETRY_INTERVAL);
            }

            /**
             * Show warning popup for balance integrity issue
             */
            function showBalanceIntegrityWarning() {
                const countedBalance = runningVestedBalance + runningUnvestedBalance;
                const spinner = document.getElementById('balanceVerificationSpinner');
                if (spinner) spinner.style.display = 'none';

                showInAppNotification(
                    'Balance Integrity Warning',
                    `Counted balance (${SatoshiMath.satoshisToAlpha(countedBalance)} ALPHA) ` +
                    `exceeds Fulcrum balance (${SatoshiMath.satoshisToAlpha(fulcrumDirectBalance)} ALPHA). ` +
                    `This may indicate a sync issue.`,
                    'warning'
                );
            }

            // Helper function to convert bytes to hex string
            function bytesToHex(bytes) {
                return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            }
            
            // Helper function to convert hex to byte array
            function hexToBytes(hex) {
                const bytes = [];
                for (let i = 0; i < hex.length; i += 2) {
                    bytes.push(parseInt(hex.substring(i, i + 2), 16));
                }
                return new Uint8Array(bytes);
            }
            
            // Base58 decode function for decoding extended keys
            function base58Decode(str) {
                const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                const ALPHABET_MAP = {};
                for (let i = 0; i < ALPHABET.length; i++) {
                    ALPHABET_MAP[ALPHABET[i]] = i;
                }
                
                // Count leading zeros (represented as '1' in base58)
                let zeros = 0;
                for (let i = 0; i < str.length && str[i] === '1'; i++) {
                    zeros++;
                }
                
                // Decode from base58 to number
                let num = BigInt(0);
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    if (!(char in ALPHABET_MAP)) {
                        throw new Error('Invalid base58 character: ' + char);
                    }
                    num = num * BigInt(58) + BigInt(ALPHABET_MAP[char]);
                }
                
                // Convert to bytes
                const bytes = [];
                while (num > 0) {
                    bytes.unshift(Number(num % BigInt(256)));
                    num = num / BigInt(256);
                }
                
                // Add leading zeros
                for (let i = 0; i < zeros; i++) {
                    bytes.unshift(0);
                }
                
                return new Uint8Array(bytes);
            }
            
            // Restore Modal Elements
            const restoreModal = document.getElementById('restoreModal');
            const restoreFileInput = document.getElementById('restoreFileInput');
            const restorePasswordInput = document.getElementById('restorePasswordInput');
            const restoreModalCancelBtn = document.getElementById('restoreModalCancelBtn');
            const restoreModalSubmitBtn = document.getElementById('restoreModalSubmitBtn');
            const restoreStatus = document.getElementById('restoreStatus');
            const scanWalletsBtn = document.getElementById('scanWalletsBtn');
            const walletScanOptions = document.getElementById('walletScanOptions');
            const walletScanResults = document.getElementById('walletScanResults');
            const scanCountInput = document.getElementById('scanCountInput');
            const scanOnlineCheckbox = document.getElementById('scanOnlineCheckbox');
            const foundWalletsList = document.getElementById('foundWalletsList');
            const scanProgress = document.getElementById('scanProgress');
            const scanStatus = document.getElementById('scanStatus');
            const scanCounter = document.getElementById('scanCounter');
            
            function showRestoreModal() {
                restoreModal.style.display = 'flex';
                document.body.style.overflow = 'hidden';
                restoreFileInput.value = '';
                restorePasswordInput.value = '';
                restoreStatus.style.display = 'none';
                walletScanOptions.style.display = 'none';
                walletScanResults.style.display = 'none';
                scanWalletsBtn.style.display = 'none';
                restoreModalSubmitBtn.style.display = 'inline-block';
            }
            
            function closeRestoreModal() {
                restoreModal.style.display = 'none';
                document.body.style.overflow = '';
            }
            
            
            // Helper function to read binary data
            function readBinaryFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(new Uint8Array(e.target.result));
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }
            
            // Helper function to find pattern in Uint8Array
            function findPattern(data, pattern, startIndex = 0) {
                for (let i = startIndex; i <= data.length - pattern.length; i++) {
                    let found = true;
                    for (let j = 0; j < pattern.length; j++) {
                        if (data[i + j] !== pattern[j]) {
                            found = false;
                            break;
                        }
                    }
                    if (found) return i;
                }
                return -1;
            }

            // Parse DER-encoded EC private key
            function parseDERPrivateKey(derData) {
                // DER structure for EC private key:
                // SEQUENCE {
                //   version INTEGER (1)
                //   privateKey OCTET STRING (32 bytes)
                //   parameters [0] (optional)
                //   publicKey [1] (optional)
                // }
                
                let offset = 0;
                
                // Check SEQUENCE tag (0x30)
                if (derData[offset] !== 0x30) return null;
                offset++;
                
                // Skip length
                if (derData[offset] & 0x80) {
                    const lengthBytes = derData[offset] & 0x7f;
                    offset += lengthBytes + 1;
                } else {
                    offset++;
                }
                
                // Check version (0x02 0x01 0x01)
                if (derData[offset] === 0x02 && derData[offset+1] === 0x01 && derData[offset+2] === 0x01) {
                    offset += 3;
                }
                
                // Find OCTET STRING (0x04) containing private key
                while (offset < derData.length - 33) {
                    if (derData[offset] === 0x04 && derData[offset+1] === 0x20) {
                        // Found 32-byte octet string
                        return derData.slice(offset + 2, offset + 34);
                    }
                    offset++;
                }
                
                return null;
            }

            // Enhanced SQLite parser for wallet.dat files
            async function restoreFromWalletDat(file) {
                try {
                    restoreStatus.className = 'info-box info';
                    restoreStatus.textContent = 'Reading BIP32 wallet.dat file...';
                    restoreStatus.style.display = 'block';
                    
                    const data = await readBinaryFile(file);
                    
                    // Check SQLite header
                    const header = new TextDecoder().decode(data.slice(0, 16));
                    if (!header.startsWith('SQLite format 3')) {
                        throw new Error('Invalid wallet.dat file - not an SQLite database');
                    }
                    
                    restoreStatus.textContent = 'Analyzing wallet structure...';
                    
                    // Look for different wallet record types
                    const walletInfo = {
                        descriptorKeys: [],
                        hdChain: null,
                        legacyKeys: [],
                        isDescriptorWallet: false
                    };
                    
                    // Pattern 1: Search for walletdescriptorkey records (modern descriptor wallets)
                    const descriptorKeyPattern = new TextEncoder().encode('walletdescriptorkey');
                    
                    let index = 0;
                    while ((index = findPattern(data, descriptorKeyPattern, index)) !== -1) {
                        walletInfo.isDescriptorWallet = true;
                        
                        // Search for DER-encoded private key directly after walletdescriptorkey
                        // Based on our analysis, the key can be up to 200 bytes after the pattern
                        let privKeyFound = false;
                        for (let checkPos = index + descriptorKeyPattern.length; 
                             checkPos < Math.min(index + descriptorKeyPattern.length + 200, data.length - 40); 
                             checkPos++) {
                            
                            // Look for DER sequence markers
                            // Pattern: d30201010420 (the pattern that actually works)
                            if (data[checkPos] === 0xd3 &&
                                data[checkPos + 1] === 0x02 &&
                                data[checkPos + 2] === 0x01 &&
                                data[checkPos + 3] === 0x01 &&
                                data[checkPos + 4] === 0x04 &&
                                data[checkPos + 5] === 0x20) {
                                
                                // Extract the 32-byte private key
                                const privKey = data.slice(checkPos + 6, checkPos + 38);
                                const privKeyHex = Array.from(privKey).map(b => b.toString(16).padStart(2, '0')).join('');
                                
                                if (isValidPrivateKey(privKeyHex)) {
                                    walletInfo.descriptorKeys.push(privKeyHex);
                                    privKeyFound = true;
                                    break;
                                }
                            }
                        }
                        
                        index++;
                    }
                    
                    // Pattern 2: Search for hdchain records (legacy HD wallets)
                    const hdChainPattern = new TextEncoder().encode('hdchain');
                    index = findPattern(data, hdChainPattern);
                    if (index !== -1) {
                        walletInfo.hdChain = true;
                    }
                    
                    // Check if wallet is encrypted before trying legacy extraction
                    const mkeyPattern = new TextEncoder().encode('mkey');
                    const hasMkey = findPattern(data, mkeyPattern, 0) !== -1;
                    
                    if (hasMkey && walletInfo.descriptorKeys.length === 0) {
                        // Wallet is encrypted and we haven't found any unencrypted descriptor keys
                        console.warn('Wallet appears to be encrypted - legacy key extraction may fail');
                    }
                    
                    // Pattern 3: Search for regular key records (legacy format)
                    // WARNING: This may find incorrect keys for encrypted wallets!
                    const keyPattern = new TextEncoder().encode('key');
                    index = 0;
                    while ((index = findPattern(data, keyPattern, index)) !== -1) {
                        // Extract private key using simple pattern search
                        const searchPattern = new Uint8Array([0x04, 0x20]); // DER encoding for 32-byte octet string
                        for (let i = index; i < Math.min(index + 200, data.length - 34); i++) {
                            if (data[i] === searchPattern[0] && data[i + 1] === searchPattern[1]) {
                                const privKey = data.slice(i + 2, i + 34);
                                const privKeyHex = Array.from(privKey).map(b => b.toString(16).padStart(2, '0')).join('');
                                
                                if (isValidPrivateKey(privKeyHex)) {
                                    walletInfo.legacyKeys.push(privKeyHex);
                                    break;
                                }
                            }
                        }
                        index++;
                    }
                    
                    // Look for wpkh descriptor to extract derivation path
                    let descriptorPath = null;
                    const wpkhPattern = new TextEncoder().encode('wpkh([');
                    let wpkhIndex = findPattern(data, wpkhPattern, 0);
                    if (wpkhIndex !== -1) {
                        // Read the descriptor (up to 200 bytes should be enough)
                        const descriptorArea = data.slice(wpkhIndex, Math.min(wpkhIndex + 200, data.length));
                        let descriptorStr = '';
                        
                        // Convert to string until we hit a non-printable character or closing parenthesis
                        for (let i = 0; i < descriptorArea.length; i++) {
                            const byte = descriptorArea[i];
                            if (byte >= 32 && byte <= 126) { // Printable ASCII
                                descriptorStr += String.fromCharCode(byte);
                                if (descriptorStr.includes('*))')) break; // End of descriptor
                            }
                        }
                        
                        console.log('Found descriptor:', descriptorStr);
                        
                        // Parse the descriptor path
                        // Format: wpkh([fingerprint/84'/0'/0']xpub.../0/*)
                        const pathMatch = descriptorStr.match(/\[[\da-f]+\/(\d+'\/\d+'\/\d+')\]/);
                        if (pathMatch) {
                            descriptorPath = pathMatch[1];
                            console.log('Extracted descriptor path:', descriptorPath);
                        }
                    }
                    
                    // Extract chain code from xpub for BIP32 wallets
                    let masterChainCode = null;
                    const xpubPattern = new TextEncoder().encode('xpub');
                    const base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                    let searchPos = 0;
                    let foundMasterChainCode = false;
                    
                    while (!foundMasterChainCode && searchPos < data.length) {
                        let xpubIndex = findPattern(data, xpubPattern, searchPos);
                        if (xpubIndex === -1) break;
                        
                        // Extract the full xpub
                        let xpubStr = 'xpub';
                        let pos = xpubIndex + 4;
                        
                        while (pos < data.length && xpubStr.length < 120) {
                            const char = String.fromCharCode(data[pos]);
                            if (base58Chars.includes(char)) {
                                xpubStr += char;
                                pos++;
                            } else {
                                break;
                            }
                        }
                        
                        if (xpubStr.length > 100) {
                            try {
                                // Decode the xpub to check depth and extract chain code
                                const decoded = base58Decode(xpubStr);
                                const depth = decoded[4];
                                
                                // We want the master key at depth 0
                                if (depth === 0) {
                                    // Chain code is at bytes 13-45 (32 bytes)
                                    const chainCodeBytes = decoded.slice(13, 45);
                                    masterChainCode = Array.from(chainCodeBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                                    console.log('Extracted master chain code from depth 0 xpub:', masterChainCode);
                                    foundMasterChainCode = true;
                                }
                            } catch (e) {
                                console.error('Failed to decode xpub:', e);
                            }
                        }
                        
                        searchPos = xpubIndex + 4;
                    }
                    
                    if (!masterChainCode) {
                        console.warn('Could not extract chain code from wallet.dat - BIP32 derivation will not work correctly');
                    }
                    
                    // Determine what we found
                    let masterKey = null;
                    let importType = '';
                    
                    if (walletInfo.isDescriptorWallet && walletInfo.descriptorKeys.length > 0) {
                        // Modern descriptor wallet
                        masterKey = walletInfo.descriptorKeys[0]; // Use first key found
                        importType = 'descriptor wallet';
                        restoreStatus.textContent = `Found ${walletInfo.descriptorKeys.length} key(s) in descriptor wallet...`;
                    } else if (walletInfo.legacyKeys.length > 0) {
                        // Legacy wallet with individual keys
                        masterKey = walletInfo.legacyKeys[0]; // Use first key found
                        importType = walletInfo.hdChain ? 'HD wallet' : 'legacy wallet';
                        restoreStatus.textContent = `Found ${walletInfo.legacyKeys.length} key(s) in ${importType}...`;
                    } else {
                        // Check if this is an encrypted wallet
                        if (hasMkey) {
                            // Encrypted wallet - password prompt already shown by file preview
                            // Just return here, the preview code will handle decryption
                            return;
                        } else {
                            throw new Error('No valid private keys found in wallet.dat file. The wallet might use an unsupported format.');
                        }
                    }
                    
                    // Confirmation before overwriting
                    if (wallet.masterPrivateKey) {
                        const confirmOverwrite = confirm(
                            `Found Alpha ${importType} with private key(s).\n\n` +
                            `This will overwrite your existing wallet. Are you sure you want to proceed?`
                        );
                        if (!confirmOverwrite) {
                            closeRestoreModal();
                            return;
                        }
                    }
                    
                    // Create wallet with the extracted key
                    wallet = {
                        masterPrivateKey: masterKey,
                        addresses: [],
                        isEncrypted: false,
                        encryptedMasterKey: null,
                        childPrivateKey: null,
                        isImportedAlphaWallet: true, // Mark as imported from Alpha wallet.dat
                        // For BIP32 HD wallets, we need the chain code
                        // This was extracted from the wallet.dat file above
                        masterChainCode: masterChainCode,
                        descriptorPath: descriptorPath // Store the descriptor path for correct derivation
                    };
                    
                    // Update global reference
                    window.walletGlobal = wallet;
                    
                    // Generate first address
                    generateNewAddress();
                    
                    // Save the wallet
                    saveWalletData();
                    
                    // Update UI - populate address list
                    if (wallet.addresses.length > 0) {
                        const addressList = document.getElementById('addressList');
                        if (addressList) {
                            addressList.innerHTML = ''; // Clear existing
                            wallet.addresses.forEach(addr => {
                                addAddressToUI(addr);
                            });
                        }
                    }
                    
                    // Update button states
                    updateButtonStates(true);
                    
                    restoreStatus.className = 'info-box success';
                    restoreStatus.innerHTML = `
                        <div>Wallet imported successfully from Alpha ${importType}!</div>
                        <div style="margin-top: 10px; font-size: 0.9em;">
                            <strong>Note:</strong> The imported master key has been recovered. 
                            The first address generated may differ from your original wallet's addresses 
                            due to derivation path differences. You can still use this wallet to manage funds.
                        </div>
                    `;
                    
                    // Close modal after 4 seconds (longer to read the note)
                    setTimeout(() => {
                        closeRestoreModal();
                    }, 4000);
                    
                } catch (error) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Error importing wallet.dat: ' + error.message;
                    restoreStatus.style.display = 'block';
                }
            }
            
            // Validate if a hex string is a valid secp256k1 private key
            function isValidPrivateKey(hex) {
                try {
                    const n = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
                    const key = BigInt('0x' + hex);
                    return key > 0n && key < n;
                } catch {
                    return false;
                }
            }

            // Helper function to read compact size from binary data
            function readCompactSize(buffer, offset) {
                const first = buffer[offset];
                if (first < 253) return { value: first, bytes: 1 };
                if (first === 253) {
                    const value = buffer[offset + 1] | (buffer[offset + 2] << 8);
                    return { value: value, bytes: 3 };
                }
                if (first === 254) {
                    const value = buffer[offset + 1] | (buffer[offset + 2] << 8) |
                                 (buffer[offset + 3] << 16) | (buffer[offset + 4] << 24);
                    return { value: value, bytes: 5 };
                }
                throw new Error('CompactSize too large');
            }

            // Decrypt master key from encrypted wallet
            function decryptMasterKey(mkeyValue, password) {
                // Parse CMasterKey structure
                let pos = 0;

                // vchCryptedKey (vector)
                const cryptedKeyLen = readCompactSize(mkeyValue, pos);
                pos += cryptedKeyLen.bytes;
                const vchCryptedKey = mkeyValue.slice(pos, pos + cryptedKeyLen.value);
                pos += cryptedKeyLen.value;

                // vchSalt (vector)
                const saltLen = readCompactSize(mkeyValue, pos);
                pos += saltLen.bytes;
                const vchSalt = mkeyValue.slice(pos, pos + saltLen.value);
                pos += saltLen.value;

                // nDerivationMethod (uint32)
                const nDerivationMethod = mkeyValue[pos] | (mkeyValue[pos + 1] << 8) |
                                         (mkeyValue[pos + 2] << 16) | (mkeyValue[pos + 3] << 24);
                pos += 4;

                // nDeriveIterations (uint32)
                const nDeriveIterations = mkeyValue[pos] | (mkeyValue[pos + 1] << 8) |
                                         (mkeyValue[pos + 2] << 16) | (mkeyValue[pos + 3] << 24);

                // Derive key and IV using SHA-512 (Bitcoin Core's method)
                const passwordBytes = CryptoJS.enc.Utf8.parse(password);
                const saltWords = CryptoJS.lib.WordArray.create(vchSalt);

                let hash = CryptoJS.SHA512(passwordBytes.concat(saltWords));
                for (let i = 0; i < nDeriveIterations - 1; i++) {
                    hash = CryptoJS.SHA512(hash);
                }

                const keyAndIv = CryptoJS.lib.WordArray.create(hash.words);
                const derivedKey = CryptoJS.lib.WordArray.create(keyAndIv.words.slice(0, 8)); // 32 bytes
                const derivedIv = CryptoJS.lib.WordArray.create(keyAndIv.words.slice(8, 12)); // 16 bytes

                // Decrypt master key
                const encryptedWords = CryptoJS.lib.WordArray.create(vchCryptedKey);
                const decrypted = CryptoJS.AES.decrypt(
                    { ciphertext: encryptedWords },
                    derivedKey,
                    { iv: derivedIv, padding: CryptoJS.pad.Pkcs7, mode: CryptoJS.mode.CBC }
                );

                return CryptoJS.enc.Hex.stringify(decrypted);
            }

            // Decrypt encrypted wallet and import
            async function decryptAndImportWallet() {
                console.log('=== decryptAndImportWallet() called ===');

                // Use the modal's password input field
                const restorePasswordInput = document.getElementById('restorePasswordInput');
                const password = restorePasswordInput ? restorePasswordInput.value : '';
                const restoreStatus = document.getElementById('restoreStatus');

                if (!password) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Please enter a password';
                    return;
                }

                try {
                    restoreStatus.className = 'info-box';
                    restoreStatus.textContent = 'Decrypting wallet...';

                    const data = window.encryptedWalletData;

                    // Step 1: Find and decrypt master key (mkey record)
                    // SQLite stores data as key-value pairs
                    // We need to find the pattern: 04 6D 6B 65 79 01 00 00 00 30 (compact_size) ...
                    // Which is: length(04) + "mkey" + index(01) + padding + value_length + value

                    const mkeyPattern = new TextEncoder().encode('mkey');
                    let mkeyIndex = findPattern(data, mkeyPattern, 0);

                    if (mkeyIndex === -1) {
                        throw new Error('Could not find mkey record');
                    }

                    // The mkey value comes after: 04 "mkey" 01 00000030 (example)
                    // Skip: length + "mkey" + index byte
                    let pos = mkeyIndex + 4; // After "mkey"
                    pos++; // Skip index byte

                    // Skip 3 zero bytes padding (SQLite format)
                    pos += 3;

                    // The value starts here. We need to extract the complete CMasterKey structure.
                    // The CMasterKey is 67 bytes total:
                    // - vchCryptedKey: 1 byte (compact size 0x30) + 48 bytes = 49 bytes
                    // - vchSalt: 1 byte (compact size 0x08) + 8 bytes = 9 bytes
                    // - nDerivationMethod: 4 bytes
                    // - nDeriveIterations: 4 bytes
                    // - 1 byte padding = 67 bytes total
                    //
                    // However, we should parse this dynamically by reading the structure
                    // Extract mkey value (100 bytes is safe, decryptMasterKey will parse it)
                    const mkeyValue = data.slice(pos, pos + 100);

                    // Decrypt master key
                    const masterKeyHex = decryptMasterKey(mkeyValue, password);

                    if (!masterKeyHex || masterKeyHex.length !== 64) {
                        throw new Error('Master key decryption failed - invalid key length');
                    }

                    // Step 2: Find wpkh descriptor with /0/* (receive addresses)
                    const descriptorPattern = new TextEncoder().encode('walletdescriptor');
                    let descriptorIndex = 0;
                    let descriptorId = null;
                    let xpubString = null;

                    while ((descriptorIndex = findPattern(data, descriptorPattern, descriptorIndex)) !== -1) {
                        // Read descriptor string
                        let scanPos = descriptorIndex + descriptorPattern.length;

                        // Skip descriptor ID (32 bytes) - it's between the prefix and the value
                        scanPos += 32;

                        // Read the descriptor value (starts with compact size)
                        const descLen = data[scanPos];
                        scanPos++;

                        const descBytes = data.slice(scanPos, scanPos + Math.min(descLen, 200));
                        let descStr = '';
                        for (let i = 0; i < descBytes.length && descBytes[i] >= 32 && descBytes[i] <= 126; i++) {
                            descStr += String.fromCharCode(descBytes[i]);
                        }

                        // Look for native SegWit receive descriptor: wpkh(...84h/1h/0h/0/*)
                        if (descStr.startsWith('wpkh(xpub') && descStr.includes('/0/*)')) {
                            // Extract xpub
                            const xpubMatch = descStr.match(/xpub[1-9A-HJ-NP-Za-km-z]{100,}/);
                            if (xpubMatch) {
                                xpubString = xpubMatch[0];

                                // Extract descriptor ID (32 bytes after "walletdescriptor" prefix)
                                const descIdStart = descriptorIndex + descriptorPattern.length;
                                descriptorId = data.slice(descIdStart, descIdStart + 32);
                                break;
                            }
                        }

                        descriptorIndex++;
                    }

                    if (!descriptorId || !xpubString) {
                        throw new Error('Could not find native SegWit receive descriptor');
                    }

                    // Step 3: Extract chain code from xpub
                    const xpubDecoded = base58Decode(xpubString);
                    const chainCode = Array.from(xpubDecoded.slice(13, 45)).map(b => b.toString(16).padStart(2, '0')).join('');

                    // Step 4: Find and decrypt the BIP32 master private key
                    // Search for walletdescriptorckey record with this descriptor ID
                    const ckeyPattern = new TextEncoder().encode('walletdescriptorckey');
                    let ckeyIndex = findPattern(data, ckeyPattern, 0);
                    let bip32MasterKey = null;

                    while (ckeyIndex !== -1 && !bip32MasterKey) {
                        // Check if this record matches our descriptor ID
                        const recordDescId = data.slice(ckeyIndex + ckeyPattern.length, ckeyIndex + ckeyPattern.length + 32);

                        if (Array.from(recordDescId).every((b, i) => b === descriptorId[i])) {
                            // Found the matching record - extract and decrypt the private key
                            // After descriptor ID, there's a compact size + public key
                            let pos = ckeyIndex + ckeyPattern.length + 32;
                            const pubkeyLen = data[pos];
                            pos++;
                            const pubkey = data.slice(pos, pos + pubkeyLen);

                            // Find the value field (encrypted key) - need to search for it in the SQLite record
                            // The value should be nearby, let's search forward
                            for (let searchPos = pos + pubkeyLen; searchPos < Math.min(pos + pubkeyLen + 100, data.length - 50); searchPos++) {
                                // Look for a compact size followed by encrypted data (typically 48 bytes)
                                const valueLen = data[searchPos];
                                if (valueLen >= 32 && valueLen <= 64) {
                                    const encryptedKey = data.slice(searchPos + 1, searchPos + 1 + valueLen);

                                    // Decrypt using master key with IV derived from pubkey hash
                                    const pubkeyHashWords = CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.lib.WordArray.create(pubkey)));
                                    const ivWords = CryptoJS.lib.WordArray.create(pubkeyHashWords.words.slice(0, 4));
                                    const masterKeyWords = CryptoJS.enc.Hex.parse(masterKeyHex);
                                    const encryptedWords = CryptoJS.lib.WordArray.create(encryptedKey);

                                    const decrypted = CryptoJS.AES.decrypt(
                                        { ciphertext: encryptedWords },
                                        masterKeyWords,
                                        { iv: ivWords, padding: CryptoJS.pad.Pkcs7, mode: CryptoJS.mode.CBC }
                                    );

                                    bip32MasterKey = CryptoJS.enc.Hex.stringify(decrypted);

                                    if (bip32MasterKey.length === 64) {
                                        break;
                                    }
                                }
                            }
                            break;
                        }

                        ckeyIndex = findPattern(data, ckeyPattern, ckeyIndex + 1);
                    }

                    if (!bip32MasterKey || bip32MasterKey.length !== 64) {
                        throw new Error('Could not decrypt BIP32 master private key');
                    }

                    // Step 5: Create wallet with decrypted BIP32 master key
                    wallet = {
                        masterPrivateKey: bip32MasterKey,
                        masterChainCode: chainCode,
                        addresses: [],
                        isEncrypted: false,
                        encryptedMasterKey: null,
                        childPrivateKey: null,
                        isImportedAlphaWallet: true,
                        descriptorPath: "84'/1'/0'" // BIP84 for Alpha network
                    };

                    window.walletGlobal = wallet;

                    // Generate first address
                    generateNewAddress();

                    // Save the wallet
                    saveWalletData();

                    // Update UI
                    updateButtonStates(true);

                    // Set up extracted wallet data for scanning
                    extractedWalletData = {
                        masterKey: bip32MasterKey,
                        masterChainCode: chainCode,
                        descriptorPath: "84'/1'/0'",
                        isAlphaWallet: true
                    };

                    // Update status to show decryption was successful
                    restoreStatus.className = 'info-box success';
                    restoreStatus.innerHTML = `
                        <div> Wallet decrypted successfully!</div>
                        <div style="margin-top: 10px; font-size: 0.9em;">
                            Starting automatic address scan...
                        </div>
                    `;

                    // Show scan options and start scanning (same as unencrypted BIP32 wallets)
                    const scanWalletsBtn = document.getElementById('scanWalletsBtn');
                    const walletScanOptions = document.getElementById('walletScanOptions');
                    const restoreModalSubmitBtn = document.getElementById('restoreModalSubmitBtn');

                    walletScanOptions.style.display = 'block';
                    restoreModalSubmitBtn.style.display = 'none';
                    scanWalletsBtn.style.display = 'inline-block';
                    scanWalletsBtn.textContent = 'Rescan Wallets';

                    // Start scanning directly (we already have extractedWalletData set up)
                    // Don't call startWalletScan() as it will try to extract the file again
                    setTimeout(() => {
                        performWalletScan(bip32MasterKey, chainCode, true);
                    }, 500);

                } catch (error) {
                    console.error('Decryption error:', error);
                    console.error('Error stack:', error.stack);
                    restoreStatus.className = 'info-box error';
                    restoreStatus.innerHTML = `
                        <div>Decryption failed: ${error.message}</div>
                        <div style="margin-top: 10px; font-size: 0.9em;">
                            Please check your password and try again.
                        </div>
                    `;
                }
            }

            // Derive address at specific index from master key
            function deriveAddressAtIndex(masterKey, masterChainCode, index, isAlphaWallet = true, isChange = false, descriptorPath = null) {
                const ec = new elliptic.ec('secp256k1');
                let childPrivateKey;
                let derivationPath;
                
                if (isAlphaWallet && masterChainCode) {
                    // BIP32 derivation for Alpha wallets
                    let key = masterKey;
                    let chainCode = masterChainCode;
                    
                    // Parse descriptor path if provided, otherwise use defaults
                    let purpose = 84; // Default to BIP84
                    let coinType = 1; // Default to testnet (1) for Alpha network
                    let account = 0;
                    
                    if (descriptorPath) {
                        // Parse path like "84'/0'/0'" or "84'/1'/0'"
                        const pathMatch = descriptorPath.match(/(\d+)'\/(\d+)'\/(\d+)'/);
                        if (pathMatch) {
                            purpose = parseInt(pathMatch[1]);
                            coinType = parseInt(pathMatch[2]);
                            account = parseInt(pathMatch[3]);
                            console.log(`Using descriptor path: m/${purpose}'/${coinType}'/${account}'/chain/index`);
                        }
                    }
                    
                    // m/purpose'/coinType'/account'/chain/index
                    // where chain = 0 for external (receiving), 1 for internal (change)
                    let result = deriveKeyBIP32(key, chainCode, purpose, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    result = deriveKeyBIP32(key, chainCode, coinType, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    result = deriveKeyBIP32(key, chainCode, account, true);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    result = deriveKeyBIP32(key, chainCode, isChange ? 1 : 0, false);
                    key = result.key;
                    chainCode = result.chainCode;
                    
                    result = deriveKeyBIP32(key, chainCode, index, false);
                    childPrivateKey = result.key;
                    derivationPath = `m/${purpose}'/${coinType}'/${account}'/${isChange ? 1 : 0}/${index}`;
                } else {
                    // HMAC-based derivation
                    derivationPath = `m/44'/0'/${index}'`;
                    const hmacInput = CryptoJS.enc.Hex.parse(masterKey);
                    const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                    const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                    childPrivateKey = hmacOutput.substring(0, 64);
                }
                
                const keyPair = ec.keyFromPrivate(childPrivateKey);
                const publicKey = keyPair.getPublic(true, 'hex');
                
                // Create SegWit address
                const publicKeyBytes = hexToBytes(publicKey);
                const sha256Hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey)).toString();
                const ripemd160Hash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hash)).toString();
                const address = createBech32('alpha', 0, hexToBytes(ripemd160Hash));
                
                return {
                    index: index,
                    address: address,
                    publicKey: publicKey,
                    privateKey: childPrivateKey,
                    path: derivationPath,
                    balance: 0,
                    utxos: []
                };
            }
            
            // Check balance for an address using Fulcrum
            async function checkAddressBalance(address) {
                if (!electrumConnected) {
                    return { balance: 0, utxoCount: 0 };
                }
                
                try {
                    const scriptHash = addressToScriptHash(address);
                    if (!scriptHash) {
                        console.error('Failed to convert address to script hash:', address);
                        return { balance: 0, utxoCount: 0 };
                    }
                    
                    // Use get_balance which is more efficient than listing all UTXOs
                    const response = await new Promise((resolve, reject) => {
                        electrumRequest('blockchain.scripthash.get_balance', [scriptHash], function(result, error) {
                            if (error) {
                                reject(error);
                            } else {
                                resolve(result);
                            }
                        });
                    });
                    
                    if (!response) {
                        return { balance: 0, utxoCount: 0 };
                    }
                    
                    // get_balance returns {confirmed: number, unconfirmed: number}
                    const confirmed = response.confirmed || 0;
                    const unconfirmed = response.unconfirmed || 0;
                    const totalBalance = confirmed + unconfirmed;
                    
                    
                    return { balance: totalBalance, utxoCount: -1 }; // -1 indicates we didn't fetch UTXO count
                } catch (error) {
                    console.error('Error checking address balance:', error);
                    return { balance: 0, utxoCount: 0 };
                }
            }
            
            // Global variables for scanning
            let scanningActive = false;
            let scannedWallets = [];
            let extractedWalletData = null;
            let lastScannedWalletData = null; // Store scan results persistently
            let lazyScanInterval = null;
            let lastLazyScanTime = 0;
            let currentScanProgress = 0; // Track current scan progress percentage
            let totalScansCount = 0; // Track total number of scans
            
            // Save scan results to local storage
            function saveScanResultsToCache(walletFingerprint, scanData) {
                try {
                    const cacheKey = `walletScanCache_${walletFingerprint}`;
                    const cacheData = {
                        timestamp: Date.now(),
                        wallets: scanData.wallets,
                        totalBalance: scanData.totalBalance,
                        scanCount: scanData.wallets.length
                    };
                    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                } catch (e) {
                    console.error('Failed to save scan results to cache:', e);
                }
            }
            
            // Load scan results from cache
            function loadScanResultsFromCache(walletFingerprint) {
                try {
                    const cacheKey = `walletScanCache_${walletFingerprint}`;
                    const cached = localStorage.getItem(cacheKey);
                    if (cached) {
                        const data = JSON.parse(cached);
                        // Check if cache is not too old (7 days)
                        if (Date.now() - data.timestamp < 7 * 24 * 60 * 60 * 1000) {
                            return data;
                        }
                    }
                } catch (e) {
                    console.error('Failed to load scan results from cache:', e);
                }
                return null;
            }
            
            // Generate fingerprint for wallet
            function generateWalletFingerprint(masterKey, masterChainCode) {
                if (!masterKey) {
                    return null;
                }
                // Use first 8 chars of master key as fingerprint
                return masterKey.substring(0, 8);
            }
            
            // Generate unique wallet storage key
            function getWalletStorageKey(walletData) {
                if (!walletData || !walletData.masterPrivateKey) return null;
                // Use SHA256 hash of master key to generate unique ID
                const fingerprint = CryptoJS.SHA256(walletData.masterPrivateKey).toString().substring(0, 16);
                return `alphaWallet_${fingerprint}`;
            }
            
            // Get all stored wallets
            function getAllStoredWallets() {
                const wallets = [];
                try {
                    // Check localStorage for all wallet keys
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('alphaWallet_')) {
                            try {
                                const walletData = JSON.parse(localStorage.getItem(key));
                                if (walletData) {
                                    // Derive wallet identifier (address or fingerprint)
                                    let identifier = 'Unknown Wallet';
                                    if (walletData.addresses && walletData.addresses.length > 0) {
                                        identifier = walletData.addresses[0].address;
                                    }
                                    wallets.push({
                                        key: key,
                                        identifier: identifier,
                                        isEncrypted: walletData.isEncrypted || false,
                                        isBIP32: walletData.isImportedAlphaWallet || false,
                                        createdAt: walletData.addresses?.[0]?.createdAt || 'Unknown'
                                    });
                                }
                            } catch (e) {
                                console.error('Error parsing wallet:', key, e);
                            }
                        }
                    }
                    
                    // Also check for legacy wallet
                    const legacyWallet = localStorage.getItem('alphaWallet');
                    if (legacyWallet) {
                        try {
                            const walletData = JSON.parse(legacyWallet);
                            if (walletData) {
                                let identifier = 'Legacy Wallet';
                                if (walletData.addresses && walletData.addresses.length > 0) {
                                    identifier = walletData.addresses[0].address;
                                }
                                wallets.push({
                                    key: 'alphaWallet',
                                    identifier: identifier,
                                    isEncrypted: walletData.isEncrypted || false,
                                    isBIP32: walletData.isImportedAlphaWallet || false,
                                    createdAt: walletData.addresses?.[0]?.createdAt || 'Unknown',
                                    isLegacy: true
                                });
                            }
                        } catch (e) {
                            console.error('Error parsing legacy wallet:', e);
                        }
                    }
                } catch (e) {
                    console.error('Error getting stored wallets:', e);
                }
                return wallets;
            }
            
            // Show wallet selector when multiple wallets exist
            function showWalletSelector(wallets, callback) {
                // Create modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 24px;
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                `;
                
                dialog.innerHTML = `
                    <h2 style="margin-top: 0; color: #333;">Select Wallet</h2>
                    <p style="color: #666; margin-bottom: 20px;">Multiple wallets detected. Please select which wallet to load:</p>
                    <div id="walletSelectorList"></div>
                    <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="walletSelectorCancel" style="padding: 8px 16px; background: #e0e0e0; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                        <button id="walletSelectorNew" style="padding: 8px 16px; background: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer;">Create New Wallet</button>
                    </div>
                `;
                
                modal.appendChild(dialog);
                document.body.appendChild(modal);
                
                const list = dialog.querySelector('#walletSelectorList');
                
                // Add wallet options
                wallets.forEach((walletInfo, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = `
                        padding: 12px;
                        margin-bottom: 10px;
                        border: 2px solid #e0e0e0;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                    `;
                    
                    item.innerHTML = `
                        <div style="font-family: monospace; font-size: 12px; color: #333; word-break: break-all;">
                            ${walletInfo.identifier}
                        </div>
                        <div style="margin-top: 5px; font-size: 11px; color: #999;">
                            ${walletInfo.isEncrypted ? ' Encrypted' : ' Unencrypted'} 
                            ${walletInfo.isBIP32 ? ' BIP32' : ' Standard'}
                            ${walletInfo.isLegacy ? ' Legacy' : ''}
                             Created: ${walletInfo.createdAt !== 'Unknown' ? new Date(walletInfo.createdAt).toLocaleDateString() : 'Unknown'}
                        </div>
                    `;
                    
                    item.onmouseover = () => {
                        item.style.borderColor = 'var(--primary-color)';
                        item.style.background = '#f0f9ff';
                    };
                    
                    item.onmouseout = () => {
                        item.style.borderColor = '#e0e0e0';
                        item.style.background = 'white';
                    };
                    
                    item.onclick = () => {
                        document.body.removeChild(modal);
                        callback(walletInfo.key);
                    };
                    
                    list.appendChild(item);
                });
                
                // Handle cancel
                dialog.querySelector('#walletSelectorCancel').onclick = () => {
                    document.body.removeChild(modal);
                    callback(null);
                };
                
                // Handle create new
                dialog.querySelector('#walletSelectorNew').onclick = () => {
                    document.body.removeChild(modal);
                    callback('new');
                };
            }
            
            // Start wallet scan with decrypted data
            async function startWalletScanWithDecryptedData(walletData) {
                try {
                    const masterKey = walletData.masterPrivateKey;
                    const masterChainCode = walletData.masterChainCode || null;
                    const isAlphaWallet = walletData.isImportedAlphaWallet || false;
                    
                    if (!masterKey) {
                        throw new Error('No master key found in decrypted wallet data');
                    }
                    
                    // Continue with normal scanning
                    performWalletScan(masterKey, masterChainCode, isAlphaWallet);
                } catch (error) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Error: ' + error.message;
                    restoreStatus.style.display = 'block';
                }
            }
            
            // Start wallet scanning or decrypt
            async function startWalletScan() {
                const file = restoreFileInput.files[0];
                if (!file) {
                    alert('Please select a file first');
                    return;
                }
                
                // Check if this is a rescan - clear cache if so
                if (scanWalletsBtn.textContent === 'Rescan Wallets') {
                    // Clear all cached scan results from localStorage
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && (key.startsWith('walletScan_') || key === 'lastScannedWalletData' || key === 'lastLazyScanTime')) {
                            keysToRemove.push(key);
                        }
                    }
                    
                    // Remove all scan-related keys
                    keysToRemove.forEach(key => {
                        localStorage.removeItem(key);
                        console.log('Cleared cached data:', key);
                    });
                    
                    // Clear in-memory data
                    lastScannedWalletData = null;
                    scannedWallets = [];
                    
                    // Update UI to show we're doing a fresh scan
                    restoreStatus.className = 'info-box info';
                    restoreStatus.textContent = 'Cache cleared. Starting fresh wallet scan...';
                    restoreStatus.style.display = 'block';
                }
                
                // Check if we're in decrypt mode
                if (scanWalletsBtn.textContent === 'Decrypt') {
                    // Handle encrypted wallet decryption
                    const password = restorePasswordInput.value;
                    if (!password) {
                        restoreStatus.className = 'info-box error';
                        restoreStatus.textContent = 'Please enter the decryption password.';
                        restoreStatus.style.display = 'block';
                        return;
                    }

                    // Check if this is an encrypted .dat file
                    if (file.name.endsWith('.dat')) {
                        console.log('Decrypting encrypted .dat file...');
                        // Set password in the field and call decryptAndImportWallet
                        // The password is already in restorePasswordInput
                        await decryptAndImportWallet();
                        return;
                    }

                    // Otherwise handle text backup files
                    try {
                        const fileContent = await file.text();
                        
                        // Check if it's the old format with ENCRYPTED MASTER KEY
                        if (fileContent.includes('ENCRYPTED MASTER KEY')) {
                            // Handle old format
                            const encryptedKeyMatch = fileContent.match(/ENCRYPTED MASTER KEY \(password protected\):\s*([^\n]+)/);
                            
                            if (!encryptedKeyMatch || !encryptedKeyMatch[1]) {
                                throw new Error('Invalid encrypted wallet format');
                            }
                            
                            const encryptedMasterKey = encryptedKeyMatch[1].trim();
                            
                            // Decrypt using PBKDF2 (old method)
                            try {
                                const salt = "alpha_wallet_salt";
                                const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                                
                                const decryptedBytes = CryptoJS.AES.decrypt(encryptedMasterKey, passwordKey);
                                const decryptedMasterKey = decryptedBytes.toString(CryptoJS.enc.Utf8);
                                
                                if (!decryptedMasterKey) {
                                    throw new Error('Incorrect password or corrupted wallet file');
                                }
                                
                                // Parse addresses from the file
                                const addressMatches = fileContent.match(/Address \d+: (alpha1[a-z0-9]{38,})/g);
                                const addresses = addressMatches ? addressMatches.map((match, index) => {
                                    const addrMatch = match.match(/Address \d+: (alpha1[a-z0-9]{38,})/);
                                    return {
                                        index: index,
                                        address: addrMatch ? addrMatch[1] : null
                                    };
                                }).filter(a => a.address) : [];
                                
                                // Check if this is a BIP32 wallet by looking for chain code
                                const chainCodeMatch = fileContent.match(/MASTER CHAIN CODE \(for (?:BIP32 HD|Alpha) wallet compatibility\):\s*([^\n]+)/);
                                const isAlphaWallet = chainCodeMatch && chainCodeMatch[1] && (fileContent.includes('WALLET TYPE: BIP32 hierarchical deterministic wallet') || fileContent.includes('WALLET TYPE: Alpha descriptor wallet'));
                                
                                // Create wallet data in the expected format
                                const walletData = {
                                    masterPrivateKey: decryptedMasterKey,
                                    masterChainCode: chainCodeMatch ? chainCodeMatch[1].trim() : null,
                                    isImportedAlphaWallet: isAlphaWallet,
                                    addresses: addresses,
                                    isEncrypted: false,
                                    encryptedMasterKey: ''
                                };
                            
                                // Check if this is a WIF wallet (no chain code) or BIP32
                                if (!walletData.masterChainCode || !walletData.isImportedAlphaWallet) {
                                    // WIF wallet - no scanning needed, directly load it
                                    restoreStatus.className = 'info-box success';
                                    restoreStatus.textContent = 'Standard WIF wallet decrypted successfully. Loading wallet...';
                                    restoreStatus.style.display = 'block';
                                    
                                    // For WIF wallets, just call restoreWallet() after ensuring password is set
                                    // This makes encrypted wallets follow the exact same flow as unencrypted ones
                                    // The restoreWallet function will handle:
                                    // - Address parsing and recovery
                                    // - childPrivateKey derivation
                                    // - Proper UI updates
                                    // - Modal closing
                                    // - Balance refresh
                                    
                                    // Make sure the password field has the decryption password
                                    restorePasswordInput.value = password;
                                    
                                    // Call restoreWallet which handles everything properly
                                    restoreWallet();
                                } else {
                                    // BIP32 wallet - needs scanning
                                    restoreStatus.className = 'info-box success';
                                    restoreStatus.textContent = 'BIP32 wallet decrypted successfully. Starting address scan...';
                                    restoreStatus.style.display = 'block';
                                    
                                    // Change button back to Rescan Wallets
                                    scanWalletsBtn.textContent = 'Rescan Wallets';
                                    walletScanOptions.style.display = 'block';
                                    
                                    // Store decrypted data for scanning
                                    window.decryptedWalletData = walletData;
                                    
                                    // Start normal scanning process for BIP32
                                    setTimeout(() => {
                                        startWalletScanWithDecryptedData(walletData);
                                    }, 1000);
                                }
                                
                                return;
                            } catch (decryptError) {
                                throw new Error('Incorrect password or corrupted wallet file');
                            }
                        } else {
                            // New format handling (if we ever need it)
                            throw new Error('New encrypted format not supported in this version');
                        }
                    } catch (error) {
                        restoreStatus.className = 'info-box error';
                        restoreStatus.textContent = 'Decryption failed: ' + error.message;
                        restoreStatus.style.display = 'block';
                        return;
                    }
                }
                
                // Normal wallet scanning flow
                try {
                    let masterKey = '';
                    let masterChainCode = null;
                    let descriptorPath = null;
                    let isAlphaWallet = false;
                    
                    if (file.name.endsWith('.dat')) {
                        // Extract from wallet.dat
                        const result = await extractFromWalletDat(file);
                        
                        // Check if wallet is encrypted
                        if (result.isEncrypted) {
                            // Show password prompt for encrypted wallet
                            restoreStatus.className = 'info-box warning';
                            restoreStatus.innerHTML = `
                                <div>This wallet is encrypted. Please enter the password to decrypt it:</div>
                                <div style="margin-top: 10px;">
                                    <input type="password" id="walletDecryptPassword" placeholder="Enter wallet password" style="width: 200px; padding: 5px;">
                                    <button id="decryptWalletBtn" style="margin-left: 10px; padding: 5px 10px;">Decrypt</button>
                                </div>
                            `;
                            restoreStatus.style.display = 'block';
                            
                            // Store the encrypted wallet data for later decryption
                            window.encryptedWalletData = result;
                            
                            // Add decrypt button handler
                            setTimeout(() => {
                                const decryptBtn = document.getElementById('decryptWalletBtn');
                                const passwordInput = document.getElementById('walletDecryptPassword');
                                
                                if (decryptBtn) {
                                    decryptBtn.onclick = async () => {
                                        const password = passwordInput.value;
                                        if (!password) {
                                            alert('Please enter a password');
                                            return;
                                        }
                                        
                                        try {
                                            restoreStatus.textContent = 'Decrypting wallet...';
                                            
                                            // Attempt to decrypt the wallet
                                            const decryptedResult = await decryptWalletDat(result.walletData, password);
                                            
                                            if (decryptedResult.masterKey) {
                                                masterKey = decryptedResult.masterKey;
                                                masterChainCode = decryptedResult.masterChainCode || result.masterChainCode;
                                                descriptorPath = decryptedResult.descriptorPath || result.descriptorPath;
                                                isAlphaWallet = true;
                                                
                                                // Continue with normal flow
                                                extractedWalletData = {
                                                    masterKey,
                                                    masterChainCode,
                                                    descriptorPath,
                                                    isAlphaWallet
                                                };
                                                
                                                // Continue to scanning
                                                await performWalletScan();
                                            } else {
                                                throw new Error('Decryption failed - incorrect password or unsupported format');
                                            }
                                        } catch (error) {
                                            restoreStatus.className = 'info-box error';
                                            restoreStatus.textContent = 'Decryption error: ' + error.message;
                                        }
                                    };
                                }
                            }, 100);
                            
                            return; // Stop here and wait for password
                        }
                        
                        masterKey = result.masterKey;
                        masterChainCode = result.masterChainCode;
                        descriptorPath = result.descriptorPath;
                        isAlphaWallet = true;
                    } else {
                        // Extract from text backup
                        const fileContent = await file.text();
                        const masterKeyMatch = fileContent.match(/MASTER PRIVATE KEY \(keep secret!\):\s*([^\n]+)/);
                        if (masterKeyMatch) {
                            masterKey = masterKeyMatch[1].trim();
                        }
                        
                        const chainCodeMatch = fileContent.match(/MASTER CHAIN CODE \(for (?:BIP32 HD|Alpha) wallet compatibility\):\s*([^\n]+)/);
                        if (chainCodeMatch) {
                            masterChainCode = chainCodeMatch[1].trim();
                            isAlphaWallet = true;
                        }
                    }
                    
                    if (!masterKey) {
                        throw new Error('Could not extract master key from file');
                    }
                    
                    // Store extracted data
                    extractedWalletData = {
                        masterKey,
                        masterChainCode,
                        descriptorPath,
                        isAlphaWallet
                    };
                    
                    console.log('Extracted wallet data:', {
                        masterKey: masterKey,
                        masterChainCode: masterChainCode,
                        descriptorPath: descriptorPath,
                        isAlphaWallet: isAlphaWallet,
                        keyLength: masterKey ? masterKey.length : 0
                    });
                    
                    // Generate wallet fingerprint
                    const fingerprint = generateWalletFingerprint(masterKey, masterChainCode);
                    
                    // Check for cached results (skip if we just cleared the cache for rescan)
                    const isRescan = scanWalletsBtn.textContent === 'Rescan Wallets';
                    const cachedResults = !isRescan ? loadScanResultsFromCache(fingerprint) : null;
                    if (cachedResults && cachedResults.wallets && cachedResults.wallets.length > 0) {
                        
                        // Use cached results but deduplicate first
                        const uniqueWallets = [];
                        const addressSet = new Set();
                        
                        cachedResults.wallets.forEach(wallet => {
                            if (!addressSet.has(wallet.address)) {
                                addressSet.add(wallet.address);
                                uniqueWallets.push(wallet);
                            } else {
                                console.warn(`Removing duplicate cached address: ${wallet.address}`);
                            }
                        });
                        
                        scannedWallets = uniqueWallets;
                        
                        // Recalculate total balance from deduplicated wallets
                        let recalculatedTotal = 0;
                        uniqueWallets.forEach(wallet => {
                            if (wallet.balance > 0) {
                                recalculatedTotal += wallet.balance;
                            }
                        });
                        
                        lastScannedWalletData = {
                            wallets: uniqueWallets,
                            totalBalance: recalculatedTotal,
                            masterKey: extractedWalletData.masterKey,
                            masterChainCode: extractedWalletData.masterChainCode,
                            descriptorPath: extractedWalletData.descriptorPath,
                            isAlphaWallet: extractedWalletData.isAlphaWallet
                        };
                        
                        // Display cached results
                        walletScanResults.style.display = 'block';
                        foundWalletsList.innerHTML = '';
                        uniqueWallets.forEach(wallet => {
                            addWalletToResults(wallet);
                        });
                        
                        // Update status
                        const deduplicationNote = cachedResults.wallets.length !== uniqueWallets.length 
                            ? `<br><em style="font-size: 11px; color: #ff6b6b;">Removed ${cachedResults.wallets.length - uniqueWallets.length} duplicate(s)</em>` 
                            : '';
                        scanStatus.innerHTML = `Found ${uniqueWallets.length} wallet(s) from cache<br>Total balance: <strong>${SatoshiMath.satoshisToAlpha(recalculatedTotal)} ALPHA</strong>${deduplicationNote}<br><em style="font-size: 11px;">Last scan: ${new Date(cachedResults.timestamp).toLocaleString()}</em>`;
                        scanProgress.style.width = '100%';
                        scanCounter.textContent = `${uniqueWallets.length} cached`;
                        
                        // Update main UI
                        updateScannedWalletsDisplay();
                        
                        // Start lazy rescan in background if online
                        if (electrumConnected) {
                            // Show loading indicator if we'll be doing background scan and have multiple wallets
                            const nonZeroWallets = uniqueWallets.filter(w => w.balance > 0).length;
                            if (nonZeroWallets > 1) {
                                const rowEl = document.getElementById('totalScannedBalanceRow');
                                if (rowEl) rowEl.style.display = 'block';
                                document.getElementById('totalScannedLoading').style.display = 'inline';
                                // Keep balance visible alongside loading
                                document.getElementById('totalScannedBalance').style.display = 'inline';
                            }
                            startLazyRescan();
                        }
                    } else {
                        // No cache, perform full scan
                        await performWalletScan();
                    }
                    
                } catch (error) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Error: ' + error.message;
                    restoreStatus.style.display = 'block';
                }
            }
            
            // Decrypt an encrypted wallet.dat file
            async function decryptWalletDat(walletData, password) {
                console.log('Attempting to decrypt wallet with provided password');
                
                // Find mkey record
                const mkeyPattern = new TextEncoder().encode('mkey');
                const mkeyPos = findPattern(walletData, mkeyPattern, 0);
                
                if (mkeyPos === -1) {
                    throw new Error('No master key record found in wallet');
                }
                
                // Parse mkey structure
                // Format: "mkey" + version (4 bytes) + length (1 byte) + data
                const dataStart = mkeyPos + 4 + 4 + 1;
                const dataLength = walletData[mkeyPos + 8]; // Length byte
                
                if (dataLength !== 0x30) { // Should be 48 bytes
                    console.warn('Unexpected mkey length:', dataLength);
                }
                
                const mkeyData = walletData.slice(dataStart, dataStart + 48);
                console.log('Encrypted master key data:', Array.from(mkeyData).map(b => b.toString(16).padStart(2, '0')).join(''));
                
                // Try common Bitcoin/Alpha Core encryption formats
                // Format appears to be: salt(8) + encrypted_data(40)
                const salt = mkeyData.slice(0, 8);
                const encryptedData = mkeyData.slice(8);
                
                // Common iteration counts for Bitcoin Core wallets
                const iterationCounts = [25000, 10000, 50000, 100000];
                const hashMethods = ['sha512', 'sha256'];
                
                for (const iterations of iterationCounts) {
                    for (const hashMethod of hashMethods) {
                        try {
                            // Derive key using PBKDF2
                            const derivedKey = await new Promise((resolve, reject) => {
                                const keyData = CryptoJS.PBKDF2(password, 
                                    CryptoJS.enc.Hex.parse(Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join('')),
                                    { 
                                        keySize: 256/32, 
                                        iterations: iterations,
                                        hasher: hashMethod === 'sha512' ? CryptoJS.algo.SHA512 : CryptoJS.algo.SHA256
                                    }
                                );
                                resolve(keyData.toString());
                            });
                            
                            // Generate IV (Bitcoin Core uses double SHA256)
                            const ivData = CryptoJS.enc.Hex.parse(derivedKey + Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join(''));
                            const iv = CryptoJS.SHA256(CryptoJS.SHA256(ivData)).toString().substring(0, 32);
                            
                            // Try to decrypt
                            const encrypted = CryptoJS.enc.Hex.parse(Array.from(encryptedData).map(b => b.toString(16).padStart(2, '0')).join(''));
                            const decrypted = CryptoJS.AES.decrypt(
                                { ciphertext: encrypted },
                                CryptoJS.enc.Hex.parse(derivedKey),
                                { 
                                    iv: CryptoJS.enc.Hex.parse(iv),
                                    mode: CryptoJS.mode.CBC,
                                    padding: CryptoJS.pad.Pkcs7
                                }
                            );
                            
                            const decryptedHex = decrypted.toString(CryptoJS.enc.Hex);
                            
                            // Check if decryption looks valid (should be 32 bytes)
                            if (decryptedHex.length >= 64) { // 32 bytes = 64 hex chars
                                const masterKey = decryptedHex.substring(0, 64);
                                
                                // Validate that it's a valid private key
                                if (isValidPrivateKey(masterKey)) {
                                    console.log('Successfully decrypted master key!');
                                    
                                    // Now use this master key to decrypt the actual wallet keys
                                    // For now, return a placeholder - full implementation would decrypt all keys
                                    return {
                                        masterKey: masterKey,
                                        masterChainCode: null, // Would need to extract from decrypted data
                                        descriptorPath: null
                                    };
                                }
                            }
                        } catch (e) {
                            // Try next combination
                            continue;
                        }
                    }
                }
                
                // If we get here, decryption failed
                throw new Error('Failed to decrypt wallet - incorrect password or unsupported encryption format');
            }
            
            // Extract from wallet.dat file
            async function extractFromWalletDat(file) {
                const data = await readBinaryFile(file);

                // Declare variables at function scope to avoid initialization errors
                let descriptorPath = null;
                let masterChainCode = null;

                // Check SQLite header
                const header = new TextDecoder().decode(data.slice(0, 16));
                if (!header.startsWith('SQLite format 3')) {
                    throw new Error('Invalid wallet.dat file - not an SQLite database');
                }
                
                // Look for private keys (same logic as restoreFromWalletDat)
                const descriptorKeyPattern = new TextEncoder().encode('walletdescriptorkey');
                let masterKey = null;
                let foundCount = 0;
                
                let index = 0;
                while ((index = findPattern(data, descriptorKeyPattern, index)) !== -1) {
                    foundCount++;
                    console.log(`Found descriptor key pattern #${foundCount} at position ${index}`);
                    // Skip the pattern and look for public key
                    let offset = index + descriptorKeyPattern.length;
                    
                    // Find compressed public key (33 bytes starting with 0x02 or 0x03)
                    for (let skip = 0; skip < 100 && offset + skip + 33 < data.length; skip++) {
                        const pubKeyCandidate = data.slice(offset + skip, offset + skip + 33);
                        if ((pubKeyCandidate[0] === 0x02 || pubKeyCandidate[0] === 0x03)) {
                            // Look for private key after public key
                            for (let privOffset = 0; privOffset < 20 && offset + skip + 33 + privOffset + 50 < data.length; privOffset++) {
                                const checkPos = offset + skip + 33 + privOffset;
                                
                                // Look for DER sequence markers
                                // Pattern 1: d63081d30201010420 (full DER sequence)
                                if (data[checkPos] === 0xd6 && 
                                    data[checkPos + 1] === 0x30 && 
                                    data[checkPos + 2] === 0x81 && 
                                    data[checkPos + 3] === 0xd3 &&
                                    data[checkPos + 4] === 0x02 &&
                                    data[checkPos + 5] === 0x01 &&
                                    data[checkPos + 6] === 0x01 &&
                                    data[checkPos + 7] === 0x04 &&
                                    data[checkPos + 8] === 0x20) {
                                    
                                    // Extract the 32-byte private key
                                    const privKeyBytes = data.slice(checkPos + 9, checkPos + 41);
                                    const privKeyHex = Array.from(privKeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                                    
                                    if (isValidPrivateKey(privKeyHex)) {
                                        masterKey = privKeyHex;
                                        console.log(`Found valid private key (pattern 1): ${privKeyHex}`);
                                        break;
                                    }
                                }
                                
                                // Pattern 2: d30201010420 (shorter DER sequence)
                                if (!masterKey &&
                                    data[checkPos] === 0xd3 &&
                                    data[checkPos + 1] === 0x02 &&
                                    data[checkPos + 2] === 0x01 &&
                                    data[checkPos + 3] === 0x01 &&
                                    data[checkPos + 4] === 0x04 &&
                                    data[checkPos + 5] === 0x20) {
                                    
                                    // Extract the 32-byte private key
                                    const privKeyBytes = data.slice(checkPos + 6, checkPos + 38);
                                    const privKeyHex = Array.from(privKeyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                                    
                                    if (isValidPrivateKey(privKeyHex)) {
                                        masterKey = privKeyHex;
                                        console.log(`Found valid private key (pattern 2): ${privKeyHex}`);
                                        break;
                                    }
                                }
                                
                                // Alternative: Look for standard DER SEQUENCE (0x30)
                                if (!masterKey && data[checkPos] === 0x30) {
                                    const derData = data.slice(checkPos, Math.min(checkPos + 200, data.length));
                                    const privKey = parseDERPrivateKey(derData);
                                    
                                    if (privKey) {
                                        const privKeyHex = Array.from(privKey).map(b => b.toString(16).padStart(2, '0')).join('');
                                        if (isValidPrivateKey(privKeyHex)) {
                                            masterKey = privKeyHex;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        if (masterKey) break;
                    }
                    if (masterKey) break;
                    index++;
                }
                
                // If no descriptor keys found, check if wallet is encrypted
                if (!masterKey && foundCount === 0) {
                    // Check for encryption markers
                    const mkeyPattern = new TextEncoder().encode('mkey');
                    const encryptedPattern = new TextEncoder().encode('encrypted');
                    
                    const hasMkey = findPattern(data, mkeyPattern, 0) !== -1;
                    const hasEncrypted = findPattern(data, encryptedPattern, 0) !== -1;
                    
                    if (hasMkey || hasEncrypted) {
                        // This is an encrypted wallet - prompt for password
                        console.log('Detected encrypted wallet - will need password for decryption');
                        
                        // Store encryption info for later use
                        return {
                            masterKey: null,
                            masterChainCode: null,
                            descriptorPath: descriptorPath,
                            isAlphaWallet: true,
                            isEncrypted: true,
                            walletData: data // Store the raw data for decryption attempt
                        };
                    }
                    
                    // Try searching for raw private keys (32 bytes) - only for truly legacy wallets
                    console.warn('Attempting legacy key extraction - this may not find the correct master key');
                    const keyPattern = new TextEncoder().encode('key');
                    index = 0;
                    while ((index = findPattern(data, keyPattern, index)) !== -1 && !masterKey) {
                        // Look for 32-byte sequences that could be private keys
                        for (let offset = index + keyPattern.length; offset < Math.min(index + 200, data.length - 32); offset++) {
                            const candidate = data.slice(offset, offset + 32);
                            const candidateHex = Array.from(candidate).map(b => b.toString(16).padStart(2, '0')).join('');
                            
                            if (isValidPrivateKey(candidateHex)) {
                                masterKey = candidateHex;
                                console.warn('Found a private key using legacy extraction - this may not be the master key!');
                                break;
                            }
                        }
                        index++;
                    }
                }
                
                if (!masterKey) {
                    // Check if this is an encrypted wallet before throwing error
                    const mkeyCheck = findPattern(data, new TextEncoder().encode('mkey'), 0);
                    if (mkeyCheck !== -1) {
                        // Return encrypted wallet indicator
                        return {
                            masterKey: null,
                            masterChainCode: masterChainCode,
                            descriptorPath: descriptorPath,
                            isAlphaWallet: true,
                            isEncrypted: true,
                            walletData: data
                        };
                    }
                    
                    if (foundCount === 0) {
                        throw new Error('No wallet descriptor keys found in wallet.dat. This might be a legacy or unsupported wallet.');
                    } else {
                        throw new Error(`Found ${foundCount} descriptor key(s) but could not extract private key.`);
                    }
                }
                
                // For Alpha wallets, extract the chain code from xpub
                // (masterChainCode already declared at function scope)

                // Look for all xpubs in the wallet data and find the master (depth 0)
                const xpubPattern = new TextEncoder().encode('xpub');
                const base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                let searchPos = 0;
                let foundMasterChainCode = false;
                
                while (!foundMasterChainCode && searchPos < data.length) {
                    let xpubIndex = findPattern(data, xpubPattern, searchPos);
                    if (xpubIndex === -1) break;
                    
                    // Extract the full xpub (approximately 111 characters)
                    let xpubStr = 'xpub';
                    let pos = xpubIndex + 4;
                    
                    while (pos < data.length && xpubStr.length < 120) {
                        const char = String.fromCharCode(data[pos]);
                        if (base58Chars.includes(char)) {
                            xpubStr += char;
                            pos++;
                        } else {
                            break;
                        }
                    }
                    
                    if (xpubStr.length > 100) {
                        try {
                            // Decode the xpub to check depth and extract chain code
                            const decoded = base58Decode(xpubStr);
                            const depth = decoded[4];
                            
                            // We want the master key at depth 0
                            if (depth === 0) {
                                // Chain code is at bytes 13-45 (32 bytes)
                                const chainCodeBytes = decoded.slice(13, 45);
                                masterChainCode = Array.from(chainCodeBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                                console.log('Extracted master chain code from depth 0 xpub:', masterChainCode);
                                foundMasterChainCode = true;
                            } else {
                                console.log('Found xpub at depth', depth, '- skipping, looking for master (depth 0)');
                            }
                        } catch (e) {
                            console.error('Failed to decode xpub:', e);
                        }
                    }
                    
                    searchPos = xpubIndex + 4;
                }
                
                if (!masterChainCode) {
                    console.warn('Could not extract chain code from wallet.dat - BIP32 derivation will not work correctly');
                }

                // Look for wpkh descriptor to extract derivation path
                // (descriptorPath already declared at function scope)
                const wpkhPattern = new TextEncoder().encode('wpkh([');
                let wpkhIndex = findPattern(data, wpkhPattern, 0);
                if (wpkhIndex !== -1) {
                    // Read the descriptor (up to 200 bytes should be enough)
                    const descriptorArea = data.slice(wpkhIndex, Math.min(wpkhIndex + 200, data.length));
                    let descriptorStr = '';
                    
                    // Convert to string until we hit a non-printable character or closing parenthesis
                    for (let i = 0; i < descriptorArea.length; i++) {
                        const byte = descriptorArea[i];
                        if (byte >= 32 && byte <= 126) { // Printable ASCII
                            descriptorStr += String.fromCharCode(byte);
                            if (descriptorStr.includes('*))')) break; // End of descriptor
                        }
                    }
                    
                    console.log('Found descriptor in extractFromWalletDat:', descriptorStr);
                    
                    // Parse the descriptor path
                    // Format: wpkh([fingerprint/84'/0'/0']xpub.../0/*)
                    const pathMatch = descriptorStr.match(/\[[\da-f]+\/(\d+'\/\d+'\/\d+')\]/);
                    if (pathMatch) {
                        descriptorPath = pathMatch[1];
                        console.log('Extracted descriptor path in extractFromWalletDat:', descriptorPath);
                    }
                }
                
                return {
                    masterKey,
                    masterChainCode,
                    descriptorPath,
                    isAlphaWallet: true
                };
            }
            
            // Perform the actual scanning
            async function performWalletScan(masterKey, masterChainCode, isAlphaWallet) {
                const scanCount = parseInt(scanCountInput.value) || 100;
                const checkOnline = scanOnlineCheckbox.checked;
                const scanChangeAddrs = document.getElementById('scanChangeAddresses').checked;
                
                // Set extracted wallet data if parameters provided
                if (masterKey) {
                    extractedWalletData = {
                        masterKey: masterKey,
                        masterChainCode: masterChainCode,
                        isAlphaWallet: isAlphaWallet
                    };
                }
                
                scanningActive = true;
                // IMPORTANT: Clear the scannedWallets array to prevent duplicates
                scannedWallets = [];
                walletScanResults.style.display = 'block';
                foundWalletsList.innerHTML = '';
                scanStatus.textContent = 'Scanning...';
                scanProgress.style.width = '0%';
                
                // Initialize scan data structure early
                lastScannedWalletData = {
                    wallets: [],
                    totalBalance: 0,
                    masterKey: extractedWalletData.masterKey,
                    masterChainCode: extractedWalletData.masterChainCode,
                    descriptorPath: extractedWalletData.descriptorPath,
                    isAlphaWallet: extractedWalletData.isAlphaWallet
                };
                
                // Reset status text for new scan
                const statusTextEl = document.getElementById('scanStatusText');
                if (statusTextEl) {
                    statusTextEl.innerHTML = 'Scanning wallets <span id="scanPercentage">0%</span>';
                }
                
                // Update display to show loading indicator
                updateScannedWalletsDisplay();
                
                const dustThreshold = 1000; // satoshis
                const totalScans = scanChangeAddrs ? scanCount * 2 : scanCount;
                let scansDone = 0;
                totalScansCount = totalScans; // Store globally
                currentScanProgress = 0; // Reset progress
                
                // Scan external addresses (receiving)
                for (let i = 0; i < scanCount && scanningActive; i++) {
                    // Derive address at index
                    const walletInfo = deriveAddressAtIndex(
                        extractedWalletData.masterKey,
                        extractedWalletData.masterChainCode,
                        i,
                        extractedWalletData.isAlphaWallet,
                        false, // external address
                        extractedWalletData.descriptorPath
                    );
                    
                    // Skip logging each address to reduce clutter
                    
                    // Check balance if online
                    if (checkOnline && electrumConnected) {
                        const balanceInfo = await checkAddressBalance(walletInfo.address);
                        walletInfo.balance = balanceInfo.balance;
                        walletInfo.utxoCount = balanceInfo.utxoCount;
                    }
                    
                    // Add to results if has balance above dust threshold, if offline, or if it's the first address
                    if (!checkOnline || !electrumConnected || walletInfo.balance > dustThreshold || i === 0) {
                        // If offline, show all addresses
                        if (!checkOnline || !electrumConnected) {
                            walletInfo.balance = -1; // Indicate unknown balance
                        }
                        walletInfo.isChange = false;
                        // Check for duplicates before adding
                        const isDuplicate = scannedWallets.some(w => w.address === walletInfo.address);
                        if (!isDuplicate) {
                            scannedWallets.push(walletInfo);
                            addWalletToResults(walletInfo);
                        } else {
                            console.warn(`Skipping duplicate address: ${walletInfo.address}`);
                        }
                        
                        // Update total balance immediately if online and has balance
                        if (checkOnline && electrumConnected && walletInfo.balance > 0) {
                            let runningTotal = 0;
                            scannedWallets.forEach(w => {
                                if (w.balance > 0) runningTotal += w.balance;
                            });
                            
                            // Update status with running total
                            scanStatus.innerHTML = `Scanning... Found ${scannedWallets.length} wallet(s)<br>Current total: <strong>${SatoshiMath.satoshisToAlpha(runningTotal)} ALPHA</strong>`;
                            
                            // Update lastScannedWalletData with current data
                            lastScannedWalletData = {
                                wallets: [...scannedWallets],
                                totalBalance: runningTotal,
                                masterKey: extractedWalletData.masterKey,
                                masterChainCode: extractedWalletData.masterChainCode,
                                descriptorPath: extractedWalletData.descriptorPath,
                                isAlphaWallet: extractedWalletData.isAlphaWallet
                            };
                            
                            // Update display to reflect current scan state
                            updateScannedWalletsDisplay();
                        }
                    }
                    
                    scansDone++;
                    // Update progress
                    const progress = (scansDone / totalScans) * 100;
                    currentScanProgress = Math.floor(progress); // Store globally
                    scanProgress.style.width = progress + '%';
                    scanCounter.textContent = `${scansDone} / ${totalScans}`;
                    
                    // Update percentage in loading indicator
                    const percentageEl = document.getElementById('scanPercentage');
                    if (percentageEl) {
                        percentageEl.textContent = `${currentScanProgress}%`;
                    }
                    
                    // Small delay to not overwhelm the UI
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                // Scan change addresses if requested
                if (scanChangeAddrs && scanningActive) {
                    for (let i = 0; i < scanCount && scanningActive; i++) {
                        // Derive change address at index
                        const walletInfo = deriveAddressAtIndex(
                            extractedWalletData.masterKey,
                            extractedWalletData.masterChainCode,
                            i,
                            extractedWalletData.isAlphaWallet,
                            true, // change address
                            extractedWalletData.descriptorPath
                        );
                        
                        // Skip logging each address to reduce clutter
                        
                        // Check balance if online
                        if (checkOnline && electrumConnected) {
                            const balanceInfo = await checkAddressBalance(walletInfo.address);
                            walletInfo.balance = balanceInfo.balance;
                            walletInfo.utxoCount = balanceInfo.utxoCount;
                            }
                        
                        // Add to results if has balance above dust threshold, if offline, or if it's the first change address
                        if (!checkOnline || !electrumConnected || walletInfo.balance > dustThreshold || i === 0) {
                            // If offline, show all addresses
                            if (!checkOnline || !electrumConnected) {
                                walletInfo.balance = -1; // Indicate unknown balance
                            }
                            walletInfo.isChange = true;
                            // Check for duplicates before adding
                            const isDuplicate = scannedWallets.some(w => w.address === walletInfo.address);
                            if (!isDuplicate) {
                                scannedWallets.push(walletInfo);
                                addWalletToResults(walletInfo);
                            } else {
                                console.warn(`Skipping duplicate change address: ${walletInfo.address}`);
                            }
                            
                            // Update total balance immediately if online and has balance
                            if (checkOnline && electrumConnected && walletInfo.balance > 0) {
                                let runningTotal = 0;
                                scannedWallets.forEach(w => {
                                    if (w.balance > 0) runningTotal += w.balance;
                                });
                                
                                // Update status with running total
                                scanStatus.innerHTML = `Scanning... Found ${scannedWallets.length} wallet(s)<br>Current total: <strong>${SatoshiMath.satoshisToAlpha(runningTotal)} ALPHA</strong>`;
                                
                                // Update lastScannedWalletData with current data
                                lastScannedWalletData = {
                                    wallets: [...scannedWallets],
                                    totalBalance: runningTotal,
                                    masterKey: extractedWalletData.masterKey,
                                    masterChainCode: extractedWalletData.masterChainCode,
                                    descriptorPath: extractedWalletData.descriptorPath,
                                    isAlphaWallet: extractedWalletData.isAlphaWallet
                                };
                                
                                // Update display to reflect current scan state
                                updateScannedWalletsDisplay();
                            }
                        }
                        
                        scansDone++;
                        // Update progress
                        const progress = (scansDone / totalScans) * 100;
                        currentScanProgress = Math.floor(progress); // Store globally
                        scanProgress.style.width = progress + '%';
                        scanCounter.textContent = `${scansDone} / ${totalScans}`;
                        
                        // Update percentage in loading indicator
                        const percentageEl = document.getElementById('scanPercentage');
                        if (percentageEl) {
                            percentageEl.textContent = `${currentScanProgress}%`;
                        }
                        
                        // Small delay to not overwhelm the UI
                        if (i % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                }
                
                scanningActive = false;
                currentScanProgress = 100; // Set to 100% when complete
                
                // Update percentage one last time
                const percentageEl = document.getElementById('scanPercentage');
                if (percentageEl) {
                    percentageEl.textContent = '100%';
                }
                
                // Calculate total balance of all scanned wallets
                let totalBalance = 0;
                scannedWallets.forEach(w => {
                    if (w.balance > 0) totalBalance += w.balance;
                });
                
                // Store scan results for later use
                lastScannedWalletData = {
                    wallets: scannedWallets,
                    totalBalance: totalBalance,
                    masterKey: extractedWalletData.masterKey,
                    masterChainCode: extractedWalletData.masterChainCode,
                    descriptorPath: extractedWalletData.descriptorPath,
                    isAlphaWallet: extractedWalletData.isAlphaWallet
                };
                
                // Save to cache
                const fingerprint = generateWalletFingerprint(extractedWalletData.masterKey, extractedWalletData.masterChainCode);
                saveScanResultsToCache(fingerprint, lastScannedWalletData);
                
                // Update scan status with total balance
                if (scannedWallets.length > 0) {
                    scanStatus.innerHTML = `Found ${scannedWallets.length} wallet(s) with funds<br>Total balance: <strong>${SatoshiMath.satoshisToAlpha(totalBalance)} ALPHA</strong>`;
                } else {
                    scanStatus.textContent = !checkOnline || !electrumConnected ? 'Scan complete (offline mode)' : 'No wallets with funds found';
                }
                
                if (scannedWallets.length === 0) {
                    foundWalletsList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No wallets with funds found. Try increasing the scan count or check your connection.</div>';
                }
                
                // Update main UI if wallet is loaded
                updateScannedWalletsDisplay();
            }
            
            // Update the main UI to show total scanned balance
            function updateScannedWalletsDisplay() {
                const totalScannedBalanceRow = document.getElementById('totalScannedBalanceRow');
                const totalScannedBalance = document.getElementById('totalScannedBalance');
                const totalScannedLoading = document.getElementById('totalScannedLoading');

                if (!lastScannedWalletData || !lastScannedWalletData.wallets) {
                    // Hide the entire row if no scan data
                    if (totalScannedBalanceRow) totalScannedBalanceRow.style.display = 'none';
                    return;
                }

                // Count non-zero balance wallets
                const nonZeroWallets = lastScannedWalletData.wallets.filter(w => w.balance > 0).length;

                if (nonZeroWallets <= 1 && !scanningActive) {
                    // Hide row if only one or no wallets with balance (unless actively scanning)
                    if (totalScannedBalanceRow) totalScannedBalanceRow.style.display = 'none';
                    return;
                }

                // Show the row for BIP32 wallets with multiple addresses
                if (totalScannedBalanceRow) totalScannedBalanceRow.style.display = 'block';

                // If actively scanning, show loading indicator
                if (scanningActive) {
                    if (totalScannedLoading) totalScannedLoading.style.display = 'inline';
                    // Hide balance text during scan
                    if (totalScannedBalance) totalScannedBalance.style.display = 'none';
                } else if (nonZeroWallets > 1) {
                    // Show total balance if multiple wallets found and not scanning
                    const totalBalance = lastScannedWalletData.totalBalance || 0;
                    document.getElementById('totalScannedAmount').textContent = `${SatoshiMath.satoshisToAlpha(totalBalance)} ALPHA`;
                    if (totalScannedBalance) totalScannedBalance.style.display = 'inline';
                    if (totalScannedLoading) totalScannedLoading.style.display = 'none';
                } else {
                    // Hide both balance and loading within the row
                    if (totalScannedBalance) totalScannedBalance.style.display = 'none';
                    if (totalScannedLoading) totalScannedLoading.style.display = 'none';
                }
            }
            
            // Check for cached scan data on page load
            function checkAndLoadCachedScanData() {
                // Look for any cached scan data in localStorage
                const keys = Object.keys(localStorage);
                const cacheKeys = keys.filter(k => k.startsWith('walletScanCache_'));
                
                if (cacheKeys.length > 0) {
                    // Use the most recent cache
                    let mostRecentCache = null;
                    let mostRecentTime = 0;
                    
                    cacheKeys.forEach(key => {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (data.timestamp > mostRecentTime) {
                                mostRecentTime = data.timestamp;
                                mostRecentCache = data;
                                // Extract fingerprint from key
                                const fingerprint = key.replace('walletScanCache_', '');
                                mostRecentCache.fingerprint = fingerprint;
                            }
                        } catch (e) {
                            console.error('Failed to parse cache:', e);
                        }
                    });
                    
                    if (mostRecentCache && mostRecentCache.wallets && mostRecentCache.wallets.length > 0) {
                        
                        // Set the cached data
                        lastScannedWalletData = {
                            wallets: mostRecentCache.wallets,
                            totalBalance: mostRecentCache.totalBalance,
                            // We don't have the master keys here, but that's ok for display
                            masterKey: null,
                            masterChainCode: null,
                            descriptorPath: null,
                            isAlphaWallet: true
                        };
                        
                        // Update UI
                        updateScannedWalletsDisplay();
                        
                        // Note: We can't start lazy rescan here because we don't have master keys
                        // It will start when a wallet is loaded or when connected to Fulcrum
                    }
                }
            }
            
            // Lazy rescan functionality
            async function startLazyRescan() {
                if (!lastScannedWalletData || !lastScannedWalletData.wallets || !electrumConnected) {
                    return;
                }
                
                
                // Clear any existing interval
                if (lazyScanInterval) {
                    clearInterval(lazyScanInterval);
                }
                
                // Perform immediate rescan if enough time has passed
                const timeSinceLastScan = Date.now() - lastLazyScanTime;
                if (timeSinceLastScan > 3600000) { // 1 hour
                    // Double-check data still exists before performing rescan
                    if (lastScannedWalletData && lastScannedWalletData.wallets) {
                        performLazyRescan();
                    }
                }
                
                // Set up periodic rescan every hour
                lazyScanInterval = setInterval(() => {
                    if (electrumConnected && lastScannedWalletData && lastScannedWalletData.wallets) {
                        performLazyRescan();
                    }
                }, 3600000); // 1 hour
            }
            
            async function performLazyRescan() {
                if (!lastScannedWalletData || !lastScannedWalletData.wallets) {
                    // Clear the interval since we have no data to scan
                    if (lazyScanInterval) {
                        clearInterval(lazyScanInterval);
                        lazyScanInterval = null;
                    }
                    return;
                }
                
                // Store a local reference to avoid null issues during async operations
                const scanData = lastScannedWalletData;
                if (!scanData || !scanData.wallets || scanData.wallets.length === 0) {
                    return;
                }
                
                lastLazyScanTime = Date.now();
                
                // Update status text for lazy rescan
                const statusTextEl = document.getElementById('scanStatusText');
                if (statusTextEl) {
                    statusTextEl.innerHTML = 'Updating balances';
                }
                
                let totalBalance = 0;
                let updatedWallets = [];
                
                for (let i = 0; i < scanData.wallets.length; i++) {
                    // Re-check in each iteration in case data was cleared
                    if (!scanData || !scanData.wallets || !scanData.wallets[i]) {
                        console.log('Lazy rescan aborted: wallet data was cleared');
                        return;
                    }
                    const wallet = scanData.wallets[i];
                    
                    try {
                        // Check balance
                        const balanceInfo = await checkAddressBalance(wallet.address);
                        const newBalance = balanceInfo.balance;
                        const oldBalance = wallet.balance || 0;
                        
                        const updatedWallet = {
                            ...wallet,
                            balance: newBalance,
                            utxoCount: balanceInfo.utxoCount
                        };
                        
                        updatedWallets.push(updatedWallet);
                        if (newBalance > 0) {
                            totalBalance += newBalance;
                        }
                        
                        // Check if balance changed
                        if (oldBalance !== newBalance) {
                            
                            // Update the stored data immediately if it still exists
                            if (lastScannedWalletData && lastScannedWalletData.wallets && lastScannedWalletData.wallets[i]) {
                                lastScannedWalletData.wallets[i] = updatedWallet;
                                
                                // Recalculate total balance from all wallets scanned so far
                                let currentTotal = 0;
                                // Add balances from already updated wallets
                                for (let j = 0; j < updatedWallets.length; j++) {
                                    if (updatedWallets[j].balance > 0) {
                                        currentTotal += updatedWallets[j].balance;
                                    }
                                }
                                // Add balances from remaining wallets (not yet scanned)
                                for (let j = i + 1; j < scanData.wallets.length; j++) {
                                    if (scanData.wallets[j].balance > 0) {
                                        currentTotal += scanData.wallets[j].balance;
                                    }
                                }
                                
                                lastScannedWalletData.totalBalance = currentTotal;
                            }
                            
                            // Update display immediately
                            updateScannedWalletsDisplay();
                        } else {
                        }
                        
                        // Rate limit: wait 10 seconds between addresses
                        if (i < scanData.wallets.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 10000));
                        }
                    } catch (error) {
                        console.error(`Failed to rescan address ${wallet.address}:`, error);
                        // Keep the old data if scan fails
                        updatedWallets.push(wallet);
                        if (wallet.balance > 0) {
                            totalBalance += wallet.balance;
                        }
                    }
                }
                
                // Update stored data only if it still exists
                if (lastScannedWalletData) {
                    lastScannedWalletData = {
                        ...scanData,
                        wallets: updatedWallets,
                        totalBalance: totalBalance
                    };
                    
                    // Update cache only if we have master keys
                    if (lastScannedWalletData.masterKey) {
                        const fingerprint = generateWalletFingerprint(
                            lastScannedWalletData.masterKey,
                            lastScannedWalletData.masterChainCode
                        );
                        if (fingerprint) {
                            saveScanResultsToCache(fingerprint, lastScannedWalletData);
                        }
                    }
                }
                
                // Update UI
                updateScannedWalletsDisplay();
                
            }
            
            // Show dialog with all scanned wallets
            function showScannedWalletsDialog() {
                if (!lastScannedWalletData || !lastScannedWalletData.wallets) {
                    alert('No scanned wallets available. Please import a wallet.dat file first.');
                    return;
                }
                
                // Create a modal dialog
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                `;
                
                const header = document.createElement('div');
                header.style.cssText = 'padding: 20px; border-bottom: 1px solid #e9ecef;';
                header.innerHTML = `
                    <h3 style="margin: 0;">Scanned Wallets</h3>
                    <p style="margin: 10px 0 0 0; color: #666;">Total balance: <strong>${SatoshiMath.satoshisToAlpha(lastScannedWalletData.totalBalance)} ALPHA</strong></p>
                `;
                
                const content = document.createElement('div');
                content.style.cssText = 'padding: 20px; overflow-y: auto; flex: 1;';
                
                // Check if master keys are available for switching
                const canSwitchAddresses = lastScannedWalletData.masterKey && lastScannedWalletData.masterChainCode;

                // Recreate the wallet list
                lastScannedWalletData.wallets.forEach(walletInfo => {
                    const walletDiv = document.createElement('div');
                    walletDiv.style.cssText = `padding: 15px; margin-bottom: 10px; background: #f8f9fa; border-radius: 8px; cursor: ${canSwitchAddresses ? 'pointer' : 'default'}; transition: background 0.2s;${!canSwitchAddresses ? ' opacity: 0.7;' : ''}`;
                    if (canSwitchAddresses) {
                        walletDiv.onmouseover = () => walletDiv.style.background = '#e9ecef';
                        walletDiv.onmouseout = () => walletDiv.style.background = '#f8f9fa';
                    }

                    // Determine action text based on availability
                    let actionText;
                    if (!canSwitchAddresses) {
                        actionText = 'Re-import wallet.dat to switch';
                    } else if (walletInfo.balance === -1) {
                        actionText = 'Offline';
                    } else {
                        actionText = 'Click to load';
                    }

                    walletDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: bold; margin-bottom: 5px;">
                                    ${walletInfo.isChange ? 'Change ' : ''}Address #${walletInfo.index}
                                    ${walletInfo.isChange ? '<span style="background: #ffa500; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">CHANGE</span>' : ''}
                                </div>
                                <div style="font-family: monospace; font-size: 12px; color: #666; word-break: break-all;">${walletInfo.address}</div>
                                <div style="font-size: 11px; color: #999; margin-top: 3px;">Path: ${walletInfo.path}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-weight: bold; color: var(--primary-color);">
                                    ${walletInfo.balance === -1 ? 'Balance Unknown' : `${SatoshiMath.satoshisToAlpha(walletInfo.balance)} ALPHA`}
                                </div>
                                <div style="font-size: 11px; color: ${canSwitchAddresses ? '#666' : '#999'};">
                                    ${actionText}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    walletDiv.onclick = () => {
                        // Check if master key is available (not from cache-only data)
                        if (!lastScannedWalletData.masterKey || !lastScannedWalletData.masterChainCode) {
                            showInAppNotification('Wallet Not Available', 'Please re-import the wallet.dat file to switch addresses. Cached data does not include the master key.', 'warning');
                            return;
                        }

                        document.body.removeChild(modal);
                        // Reconstruct full wallet info from stored data
                        const fullWalletInfo = deriveAddressAtIndex(
                            lastScannedWalletData.masterKey,
                            lastScannedWalletData.masterChainCode,
                            walletInfo.index,
                            lastScannedWalletData.isAlphaWallet,
                            walletInfo.isChange,
                            lastScannedWalletData.descriptorPath
                        );
                        fullWalletInfo.balance = walletInfo.balance;
                        fullWalletInfo.utxoCount = walletInfo.utxoCount;

                        // Store the extracted wallet data globally before importing
                        extractedWalletData = lastScannedWalletData;

                        selectWalletForImport(fullWalletInfo);
                    };
                    
                    content.appendChild(walletDiv);
                });
                
                const footer = document.createElement('div');
                footer.style.cssText = 'padding: 20px; border-top: 1px solid #e9ecef; text-align: right;';
                footer.innerHTML = `
                    <button onclick="this.closest('div[style*=fixed]').remove()" class="button" style="background-color: #6c757d;">Close</button>
                `;
                
                dialog.appendChild(header);
                dialog.appendChild(content);
                dialog.appendChild(footer);
                modal.appendChild(dialog);
                document.body.appendChild(modal);
                
                // Close on backdrop click
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                };
            }
            window.showScannedWalletsDialog = showScannedWalletsDialog;
            
            // Add wallet to results UI
            function addWalletToResults(walletInfo) {
                const walletDiv = document.createElement('div');
                walletDiv.style.cssText = 'padding: 15px; margin-bottom: 10px; background: #f8f9fa; border-radius: 8px; cursor: pointer; transition: background 0.2s;';
                walletDiv.onmouseover = () => walletDiv.style.background = '#e9ecef';
                walletDiv.onmouseout = () => walletDiv.style.background = '#f8f9fa';
                
                walletDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: bold; margin-bottom: 5px;">
                                ${walletInfo.isChange ? 'Change ' : ''}Address #${walletInfo.index}
                                ${walletInfo.isChange ? '<span style="background: #ffa500; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">CHANGE</span>' : ''}
                            </div>
                            <div style="font-family: monospace; font-size: 12px; color: #666; word-break: break-all;">${walletInfo.address}</div>
                            <div style="font-size: 11px; color: #999; margin-top: 3px;">Path: ${walletInfo.path}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: bold; color: var(--primary-color);">
                                ${walletInfo.balance === -1 ? 'Balance Unknown' : `${SatoshiMath.satoshisToAlpha(walletInfo.balance)} ALPHA`}
                            </div>
                            <div style="font-size: 11px; color: #666;">
                                ${walletInfo.balance === -1 ? 'Offline' : 'Click to load'}
                            </div>
                        </div>
                    </div>
                `;
                
                walletDiv.onclick = () => selectWalletForImport(walletInfo);
                foundWalletsList.appendChild(walletDiv);
            }
            
            // Select a wallet for import
            function selectWalletForImport(walletInfo) {
                // Directly import without confirmation
                // Don't stop scanning - let it continue in background
                
                // Create wallet with the selected index
                // Remove utxos from walletInfo for storage
                const addressInfo = {
                    index: walletInfo.index,
                    address: walletInfo.address,
                    publicKey: walletInfo.publicKey,
                    path: walletInfo.path,
                    createdAt: new Date().toISOString()
                };
                
                wallet = {
                    masterPrivateKey: extractedWalletData.masterKey,
                    addresses: [addressInfo],
                    isEncrypted: false,
                    encryptedMasterKey: '',
                    childPrivateKey: walletInfo.privateKey,
                    isImportedAlphaWallet: extractedWalletData.isAlphaWallet,
                    masterChainCode: extractedWalletData.masterChainCode
                };
                
                // Update global reference
                window.walletGlobal = wallet;
                
                // Update UI
                updateButtonStates(true);
                addAddressToUI(walletInfo);
                saveWalletData();
                
                // Close modal
                closeRestoreModal();
                
                showInAppNotification('Wallet Imported', `Successfully imported wallet at index ${walletInfo.index}`, 'success');

                // Clear classification queue when switching wallets
                clearClassificationQueue();

                // Refresh balance if connected
                if (electrumConnected) {
                    refreshBalance();
                }
                
                // Update scanned wallets display
                updateScannedWalletsDisplay();
            }
            
            async function restoreWallet() {
                const file = restoreFileInput.files[0];
                if (!file) {
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Please select a wallet backup file.';
                    restoreStatus.style.display = 'block';
                    return;
                }
                
                // Clear ALL previous wallet state before loading new wallet
                console.log('Clearing previous wallet state...');
                currentUtxos = [];
                currentTransactions = [];
                currentTransactionPage = 1;
                currentUtxoPage = 1;
                offlineUtxoData = null;
                // Clear vesting classification state
                addressVestingCache.clear();
                VestingClassifier.clearCache();
                clearClassificationQueue();

                // Clear UI displays
                if (walletBalance) walletBalance.textContent = '0.00000000 ALPHA';
                if (walletUnconfirmed) walletUnconfirmed.textContent = '';
                const transactionHistoryList = document.getElementById('transactionHistoryList');
                if (transactionHistoryList) transactionHistoryList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading wallet...</div>';
                const currentUtxoList = document.getElementById('currentUtxoList');
                if (currentUtxoList) currentUtxoList.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading wallet...</div>';
                
                // Clear any existing scan cache when loading a new wallet
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('walletScan_') || 
                               key.startsWith('walletScanCache_') || 
                               key === 'lastScannedWalletData' || 
                               key === 'lastLazyScanTime')) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => {
                    localStorage.removeItem(key);
                    console.log('Cleared cached scan data on wallet load:', key);
                });
                
                // Clear in-memory scan data and stop any ongoing rescans
                lastScannedWalletData = null;
                scannedWallets = [];
                
                // Clear any existing rescan interval
                if (lazyScanInterval) {
                    clearInterval(lazyScanInterval);
                    lazyScanInterval = null;
                }
                
                try {
                    // Check if this is a wallet.dat file (SQLite)
                    if (file.name.endsWith('.dat')) {
                        await restoreFromWalletDat(file);
                        return;
                    }
                    
                    // Otherwise, read as text file (original backup format)
                    const fileContent = await file.text();
                    
                    // Parse the master key from the file
                    let masterKey = '';
                    let isEncrypted = false;
                    let encryptedMasterKey = '';
                    
                    // Check if this is an encrypted wallet
                    if (fileContent.includes('ENCRYPTED MASTER KEY')) {
                        isEncrypted = true;
                        console.log('Loading encrypted wallet...');
                        
                        // Extract the encrypted master key
                        const encryptedKeyMatch = fileContent.match(/ENCRYPTED MASTER KEY \(password protected\):\s*([^\n]+)/);
                        if (encryptedKeyMatch && encryptedKeyMatch[1]) {
                            encryptedMasterKey = encryptedKeyMatch[1].trim();
                            console.log('Found encrypted master key');
                            
                            // Get the decryption password
                            const password = restorePasswordInput.value;
                            if (!password) {
                                restoreStatus.className = 'info-box error';
                                restoreStatus.textContent = 'This is an encrypted wallet. Please enter the decryption password.';
                                restoreStatus.style.display = 'block';
                                return;
                            }
                            
                            // Decrypt the master key
                            try {
                                console.log('Attempting to decrypt with provided password...');
                                const salt = "alpha_wallet_salt";
                                const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                                
                                // Try to decrypt
                                const decryptedBytes = CryptoJS.AES.decrypt(encryptedMasterKey, passwordKey);
                                masterKey = decryptedBytes.toString(CryptoJS.enc.Utf8);
                                
                                if (!masterKey) {
                                    restoreStatus.className = 'info-box error';
                                    restoreStatus.textContent = 'Failed to decrypt the wallet. The password may be incorrect.';
                                    restoreStatus.style.display = 'block';
                                    return;
                                }
                                console.log('Successfully decrypted master key:', masterKey.substring(0, 8) + '...');
                            } catch (e) {
                                restoreStatus.className = 'info-box error';
                                restoreStatus.textContent = 'Error decrypting wallet: ' + e.message;
                                restoreStatus.style.display = 'block';
                                return;
                            }
                        } else {
                            restoreStatus.className = 'info-box error';
                            restoreStatus.textContent = 'Could not find the encrypted master key in the backup file.';
                            restoreStatus.style.display = 'block';
                            return;
                        }
                    } else {
                        // Unencrypted wallet, extract the master key directly
                        const masterKeyMatch = fileContent.match(/MASTER PRIVATE KEY \(keep secret!\):\s*([^\n]+)/);
                        if (masterKeyMatch && masterKeyMatch[1]) {
                            masterKey = masterKeyMatch[1].trim();
                        } else {
                            restoreStatus.className = 'info-box error';
                            restoreStatus.textContent = 'Could not find the master private key in the backup file.';
                            restoreStatus.style.display = 'block';
                            return;
                        }
                    }
                    
                    // Check if this is an Alpha descriptor wallet with chain code
                    let masterChainCode = null;
                    let isImportedAlphaWallet = false;
                    
                    const chainCodeMatch = fileContent.match(/MASTER CHAIN CODE \(for (?:BIP32 HD|Alpha) wallet compatibility\):\s*([^\n]+)/);
                    if (chainCodeMatch && chainCodeMatch[1]) {
                        masterChainCode = chainCodeMatch[1].trim();
                        isImportedAlphaWallet = true;
                    }
                    
                    // Also check wallet type explicitly
                    if (fileContent.includes('WALLET TYPE: BIP32 hierarchical deterministic wallet') || fileContent.includes('WALLET TYPE: Alpha descriptor wallet')) {
                        isImportedAlphaWallet = true;
                    }
                    
                    // Parse addresses from the backup file
                    let parsedAddresses = [];
                    const addressSection = fileContent.match(/YOUR ADDRESSES:\s*\n([\s\S]*?)(?:\n\nGenerated on:|$)/);
                    console.log('Address section found:', !!addressSection);
                    if (addressSection && addressSection[1]) {
                        const addressLines = addressSection[1].trim().split('\n');
                        console.log('Address lines to parse:', addressLines);
                        for (const line of addressLines) {
                            // Parse lines like: "Address 1: alpha1qllh2t42ytsgnx8fferxwms6npec7whvnaxta7d (Path: m/44'/0'/0')"
                            // or: "Address 1: alpha1qllh2t42ytsgnx8fferxwms6npec7whvnaxta7d (Path: undefined)"
                            const addressMatch = line.match(/Address\s+(\d+):\s+(\w+)\s*\(Path:\s*([^)]*)\)/);
                            if (addressMatch) {
                                const index = parseInt(addressMatch[1]) - 1; // Convert to 0-based index
                                const address = addressMatch[2];
                                const path = addressMatch[3] === 'undefined' ? null : addressMatch[3];
                                const addressInfo = {
                                    index: index,
                                    address: address,
                                    path: path,
                                    createdAt: new Date().toISOString()
                                };
                                console.log('Parsed address:', addressInfo);
                                parsedAddresses.push(addressInfo);
                            }
                        }
                    }
                    console.log('Total parsed addresses:', parsedAddresses.length, parsedAddresses);
                    
                    // Confirmation before overwriting
                    if (wallet.masterPrivateKey) {
                        const confirmOverwrite = confirm('This will overwrite your existing wallet. Are you sure you want to proceed?');
                        if (!confirmOverwrite) {
                            return;
                        }
                    }
                    
                    // Create a new wallet with the restored master key
                    wallet = {
                        masterPrivateKey: masterKey,
                        addresses: parsedAddresses, // Use parsed addresses instead of empty array
                        isEncrypted: isEncrypted,
                        encryptedMasterKey: encryptedMasterKey,
                        childPrivateKey: null, // Will be set when generating first address or recovered
                        isImportedAlphaWallet: isImportedAlphaWallet,
                        masterChainCode: masterChainCode
                    };
                    
                    // Update global reference
                    window.walletGlobal = wallet;
                    
                    // Update UI for both key displays
                    // masterKeyElement.textContent = masterKey; // Removed with Security section
                    // masterKeyElement.classList.add('masked'); // Removed with Security section
                    
                    // Convert and display WIF key
                    const wifKey = hexToWIF(masterKey);
                    // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                    // wifKeyElement.textContent = wifKey; // Removed with Security section
                    // wifKeyElement.classList.add('masked'); // Removed with Security section
                    
                    
                    // Enable buttons
                    updateButtonStates(true);
                    
                    // Update encryption UI
                    if (isEncrypted) {
                        // encryptionStatus.style.display = 'block'; // Removed with Security section
                        // Hide password strength indicator when wallet is encrypted
                        passwordStrength.innerHTML = '';
                    } else {
                        // encryptionStatus.style.display = 'none'; // Removed with Security section
                    }
                    
                    // Generate addresses properly
                    if (wallet.isImportedAlphaWallet && wallet.masterChainCode) {
                        // For BIP32 wallets, ALWAYS regenerate addresses from master key
                        // Don't trust the addresses in the file - derive them properly
                        wallet.addresses = []; // Clear any loaded addresses
                        generateNewAddress(); // This will use BIP32 derivation
                    } else if (wallet.addresses.length === 0) {
                        // For standard wallets with no addresses, generate one
                        generateNewAddress();
                    } else {
                        // For standard wallets with addresses, recover and verify them
                        console.log('Recovering standard wallet with parsed addresses:', wallet.addresses);
                        console.log('Master private key available:', !!wallet.masterPrivateKey);
                        console.log('Is encrypted:', wallet.isEncrypted);
                        
                        // Keep only the first address for standard wallets
                        if (wallet.addresses.length > 1) {
                            wallet.addresses = [wallet.addresses[0]];
                        }
                        
                        // Recover childPrivateKey for the first address
                        const addressIndex = wallet.addresses[0].index || 0;
                        const derivationPath = `m/44'/0'/${addressIndex}'`;
                        
                        console.log('Attempting to derive child key for path:', derivationPath);
                        console.log('Master key (first 8 chars):', wallet.masterPrivateKey ? wallet.masterPrivateKey.substring(0, 8) + '...' : 'null');
                        
                        // Derive child key using HMAC (standard wallet method)
                        const hmacInput = CryptoJS.enc.Hex.parse(wallet.masterPrivateKey);
                        const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                        const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                        const childPrivateKey = hmacOutput.substring(0, 64);
                        
                        console.log('Derived child private key (first 8 chars):', childPrivateKey.substring(0, 8) + '...');
                        
                        // Generate address from the derived key to verify
                        const ec = new elliptic.ec('secp256k1');
                        const keyPair = ec.keyFromPrivate(childPrivateKey);
                        const publicKey = keyPair.getPublic(true, 'hex');
                        
                        // Calculate address
                        const sha256Hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey));
                        const ripemd160Hash = CryptoJS.RIPEMD160(sha256Hash);
                        const programData = ripemd160Hash.toString();
                        const witnessVersion = 0;
                        const derivedAddress = createBech32('alpha', witnessVersion, hexToBytes(programData));
                        
                        // Verify the address matches
                        if (derivedAddress === wallet.addresses[0].address) {
                            console.log(' Address verification successful! Recovered childPrivateKey correctly.');
                            console.log('  Address:', wallet.addresses[0].address);
                            console.log('  Path:', derivationPath);
                            console.log('  Child Private Key (first 8 chars):', childPrivateKey.substring(0, 8) + '...');
                            wallet.childPrivateKey = childPrivateKey;
                            wallet.addresses[0].publicKey = publicKey;
                            wallet.addresses[0].path = derivationPath;
                            
                            // Show success message
                            restoreStatus.className = 'info-box success';
                            restoreStatus.textContent = 'Wallet restored successfully. Address verified and private key recovered.';
                            restoreStatus.style.display = 'block';
                        } else {
                            console.error(' Address verification failed!');
                            console.error('Expected:', wallet.addresses[0].address);
                            console.error('Derived:', derivedAddress);
                            
                            // Try to recover by scanning for the correct index
                            let recovered = false;
                            for (let i = 0; i < 100; i++) {
                                const testPath = `m/44'/0'/${i}'`;
                                const testHmac = CryptoJS.HmacSHA512(hmacInput, CryptoJS.enc.Utf8.parse(testPath)).toString();
                                const testChildKey = testHmac.substring(0, 64);
                                const testKeyPair = ec.keyFromPrivate(testChildKey);
                                const testPublicKey = testKeyPair.getPublic(true, 'hex');
                                const testSha256 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(testPublicKey));
                                const testRipemd = CryptoJS.RIPEMD160(testSha256);
                                const testAddress = createBech32('alpha', witnessVersion, hexToBytes(testRipemd.toString()));
                                
                                if (testAddress === wallet.addresses[0].address) {
                                    console.log(` Found correct derivation at index ${i}!`);
                                    wallet.childPrivateKey = testChildKey;
                                    wallet.addresses[0].publicKey = testPublicKey;
                                    wallet.addresses[0].path = testPath;
                                    wallet.addresses[0].index = i;
                                    recovered = true;
                                    
                                    restoreStatus.className = 'info-box success';
                                    restoreStatus.textContent = `Wallet recovered! Found correct key at index ${i}.`;
                                    restoreStatus.style.display = 'block';
                                    break;
                                }
                            }
                            
                            if (!recovered) {
                                // CRITICAL FIX: Address verification failed. This indicates either:
                                // 1. The wallet was created with a different master key
                                // 2. The wallet backup file is corrupted
                                // 3. The address was derived with a non-standard method
                                // We MUST NOT silently use a mismatched key/address pair as this
                                // will cause all transactions to fail with script verification errors.

                                restoreStatus.className = 'info-box error';
                                restoreStatus.textContent = 'ERROR: Wallet integrity check failed. The displayed address does not match any key derived from the master private key. This wallet file may be corrupted or from a different wallet. Import aborted for your security.';
                                restoreStatus.style.display = 'block';
                                console.error('WALLET INTEGRITY CHECK FAILED');
                                console.error('Address from file:', wallet.addresses[0].address);
                                console.error('Expected address from master key at path m/44\'/0\'/0\':', derivedAddress);
                                console.error('Recovery scan (0-99) failed to find matching key');
                                console.error('Import aborted to prevent key/address mismatch bug');

                                // Clear the wallet and abort import
                                wallet = {};
                                window.walletGlobal = wallet;

                                // Allow user to try again with a different file
                                const submitBtn = document.getElementById('restoreModalSubmitBtn');
                                if (submitBtn) submitBtn.style.display = 'inline-block';
                                restoreFileInput.value = '';  // Clear the failed file selection
                                updateButtonStates(false);  // Re-enable "Load Wallet Backup" button

                                return;  // Stop processing, wallet import failed
                            }
                        }
                        
                        console.log('About to call addAddressToUI with:', wallet.addresses[0]);
                        addAddressToUI(wallet.addresses[0]);
                        
                        // Force wallet info section to be visible
                        const walletInfoSection = document.getElementById('walletInfo');
                        if (walletInfoSection) {
                            walletInfoSection.style.display = 'block';
                            console.log('Forced walletInfo section to be visible');
                        }
                        
                        // Update the wallet address directly as backup
                        const walletAddressElement = document.getElementById('walletAddress');
                        if (walletAddressElement && wallet.addresses[0]) {
                            walletAddressElement.textContent = wallet.addresses[0].address;
                            console.log('Directly updated wallet address element to:', wallet.addresses[0].address);
                        }
                    }
                    
                    // Save the restored wallet
                    saveWalletData();
                    
                    // Close the restore modal for non-BIP32 wallets
                    if (!wallet.isImportedAlphaWallet) {
                        // Standard wallet - close modal and show wallet UI immediately
                        closeRestoreModal();
                        
                        // Show success notification
                        if (isEncrypted) {
                            showInAppNotification('Encrypted Wallet Loaded', 'Successfully decrypted and recovered wallet', 'success');
                        } else {
                            showInAppNotification('Wallet Loaded', 'Successfully loaded wallet', 'success');
                        }
                    }
                    
                    // If already connected to Fulcrum, refresh balance
                    if (electrumConnected) {
                        // Reset initial load flag when wallet is restored
                        isInitialLoad = true;
                        setTimeout(() => {
                            refreshBalance();
                            updateTransactionHistory();
                            // Allow notifications after initial load
                            setTimeout(() => {
                                isInitialLoad = false;
                            }, 2000);
                        }, 500);
                    }
                    
                    // Close any open sections to maintain a clean UI
                    // document.getElementById('keys-section').style.display = 'none'; // Removed with Security section
                    
                    // Reset section button text
                    // document.getElementById('showEncryptionBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                        </svg>
                        Encrypt Wallet`; */
                        
                    // document.getElementById('showRestoreBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        Restore Wallet`; */
                        
                    // document.getElementById('showAdvancedBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                        Migrate Wallet`; */
                    
                    // Show success message
                    restoreStatus.className = 'info-box success';
                    restoreStatus.textContent = 'Wallet restored successfully!';
                    restoreStatus.style.display = 'block';
                    showInAppNotification('Wallet Restored', 'Your wallet has been successfully restored from backup', 'success');
                    
                    // Close modal after a delay
                    setTimeout(() => {
                        closeRestoreModal();
                    }, 2000);
                    
                } catch (e) {
                    console.error('Error restoring wallet:', e);
                    restoreStatus.className = 'info-box error';
                    restoreStatus.textContent = 'Failed to restore wallet: ' + e.message;
                    restoreStatus.style.display = 'block';
                }
            }
            
            // Toggle WIF key visibility
            /* // Removed with Security section
            async function toggleWifKey() {
                // const wifKeyElement = document.getElementById('wifMasterKey'); // Removed with Security section
                
                if (wifKeyElement.classList.contains('masked')) {
                    // Check if wallet is encrypted
                    if (wallet.isEncrypted) {
                        // Ask for password with custom modal
                        const password = await showPasswordModal(
                            "Enter Password",
                            "Your wallet is encrypted. Please enter your password to view the private key:"
                        );
                        
                        if (!password) {
                            return; // User cancelled
                        }
                        
                        try {
                            // Generate key from password
                            const salt = "alpha_wallet_salt";
                            const passwordKey = CryptoJS.PBKDF2(password, salt, { keySize: 256/32, iterations: 100000 }).toString();
                            
                            // Try to decrypt the master key
                            const decryptedKey = CryptoJS.AES.decrypt(wallet.encryptedMasterKey, passwordKey).toString(CryptoJS.enc.Utf8);
                            
                            // If decryption failed, this will be an empty string
                            if (!decryptedKey) {
                                alert("Incorrect password. Access denied.");
                                return;
                            }
                            
                            // Check if the decrypted key matches our stored key
                            if (decryptedKey !== wallet.masterPrivateKey) {
                                alert("Incorrect password. Access denied.");
                                return;
                            }
                            
                            // Password verified, proceed with normal confirmation
                        } catch (e) {
                            console.error("Error decrypting master key:", e);
                            alert("Error verifying password. Access denied.");
                            return;
                        }
                    }
                    
                    // Show a confirmation dialog
                    const shouldShow = confirm("You are about to reveal your private key. Make sure no one is looking at your screen. Continue?");
                    
                    if (shouldShow) {
                        // Generate the child key for the first address
                        const addressIndex = 0;
                        const derivationPath = `m/44'/0'/${addressIndex}'`;
                        const hmacInput = CryptoJS.enc.Hex.parse(wallet.masterPrivateKey);
                        const hmacKey = CryptoJS.enc.Utf8.parse(derivationPath);
                        const hmacOutput = CryptoJS.HmacSHA512(hmacInput, hmacKey).toString();
                        const childPrivateKey = hmacOutput.substring(0, 64);
                        
                        // Convert and display the child key as WIF
                        const wifKey = hexToWIF(childPrivateKey);
                        wifKeyElement.textContent = wifKey;
                        
                        wifKeyElement.classList.remove('masked');
                        // document.getElementById('toggleWifKeyBtn').innerHTML = ` // Removed with Security section
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                                <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                <line x1="1" y1="1" x2="23" y2="23"></line>
                            </svg>
                            <span>Hide</span>
                        `;
                        
                        // Auto-hide after 30 seconds for security
                        setTimeout(() => {
                            if (!wifKeyElement.classList.contains('masked')) {
                                wifKeyElement.classList.add('masked');
                                // document.getElementById('toggleWifKeyBtn').innerHTML = ` // Removed with Security section
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                        <circle cx="12" cy="12" r="3"></circle>
                                    </svg>
                                    <span>Show</span>
                                `;
                            }
                        }, 30000);
                    }
                } else {
                    wifKeyElement.classList.add('masked');
                    document.getElementById('toggleWifKeyBtn').innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 5px;">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        <span>Show</span>
                    `;
                }
            }
            */ // End of removed toggleWifKey function
            
            // Toggle section functionality
            function toggleSection(sectionId, buttonId, showText, hideText, iconSvg) {
                const section = document.getElementById(sectionId);
                const button = document.getElementById(buttonId);
                
                if (section.style.display === 'none') {
                    // Hide any other open sections first
                                                            document.getElementById('keys-section').style.display = 'none';
                    
                    // Reset all button texts
                    // document.getElementById('showEncryptionBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                        </svg>
                        Encrypt Wallet`; */
                        
                    // document.getElementById('showRestoreBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        Restore Wallet`; */
                        
                    // document.getElementById('showAdvancedBtn').innerHTML = ` // Removed with Security section
                        /* <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                        Migrate Wallet`; */
                    
                    // Show this section
                    section.style.display = 'block';
                    button.innerHTML = hideText;
                    
                    // Always enable the button when it's in "hide" mode
                    button.disabled = false;
                    
                    // Smooth scroll to the section
                    setTimeout(() => {
                        section.scrollIntoView({ behavior: 'smooth' });
                    }, 100);
                } else {
                    // Hide this section
                    section.style.display = 'none';
                    button.innerHTML = iconSvg + showText;
                }
            }
            
            // Migrate section toggle
            /* // Removed with Security section
            function toggleMigrateSection() {
                toggleSection(
                    'keys-section', 
                    'showAdvancedBtn',
                    'Migrate Wallet',
                    'Hide Migration Options',
                    `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                    </svg>`
                );
            }
            */
            
            
            // Set up event listeners
            initializeWalletBtn.addEventListener('click', initializeWallet);
            saveWalletBtn.addEventListener('click', showSaveModal);
            deleteWalletBtn.addEventListener('click', deleteWallet);
            restoreWalletBtn.addEventListener('click', showRestoreModal);
            
            // Switch wallet button
            const switchWalletBtn = document.getElementById('switchWalletBtn');
            switchWalletBtn.addEventListener('click', function() {
                const storedWallets = getAllStoredWallets();
                if (storedWallets.length === 0) {
                    showInAppNotification('No Wallets', 'No wallets found. Create or restore a wallet first.', 'warning');
                } else if (storedWallets.length === 1) {
                    showInAppNotification('Single Wallet', 'Only one wallet exists. Create or restore another wallet to switch.', 'info');
                } else {
                    showWalletSelector(storedWallets, (selectedKey) => {
                        if (selectedKey === 'new') {
                            // Clear current wallet and let user create new
                            wallet = {
                                masterPrivateKey: '',
                                addresses: [],
                                isEncrypted: false,
                                encryptedMasterKey: ''
                            };
                            window.walletGlobal = wallet;
                            updateButtonStates(false);
                            // Clear UI
                            walletInfo.style.display = 'none';
                            localStorage.removeItem('currentWalletKey');
                            showInAppNotification('Ready', 'Ready to create new wallet', 'info');
                        } else if (selectedKey) {
                            // Clear current state before loading new wallet
                            currentUtxos = [];
                            currentTransactions = [];
                            lastScannedWalletData = null;
                            scannedWallets = [];
                            // Clear vesting classification state
                            addressVestingCache.clear();
                            VestingClassifier.clearCache();

                            // Load selected wallet
                            loadWalletByKey(selectedKey);
                            showInAppNotification('Wallet Switched', 'Successfully switched wallet', 'success');
                            
                            // Refresh if connected
                            if (electrumConnected) {
                                setTimeout(() => {
                                    refreshBalance();
                                    updateTransactionHistory();
                                }, 500);
                            }
                        }
                    });
                }
            });
            // migrateWalletBtn.addEventListener('click', toggleMigrateSection); // Removed with Security section
            
            // Restore modal event listeners
            restoreModalCancelBtn.addEventListener('click', closeRestoreModal);
            restoreModalSubmitBtn.addEventListener('click', restoreWallet);
            scanWalletsBtn.addEventListener('click', startWalletScan);
            
            // File input change handler
            restoreFileInput.addEventListener('change', async function() {
                if (this.files.length > 0) {
                    const file = this.files[0];

                    // Check if it's an encrypted wallet
                    let isEncryptedWallet = false;
                    if (file.name.endsWith('.txt')) {
                        try {
                            const fileContent = await file.text();
                            // Check for both new and old encrypted formats
                            if (fileContent.includes('ENCRYPTED UNICITY WALLET') ||
                                fileContent.includes('ENCRYPTED MASTER KEY')) {
                                isEncryptedWallet = true;
                            }
                        } catch (e) {
                            // Continue with normal flow if can't read
                        }
                    } else if (file.name.endsWith('.dat')) {
                        // Check if .dat file is encrypted by looking for mkey record
                        try {
                            const data = await readBinaryFile(file);
                            const mkeyPattern = new TextEncoder().encode('mkey');
                            const hasMkey = findPattern(data, mkeyPattern, 0) !== -1;
                            if (hasMkey) {
                                isEncryptedWallet = true;
                                window.encryptedWalletData = data; // Store for later decryption
                                console.log(' Encrypted .dat file detected in file preview');
                            }
                        } catch (e) {
                            console.error('Error checking .dat encryption:', e);
                        }
                    }
                    
                    if (isEncryptedWallet) {
                        // Detect wallet type from encrypted file
                        let walletTypeInfo = '';
                        let isBIP32Encrypted = false;

                        if (file.name.endsWith('.dat')) {
                            // .dat files are always BIP32 HD wallets (Alpha Core format)
                            walletTypeInfo = ' (Alpha Core BIP32 HD Wallet)';
                            isBIP32Encrypted = true;
                        } else {
                            // Text backup files - detect from content
                            try {
                                const fileContent = await file.text();
                                if (fileContent.includes('WALLET TYPE: BIP32 hierarchical deterministic wallet')) {
                                    walletTypeInfo = ' (BIP32 HD Wallet - will scan for addresses)';
                                    isBIP32Encrypted = true;
                                } else if (fileContent.includes('WALLET TYPE: Standard wallet')) {
                                    walletTypeInfo = ' (Standard WIF Wallet - single address)';
                                } else if (fileContent.includes('MASTER CHAIN CODE')) {
                                    // Fallback detection for older format
                                    walletTypeInfo = ' (BIP32 HD Wallet - will scan for addresses)';
                                    isBIP32Encrypted = true;
                                } else {
                                    walletTypeInfo = ' (Standard WIF Wallet - single address)';
                                }
                            } catch (e) {
                                // If can't detect, assume standard
                                walletTypeInfo = '';
                            }
                        }
                        
                        // Store wallet type for later use
                        restoreFileInput.dataset.isBIP32Encrypted = isBIP32Encrypted;
                        // Note: For .dat files, data was already stored in window.encryptedWalletData above

                        console.log(' ENCRYPTED WALLET DETECTED IN FILE PREVIEW - Setting up decrypt button');

                        // Show decrypt button (use existing password field)
                        walletScanOptions.style.display = 'none';
                        restoreModalSubmitBtn.style.display = 'none';
                        scanWalletsBtn.style.display = 'inline-block';
                        scanWalletsBtn.textContent = 'Decrypt';

                        console.log(' Button text set to:', scanWalletsBtn.textContent);

                        restoreStatus.className = 'info-box warning';
                        restoreStatus.textContent = `Encrypted wallet detected${walletTypeInfo}. Please enter the password above and click Decrypt.`;
                        restoreStatus.style.display = 'block';

                        // Focus the existing password input
                        setTimeout(() => {
                            if (restorePasswordInput) restorePasswordInput.focus();
                        }, 100);
                    } else {
                        // Check if it's a WIF wallet (non-BIP32 text file)
                        let isWifWallet = false;
                        if (file.name.endsWith('.txt')) {
                            try {
                                const fileContent = await file.text();
                                // Check if it's a WIF wallet by looking for absence of chain code
                                // and presence of standard wallet markers
                                if ((fileContent.includes('WALLET TYPE: Standard wallet') || 
                                    fileContent.includes('MASTER PRIVATE KEY') && 
                                    !fileContent.includes('MASTER CHAIN CODE')) && 
                                    !fileContent.includes('WALLET TYPE: BIP32')) {
                                    isWifWallet = true;
                                }
                            } catch (e) {
                                // Continue with normal flow if can't read
                            }
                        }
                        
                        if (isWifWallet) {
                            // For WIF wallets, show direct load button without scan options
                            walletScanOptions.style.display = 'none';
                            restoreModalSubmitBtn.style.display = 'inline-block';
                            scanWalletsBtn.style.display = 'none';
                            
                            restoreStatus.className = 'info-box info';
                            restoreStatus.textContent = 'Standard WIF wallet detected. Click Load to import.';
                            restoreStatus.style.display = 'block';
                        } else {
                            // Normal wallet discovery flow for BIP32 wallets
                            walletScanOptions.style.display = 'block';
                            restoreModalSubmitBtn.style.display = 'none';
                            scanWalletsBtn.style.display = 'inline-block';
                            scanWalletsBtn.textContent = 'Rescan Wallets';
                            restoreStatus.style.display = 'none';
                            
                            // Start scanning automatically for non-encrypted BIP32 wallets
                            setTimeout(() => {
                                startWalletScan();
                            }, 500); // Small delay for UI to update
                        }
                    }
                } else {
                    walletScanOptions.style.display = 'none';
                    scanWalletsBtn.style.display = 'none';
                    restoreModalSubmitBtn.style.display = 'inline-block';
                    restoreStatus.style.display = 'none';
                }
            });
            
            // Password strength checker
            passwordModalInput.addEventListener('input', function() {
                checkPasswordStrength(this.value);
            });
            
            // Save wallet data using unique key per wallet
            function saveWalletData() {
                try {
                    // Get unique storage key for this wallet
                    const storageKey = getWalletStorageKey(wallet);
                    if (!storageKey) {
                        console.error("Cannot save wallet: no master key available");
                        return;
                    }
                    
                    // Save to localStorage with unique key
                    localStorage.setItem(storageKey, JSON.stringify(wallet));
                    console.log(`Wallet data saved to localStorage with key: ${storageKey}`);
                    
                    // Also save the current wallet key for quick access
                    localStorage.setItem('currentWalletKey', storageKey);
                    
                    // Migrate legacy wallet if it exists and matches current wallet
                    const legacyWallet = localStorage.getItem('alphaWallet');
                    if (legacyWallet) {
                        try {
                            const legacyData = JSON.parse(legacyWallet);
                            // Check if it's the same wallet by comparing addresses
                            if (legacyData.addresses && wallet.addresses && 
                                legacyData.addresses[0]?.address === wallet.addresses[0]?.address) {
                                // Remove legacy storage
                                localStorage.removeItem('alphaWallet');
                                console.log('Migrated legacy wallet to new storage format');
                            }
                        } catch (e) {
                            console.error('Error migrating legacy wallet:', e);
                        }
                    }
                    
                    // Also try IndexedDB for better storage (but keep localStorage as primary)
                    try {
                        const request = indexedDB.open("AlphaWalletDB", 1);
                        
                        request.onupgradeneeded = function(event) {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('wallet')) {
                                db.createObjectStore('wallet', { keyPath: 'id' });
                            }
                        };
                        
                        request.onsuccess = function(event) {
                            const db = event.target.result;
                            const transaction = db.transaction(['wallet'], 'readwrite');
                            const store = transaction.objectStore('wallet');
                            
                            // Use storage key as ID
                            const walletData = { ...wallet, id: storageKey };
                            store.put(walletData);
                            
                            transaction.oncomplete = function() {
                                console.log("Wallet also saved to IndexedDB");
                            };
                        };
                    } catch (e) {
                        // IndexedDB is optional, localStorage is primary
                    }
                } catch (e) {
                    console.error("Error saving wallet data", e);
                }
            }
            
            // Check wallet status on page load
            function checkWalletStatus() {
                if (wallet.masterPrivateKey) {
                    initializeWalletBtn.disabled = true;
                    initializeWalletBtn.title = "Wallet already created";
                }
            }
            
            // Check connection status (online/offline)
            function checkConnectionStatus() {
                const connectionStatus = document.getElementById('connectionStatus');
                const connectionStatusText = document.getElementById('connectionStatusText');
                
                // First, update the status based on navigator.onLine
                updateConnectionUI(navigator.onLine);
                
                // Then, try to perform a more accurate check by fetching a remote resource
                // This is a more reliable way to detect true connectivity
                if (navigator.onLine) {
                    // Create a unique URL to prevent caching
                    const testUrl = 'https://www.google.com/favicon.ico?_=' + new Date().getTime();
                    
                    // Set a short timeout to avoid blocking the UI if network is slow
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Timeout')), 3000);
                    });
                    
                    // Try to fetch a small resource
                    Promise.race([
                        fetch(testUrl, { method: 'HEAD', mode: 'no-cors', cache: 'no-store' }),
                        timeoutPromise
                    ])
                    .then(() => {
                        // If successful, we're definitely online
                        updateConnectionUI(true);
                    })
                    .catch(error => {
                        // If there's an error fetching, we might be offline or behind a firewall
                        if (error.message === 'Timeout') {
                            // Still showing as online but slow/unreliable
                            updateConnectionUI(true, 'slow');
                        } else {
                            // Probably offline or blocked - show as offline
                            updateConnectionUI(false);
                        }
                    });
                }
            }
            
            // Helper to update the connection status UI (removed - no longer showing warnings)
            function updateConnectionUI(isOnline, connectionQuality = 'normal') {
                // Function kept for compatibility but no longer displays warnings
                // Connection status is now shown only in the connection indicator
            }
            
            // Set up event listeners for online/offline status
            window.addEventListener('online', checkConnectionStatus);
            window.addEventListener('offline', checkConnectionStatus);
            
            // Check connection status immediately
            checkConnectionStatus();
            
            // Periodically check connection status (every 60 seconds)
            setInterval(checkConnectionStatus, 60000);
            
            // Load wallet data and do initial check
            loadWalletData();
            
            // Initialize broadcast queue
            initBroadcastQueue();
            
            // Check for cached scan data and start lazy rescan
            checkAndLoadCachedScanData();
            
            // ===== ELECTRUM RPC CLIENT =====
            
            // WebSocket connection for Electrum protocol
            let electrumSocket = null;
            let electrumRequestId = 1;
            let electrumCallbacks = {};
            // electrumConnected already declared at top
            let currentScriptHashSubscription = null;
            let headerSubscriptionActive = false;

            // ===== AUTOMATIC RECONNECTION SYSTEM =====
            // State machine: disconnected  connecting  connected
            //                                               
            //                      reconnecting 
            //
            // States:
            // - disconnected: No connection, Connect button visible
            // - connecting: Initial connection attempt in progress
            // - connected: Successfully connected, Disconnect button visible
            // - reconnecting: Auto-retry every 5s, Reconnecting button visible (cancels on click)
            //
            // Behavior:
            // - Connect button clicked  enter 'connecting' state, attempt connection
            // - Connection succeeds  enter 'connected' state, stop reconnection timer
            // - Connection lost while 'connected'  enter 'reconnecting' state, retry every 5s
            // - Disconnect clicked while 'connected'  enter 'disconnected' state
            // - Reconnecting button clicked  cancel reconnection, enter 'disconnected' state

            let reconnectionState = 'disconnected'; // 'disconnected', 'connecting', 'connected', 'reconnecting'
            let reconnectionTimer = null;
            let reconnectionAttempts = 0;
            const RECONNECTION_INTERVAL = 5000; // 5 seconds

            // Update connection button UI based on state
            function updateConnectionButton() {
                const connectBtn = document.getElementById('connectRpcBtn');
                const disconnectBtn = document.getElementById('disconnectRpcBtn');

                if (reconnectionState === 'connected') {
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = 'inline-flex';
                    disconnectBtn.style.backgroundColor = '#ff006e';
                    disconnectBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M18 6 6 18"></path>
                            <path d="m6 6 12 12"></path>
                        </svg>
                        Disconnect
                    `;
                } else if (reconnectionState === 'reconnecting') {
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = 'inline-flex';
                    disconnectBtn.style.backgroundColor = '#ffba08';
                    disconnectBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M18 6 6 18"></path>
                            <path d="m6 6 12 12"></path>
                        </svg>
                        Reconnecting... (Cancel)
                    `;
                } else if (reconnectionState === 'connecting') {
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = 'inline-flex';
                    disconnectBtn.style.backgroundColor = '#6c757d';
                    disconnectBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polyline points="12 6 12 12 16 14"></polyline>
                        </svg>
                        Connecting...
                    `;
                } else { // disconnected
                    connectBtn.style.display = 'inline-flex';
                    disconnectBtn.style.display = 'none';
                }
            }

            // Start automatic reconnection attempts
            function startReconnection() {
                // Clear any existing reconnection timer
                if (reconnectionTimer) {
                    clearTimeout(reconnectionTimer);
                    reconnectionTimer = null;
                }

                reconnectionState = 'reconnecting';
                updateConnectionButton();

                console.log(`Starting reconnection attempts (attempt ${reconnectionAttempts + 1})`);

                // Attempt to reconnect
                reconnectionTimer = setTimeout(() => {
                    reconnectionAttempts++;
                    console.log(`Reconnection attempt ${reconnectionAttempts}`);
                    connectToElectrum(true); // silent mode

                    // If still in reconnecting state after connection attempt, schedule next attempt
                    if (reconnectionState === 'reconnecting') {
                        startReconnection();
                    }
                }, RECONNECTION_INTERVAL);
            }

            // Stop automatic reconnection
            function stopReconnection() {
                if (reconnectionTimer) {
                    clearTimeout(reconnectionTimer);
                    reconnectionTimer = null;
                }
                reconnectionAttempts = 0;
                console.log('Stopped reconnection attempts');
            }

            // Helper function to subscribe to address changes
            function subscribeToAddressChanges(address) {
                if (!electrumConnected || !address) return;
                
                const scriptHash = addressToScriptHash(address);
                if (!scriptHash) return;
                
                // Unsubscribe from previous address if any
                if (currentScriptHashSubscription && currentScriptHashSubscription !== scriptHash) {
                    electrumRequest('blockchain.scripthash.unsubscribe', [currentScriptHashSubscription], function(result) {
                        console.log('Unsubscribed from previous address:', result);
                    });
                }
                
                // Subscribe to new address
                electrumRequest('blockchain.scripthash.subscribe', [scriptHash], function(result) {
                    // Successfully subscribed to address changes
                    currentScriptHashSubscription = scriptHash;
                });
            }
            
            // Helper function to unsubscribe from current address
            function unsubscribeFromAddressChanges() {
                if (currentScriptHashSubscription && electrumConnected) {
                    electrumRequest('blockchain.scripthash.unsubscribe', [currentScriptHashSubscription], function(result) {
                        console.log('Unsubscribed from address:', result);
                        currentScriptHashSubscription = null;
                    });
                }
            }
            
            // RPC UI elements
            const connectRpcBtn = document.getElementById('connectRpcBtn');
            const disconnectRpcBtn = document.getElementById('disconnectRpcBtn');
            const rpcServerInput = document.getElementById('rpcServer');
            const connectionStatusDiv = document.getElementById('connectionStatus');
            const connectionStatusText = document.getElementById('connectionStatusText');
            // const balanceDisplay = document.getElementById('balanceDisplay'); // Removed duplicate balance display
            // const balanceAmount = document.getElementById('balanceAmount'); // Removed duplicate balance display
            // const transactionList = document.getElementById('transactionList'); // Removed duplicate transaction display
            // const refreshBalanceBtn = document.getElementById('refreshBalanceBtn'); // Removed duplicate balance display
            
            // Connect to Electrum server
            function connectToElectrum(silent = false) {
                const serverUrl = rpcServerInput.value.trim();

                if (!serverUrl) {
                    if (!silent) alert('Please enter a Fulcrum server URL');
                    return;
                }

                // CRITICAL FIX: Check if we already have an active or connecting socket
                if (electrumSocket) {
                    const state = electrumSocket.readyState;

                    // If already connected or connecting, don't create a new socket
                    if (state === WebSocket.OPEN) {
                        console.log('Already connected to Fulcrum server');
                        if (!silent) {
                            showInAppNotification('Already Connected', 'Already connected to Fulcrum server', 'info');
                        }
                        return;
                    }

                    if (state === WebSocket.CONNECTING) {
                        console.log('Connection already in progress');
                        if (!silent) {
                            showInAppNotification('Connecting', 'Connection already in progress', 'info');
                        }
                        return;
                    }

                    // If socket exists but is CLOSING or CLOSED, clean it up first
                    if (state === WebSocket.CLOSING || state === WebSocket.CLOSED) {
                        console.log('Cleaning up old socket before creating new connection');
                        try {
                            // Remove event handlers to prevent any stale callbacks
                            electrumSocket.onopen = null;
                            electrumSocket.onmessage = null;
                            electrumSocket.onerror = null;
                            electrumSocket.onclose = null;
                            electrumSocket.close();
                        } catch (e) {
                            console.warn('Error closing old socket:', e);
                        }
                        electrumSocket = null;
                    }
                }

                // Update state to connecting (unless we're already in reconnecting mode)
                if (reconnectionState !== 'reconnecting') {
                    reconnectionState = 'connecting';
                    updateConnectionButton();
                }
                // If we're in reconnecting mode, keep that state so onclose knows to continue retrying

                // Show connecting status
                connectionStatusDiv.style.display = 'block';
                connectionStatusText.textContent = 'Connecting to ' + serverUrl + '...';

                try {
                    electrumSocket = new WebSocket(serverUrl);
                    
                    electrumSocket.onopen = function() {
                        electrumConnected = true;

                        // Update reconnection state to connected and stop any reconnection attempts
                        reconnectionState = 'connected';
                        stopReconnection();
                        updateConnectionButton();

                        updateUtxoListDisplay(); // Update UTXO list display when connected
                        const infoBox = connectionStatusDiv.querySelector('.info-box');
                        if (infoBox) {
                            infoBox.style.backgroundColor = 'rgba(6, 214, 160, 0.1)';
                            infoBox.style.borderLeftColor = 'var(--success-color)';
                        }

                        const reconnectMsg = reconnectionAttempts > 0 ? ` (after ${reconnectionAttempts} attempts)` : '';
                        reconnectionAttempts = 0;
                        connectionStatusText.textContent = 'Connected to Fulcrum server' + reconnectMsg;
                        showInAppNotification('Connected', 'Successfully connected to Fulcrum server', 'success');

                        rpcServerInput.disabled = true;
                        
                        // Resume broadcast queue if needed
                        if (broadcastQueue.length > 0 && !isQueueProcessing) {
                            console.log('Connection established, resuming broadcast queue');
                            processQueue();
                        }
                        
                        // Show balance display
                        // balanceDisplay.style.display = 'block'; // Removed duplicate balance display
                        
                        // Subscribe to headers for new blocks
                        electrumRequest('blockchain.headers.subscribe', [], function(result) {
                            // Successfully subscribed to block headers
                            headerSubscriptionActive = true;
                            if (result && (result.height || result.block_height)) {
                                currentBlockHeight = result.height || result.block_height;
                                // Get the actual block header to extract timestamp
                                electrumRequest('blockchain.block.header', [currentBlockHeight], function(headerHex) {
                                    if (headerHex) {
                                        // Parse block header to get timestamp (bytes 68-71)
                                        // Bitcoin block header timestamp is at bytes 68-71 (little-endian)
                                        const timestampBytes = headerHex.substr(68 * 2, 8).match(/.{2}/g).reverse().join('');
                                        currentBlockTime = new Date(parseInt(timestampBytes, 16) * 1000);
                                        console.log(`Block ${currentBlockHeight} timestamp: ${currentBlockTime.toISOString()}`);
                                    }
                                    updateCommonBalance();
                                });
                            }
                        });
                        
                        // Subscribe to current address if available
                        const currentAddress = wallet.addresses && wallet.addresses.length > 0 ? 
                            wallet.addresses[0].address : watchOnlyAddressValue;
                        if (currentAddress) {
                            subscribeToAddressChanges(currentAddress);
                        }
                        
                        // Refresh balance on connect  
                        refreshBalance();
                        
                        // After initial load, allow notifications
                        setTimeout(() => {
                            isInitialLoad = false;
                        }, 2000);
                        
                        // Update import button state
                        updateCommonBalance();
                        
                        // Start polling for new blocks
                        startBlockPolling();
                        
                        // Start lazy rescan if we have scanned wallets data
                        if (lastScannedWalletData && lastScannedWalletData.wallets && lastScannedWalletData.wallets.length > 0) {
                            startLazyRescan();
                        }
                        
                        // Get server version
                        electrumRequest('server.version', ['Unicity Wallet', '1.4'], function(result) {
                            console.log('Server version:', result);
                        });
                        
                        // If we have an address, get its balance
                        if (wallet.addresses && wallet.addresses.length > 0) {
                            refreshBalance();
                        }
                    };
                    
                    electrumSocket.onmessage = function(event) {
                        try {
                            const response = JSON.parse(event.data);
                            
                            // Handle normal responses
                            if (response.id && electrumCallbacks[response.id]) {
                                const callback = electrumCallbacks[response.id];
                                delete electrumCallbacks[response.id];

                                if (response.error) {
                                    console.error('Electrum error:', response.error);
                                    callback(null, response.error);
                                } else {
                                    callback(response.result);
                                }
                            }
                            
                            // Handle subscription notifications (no id field)
                            else if (response.method && response.params) {
                                if (response.method === 'blockchain.headers.subscribe') {
                                    // New block header notification
                                    const header = response.params[0];
                                    if (header) {
                                        const newHeight = header.height || header.block_height;
                                        console.log('New block detected via subscription:', newHeight);
                                        
                                        // Update block height and timestamp
                                        currentBlockHeight = newHeight;
                                        const timestampHex = header.hex.substring(136, 144);
                                        const timestamp = parseInt(timestampHex.match(/../g).reverse().join(''), 16);
                                        currentBlockTime = new Date(timestamp * 1000);
                                        
                                        // Update UI and refresh data
                                        updateCommonBalance();
                                        
                                        // Handle new block for broadcast queue
                                        onNewBlock();
                                        
                                        // Refresh appropriate balance
                                        if (watchOnlyMode && watchOnlyAddressValue) {
                                            refreshWatchOnlyBalance(watchOnlyAddressValue);
                                        } else {
                                            refreshBalance();
                                        }
                                        
                                        // Always update transaction history to refresh confirmation counts
                                        updateTransactionHistory();
                                        
                                        // Also update UTXO list to refresh confirmation counts
                                        updateUtxoListDisplay();
                                        
                                        // Don't show notification for new blocks - too frequent and redundant
                                    }
                                }
                                else if (response.method === 'blockchain.scripthash.subscribe') {
                                    // Address status changed notification
                                    const scriptHash = response.params[0];
                                    const status = response.params[1];
                                    console.log('Address status changed:', scriptHash, status);

                                    // Show spinner while re-fetching
                                    const spinner = document.getElementById('balanceVerificationSpinner');
                                    if (spinner) spinner.style.display = 'inline';

                                    // Re-fetch Fulcrum direct balance for verification
                                    const currentAddress = getCurrentVestingAddress();
                                    if (currentAddress) {
                                        fetchFulcrumDirectBalance(currentAddress);
                                    }

                                    // Refresh balance and transactions immediately
                                    if (watchOnlyMode && watchOnlyAddressValue) {
                                        refreshWatchOnlyBalance(watchOnlyAddressValue);
                                    } else {
                                        refreshBalance();
                                    }

                                    // Don't show notification for address activity - too frequent
                                }
                            }
                        } catch (err) {
                            console.error('Error parsing Electrum response:', err);
                        }
                    };
                    
                    electrumSocket.onerror = function(error) {
                        console.error('WebSocket error:', error);
                        const infoBox = connectionStatusDiv.querySelector('.info-box');
                        if (infoBox) {
                            infoBox.style.backgroundColor = 'rgba(255, 0, 110, 0.1)';
                            infoBox.style.borderLeftColor = 'var(--danger-color)';
                        }
                        if (silent) {
                            connectionStatusText.textContent = 'Unable to auto-connect. Click connect to try manually.';
                            setTimeout(() => {
                                connectionStatusDiv.style.display = 'none';
                            }, 3000);
                        } else {
                            connectionStatusText.textContent = 'Connection error: Check console for details';
                            showInAppNotification('Connection Error', 'Failed to connect to Fulcrum server', 'error');
                        }
                    };
                    
                    electrumSocket.onclose = function(event) {
                        // CRITICAL FIX: Clear the socket reference to prevent stale connections
                        electrumSocket = null;
                        electrumConnected = false;
                        serverProvidesVesting = false;
                        fulcrumDirectBalance = 0n;
                        balanceRetryCount = 0;
                        currentScriptHashSubscription = null;
                        headerSubscriptionActive = false;
                        isInitialLoad = true;  // Reset for next connection
                        updateUtxoListDisplay(); // Update UTXO list display when disconnected
                        updateCommonBalance(); // Update button states
                        const infoBox = connectionStatusDiv.querySelector('.info-box');
                        if (infoBox) {
                            infoBox.style.backgroundColor = 'rgba(255, 186, 8, 0.1)';
                            infoBox.style.borderLeftColor = '#ffba08';
                        }

                        // Clear lazy scan interval
                        if (lazyScanInterval) {
                            clearInterval(lazyScanInterval);
                            lazyScanInterval = null;
                        }

                        // Determine if this was an unexpected disconnect or manual disconnect
                        const wasConnected = reconnectionState === 'connected';
                        const wasReconnecting = reconnectionState === 'reconnecting';
                        const wasConnecting = reconnectionState === 'connecting';

                        // If we were connected and connection was lost unexpectedly, start reconnection
                        if (wasConnected) {
                            console.log('Connection lost unexpectedly, starting automatic reconnection');
                            connectionStatusText.textContent = 'Connection lost - Reconnecting...';
                            startReconnection();
                        } else if (wasReconnecting) {
                            // If we were in reconnecting mode and this attempt failed
                            // The timer is already scheduled, just update UI
                            console.log('Reconnection attempt failed, timer will retry');
                            connectionStatusText.textContent = 'Connection failed - Retrying in 5s...';
                            reconnectionState = 'reconnecting';
                            updateConnectionButton();
                        } else if (wasConnecting) {
                            // If we were in connecting state (initial connect attempt)
                            // This likely came from manual connect or initial failed connection
                            // Check if we should enter reconnection mode
                            if (reconnectionTimer) {
                                // We have a reconnection timer running, stay in reconnecting mode
                                console.log('Connection attempt failed during reconnection cycle');
                                reconnectionState = 'reconnecting';
                                updateConnectionButton();
                                connectionStatusText.textContent = 'Connection failed - Retrying in 5s...';
                            } else {
                                // No reconnection timer, this was a one-off connection attempt
                                reconnectionState = 'disconnected';
                                updateConnectionButton();
                                connectionStatusText.textContent = 'Connection failed';
                                rpcServerInput.disabled = false;
                            }
                        } else {
                            // Manual disconnect or already disconnected
                            reconnectionState = 'disconnected';
                            updateConnectionButton();
                            connectionStatusText.textContent = 'Disconnected from server';
                            rpcServerInput.disabled = false;
                        }

                        // Hide balance display
                        // balanceDisplay.style.display = 'none'; // Removed duplicate balance display
                    };
                    
                } catch (err) {
                    if (!silent) {
                        showInAppNotification('Connection Failed', err.message, 'error');
                    }
                    const infoBox = connectionStatusDiv.querySelector('.info-box');
                    if (infoBox) {
                        infoBox.style.backgroundColor = 'rgba(255, 0, 110, 0.1)';
                        infoBox.style.borderLeftColor = 'var(--danger-color)';
                    }
                    if (silent) {
                        connectionStatusText.textContent = 'Auto-connect unavailable';
                        setTimeout(() => {
                            connectionStatusDiv.style.display = 'none';
                        }, 3000);
                    } else {
                        connectionStatusText.textContent = 'Failed to connect: ' + err.message;
                    }
                }
            }
            
            // Disconnect from Electrum server
            function disconnectFromElectrum() {
                // Check current state to determine behavior
                if (reconnectionState === 'reconnecting') {
                    // If in reconnecting state, clicking button should cancel reconnection
                    console.log('Canceling reconnection attempts');
                    stopReconnection();
                    reconnectionState = 'disconnected';
                    updateConnectionButton();
                    connectionStatusText.textContent = 'Reconnection canceled';
                    showInAppNotification('Canceled', 'Reconnection attempts canceled', 'info');
                    return;
                }

                // Manual disconnect from connected/connecting state
                console.log('Manual disconnect requested');

                // Stop any reconnection attempts
                stopReconnection();

                // Set state to disconnected BEFORE closing socket
                // This prevents the onclose handler from starting reconnection
                reconnectionState = 'disconnected';

                if (electrumSocket) {
                    // CRITICAL FIX: Remove event handlers before closing to prevent reconnection loops
                    try {
                        electrumSocket.onopen = null;
                        electrumSocket.onmessage = null;
                        electrumSocket.onerror = null;
                        electrumSocket.onclose = null;
                        electrumSocket.close();
                    } catch (e) {
                        console.warn('Error during socket cleanup:', e);
                    }
                    electrumSocket = null;
                    showInAppNotification('Disconnected', 'Manually disconnected from Fulcrum server', 'info');
                }

                electrumConnected = false;
                serverProvidesVesting = false;
                fulcrumDirectBalance = 0n;
                balanceRetryCount = 0;
                electrumCallbacks = {};
                updateUtxoListDisplay(); // Update UTXO list display when disconnected

                // Stop polling
                stopBlockPolling();

                // Clear lazy scan interval
                if (lazyScanInterval) {
                    clearInterval(lazyScanInterval);
                    lazyScanInterval = null;
                }

                // Update UI
                updateConnectionButton();
                updateCommonBalance();
                connectionStatusText.textContent = 'Disconnected from server';
                rpcServerInput.disabled = false;
            }
            
            // Make an Electrum RPC request
            function electrumRequest(method, params, callback) {
                if (!electrumConnected || !electrumSocket) {
                    console.error('Not connected to Electrum server');
                    if (callback) callback(null, 'Not connected');
                    return;
                }
                
                const id = electrumRequestId++;
                const request = {
                    id: id,
                    method: method,
                    params: params || []
                };
                
                if (callback) {
                    electrumCallbacks[id] = callback;
                }
                
                try {
                    electrumSocket.send(JSON.stringify(request) + '\n');
                } catch (err) {
                    console.error('Error sending request:', err);
                    if (callback) callback(null, err.message);
                }
            }
            
            // Convert Bech32 address to script hash for Electrum protocol
            function addressToScriptHash(address) {
                try {
                    // Decode the bech32 address to get the witness program
                    const decoded = decodeBech32(address);
                    if (!decoded) {
                        console.error('Failed to decode address:', address);
                        return null;
                    }
                    
                    const witnessVersion = decoded.witnessVersion;
                    const witnessProgram = decoded.data;
                    
                    // Create the scriptPubKey for P2WPKH (witness version 0, 20 bytes)
                    // Format: OP_0 (0x00) + push_20_bytes (0x14) + witness_program
                    let scriptPubKey = [];
                    
                    // Add witness version (OP_0 for version 0, or OP_1-OP_16 for versions 1-16)
                    if (witnessVersion === 0) {
                        scriptPubKey.push(0x00);
                    } else {
                        scriptPubKey.push(0x50 + witnessVersion); // OP_1 = 0x51, OP_2 = 0x52, etc.
                    }
                    
                    // Add push opcode for the witness program length
                    scriptPubKey.push(witnessProgram.length);
                    
                    // Add the witness program
                    scriptPubKey = scriptPubKey.concat(witnessProgram);
                    
                    // Convert to hex string for hashing
                    const scriptHex = scriptPubKey.map(b => b.toString(16).padStart(2, '0')).join('');
                    
                    // Hash the script with SHA256
                    const hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(scriptHex));
                    const hashBytes = CryptoJS.enc.Hex.stringify(hash);
                    
                    // Reverse the bytes for Electrum (little-endian)
                    let reversed = '';
                    for (let i = hashBytes.length - 2; i >= 0; i -= 2) {
                        reversed += hashBytes.substr(i, 2);
                    }
                    
                    return reversed;
                } catch (err) {
                    console.error('Error converting address to script hash:', err);
                    return null;
                }
            }
            
            // Decode Bech32 address to get witness version and program
            function decodeBech32(address) {
                try {
                    // Normalize address to lowercase for Bech32 processing
                    address = address.toLowerCase();
                    
                    // Find the separator '1'
                    const pos = address.lastIndexOf('1');
                    if (pos < 1) return null;
                    
                    const hrp = address.substring(0, pos);
                    const data = address.substring(pos + 1);
                    
                    // Decode the data part
                    const decoded = [];
                    for (let i = 0; i < data.length; i++) {
                        const d = CHARSET.indexOf(data.charAt(i));
                        if (d === -1) return null;
                        decoded.push(d);
                    }
                    
                    // Verify checksum (last 6 characters)
                    if (!verifyBech32Checksum(hrp, decoded)) {
                        console.error('Invalid bech32 checksum');
                        return null;
                    }
                    
                    // Remove checksum
                    const values = decoded.slice(0, -6);
                    
                    // First value is witness version
                    const witnessVersion = values[0];
                    
                    // Convert from 5-bit to 8-bit
                    const witnessProgram = convertBits(values.slice(1), 5, 8, false);
                    
                    return {
                        hrp: hrp,
                        witnessVersion: witnessVersion,
                        data: witnessProgram
                    };
                } catch (err) {
                    console.error('Error decoding bech32:', err);
                    return null;
                }
            }
            
            // Verify Bech32 checksum
            function verifyBech32Checksum(hrp, data) {
                const values = hrpExpand(hrp).concat(data);
                return bech32Polymod(values) === 1;
            }
            
            // Refresh balance for current address
            function refreshBalance() {
                let address = null;
                
                if (watchOnlyMode && watchOnlyAddressValue) {
                    address = watchOnlyAddressValue;
                } else if (wallet.addresses && wallet.addresses.length > 0) {
                    address = wallet.addresses[0].address;
                } else {
                    // No address available
                    return;
                }
                
                const scriptHash = addressToScriptHash(address);
                
                if (!scriptHash) {
                    // balanceAmount.textContent = 'Error: Invalid address format'; // Removed duplicate balance display
                    console.error('Failed to convert address to script hash');
                    return;
                }
                
                // balanceAmount.textContent = 'Loading...'; // Removed duplicate balance display
                // Debug logs removed
                
                // Get script hash balance (using blockchain.scripthash.get_balance)
                electrumRequest('blockchain.scripthash.get_balance', [scriptHash], function(result, error) {
                    if (error) {
                        // balanceAmount.textContent = 'Error loading balance'; // Removed duplicate balance display
                        console.error('Balance error:', error);
                        return;
                    }
                    
                    if (result) {
                        const confirmed = result.confirmed || 0;
                        const unconfirmed = result.unconfirmed || 0;
                        const total = confirmed + unconfirmed;
                        
                        // Convert from satoshis to ALPHA (1 ALPHA = 100,000,000 satoshis)
                        const alphaBalance = SatoshiMath.satoshisToAlpha(total);
                        // balanceAmount.textContent = alphaBalance + ' ALPHA'; // Removed duplicate balance display
                        
                        if (unconfirmed > 0) {
                            const unconfirmedAlpha = SatoshiMath.satoshisToAlpha(unconfirmed);
                            // balanceAmount.innerHTML += '<br><small style="color: #999;">(' + unconfirmedAlpha + ' unconfirmed)</small>'; // Removed duplicate balance display
                        }
                    }
                });
                
                // Get transaction history (using blockchain.scripthash.get_history)
                electrumRequest('blockchain.scripthash.get_history', [scriptHash], function(result, error) {
                    if (error) {
                        // transactionList.innerHTML = '<p style="color: #999; text-align: center;">Error loading transactions</p>'; // Removed duplicate transaction display
                        return;
                    }
                    
                    if (result && result.length > 0) {
                        // transactionList.innerHTML = ''; // Removed duplicate transaction display
                        
                        // Show last 10 transactions
                        const recentTxs = result.slice(-10).reverse();
                        
                        recentTxs.forEach(function(tx) {
                            const txDiv = document.createElement('div');
                            txDiv.style.cssText = 'padding: 10px; border-bottom: 1px solid #e9ecef; font-size: 14px;';
                            
                            const txId = tx.tx_hash || tx.txid;
                            const height = tx.height;
                            
                            txDiv.innerHTML = `
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="font-family: monospace; font-size: 12px; color: #666;">
                                            ${txId.substring(0, 8)}...${txId.substring(txId.length - 8)}
                                        </div>
                                        <div style="color: #999; font-size: 12px; margin-top: 2px;">
                                            ${height > 0 ? 'Block ' + height : 'Unconfirmed'}
                                            <span class="legacy-tx-timestamp" data-height="${height}" data-txid="${txId}"></span>
                                        </div>
                                    </div>
                                    <button class="small-button" onclick="navigator.clipboard.writeText('${txId}').then(() => alert('Transaction ID copied!'));" title="Copy transaction ID">
                                        Copy
                                    </button>
                                </div>
                            `;
                            
                            // transactionList.appendChild(txDiv); // Removed duplicate transaction display
                        });
                    } else {
                        // transactionList.innerHTML = '<p style="color: #999; text-align: center;">No transactions found</p>'; // Removed duplicate transaction display
                    }
                });
            }
            
            // Event listeners for RPC buttons
            // Connect button handler - starts reconnection mode
            connectRpcBtn.onclick = function() {
                // When clicking connect from disconnected state, go to reconnecting mode
                console.log('Connect button clicked - starting reconnection mode');
                reconnectionState = 'connecting';
                updateConnectionButton();
                connectToElectrum(false); // Not silent, show notifications

                // If connection fails, enter reconnecting mode
                setTimeout(() => {
                    if (reconnectionState === 'connecting' && !electrumConnected) {
                        startReconnection();
                    }
                }, 3000); // Give initial connection 3 seconds
            };

            // Disconnect/Cancel button handler
            disconnectRpcBtn.onclick = disconnectFromElectrum;
            // refreshBalanceBtn.onclick = refreshBalance; // Removed duplicate balance display
            
            // Auto-connect to default endpoint on page load
            function tryAutoConnect() {
                const defaultEndpoint = 'wss://fulcrum.unicity.network:50004';
                
                // Only auto-connect if we're not already connected and the input has the default value
                if (!electrumConnected && rpcServerInput.value === defaultEndpoint) {
                    // Show a subtle notification that we're attempting to connect
                    connectionStatusDiv.style.display = 'block';
                    connectionStatusText.textContent = 'Auto-connecting to Unicity network...';
                    
                    // Attempt to connect silently
                    setTimeout(() => {
                        connectToElectrum(true); // Pass true for silent mode
                    }, 500); // Small delay to ensure UI is ready
                }
            }
            
            // Call auto-connect when page loads
            setTimeout(tryAutoConnect, 1000); // Wait 1 second after page load
            
            // Auto-refresh balance when address is generated
            const originalGenerateNewAddress = window.generateNewAddress;
            window.generateNewAddress = function() {
                originalGenerateNewAddress();
                if (electrumConnected) {
                    // Clear previous address data
                    currentTransactions = [];
                    currentUtxos = [];
                    // Reset pagination
                    currentTransactionPage = 1;
                    currentUtxoPage = 1;
                    updateTransactionHistory();
                    updateUtxoListDisplay();
                    
                    setTimeout(() => {
                        refreshBalance();
                        // Subscribe to the new address
                        if (wallet.addresses && wallet.addresses.length > 0) {
                            subscribeToAddressChanges(wallet.addresses[0].address);
                            // Reset initial load flag when address changes
                            isInitialLoad = true;
                            setTimeout(() => {
                                isInitialLoad = false;
                            }, 2000);
                        }
                    }, 500);
                }
            };
            
            // ===== UTXO EXPORT/IMPORT FUNCTIONALITY =====
            
            // Store for offline UTXO data
            // offlineUtxoData already declared at top
            // currentUtxos already declared at top
            // currentTransactions already declared at top
            let transactionDetailsCache = {}; // Cache for transaction details
            let isInitialLoad = true;  // Track if this is the first load
            
            // Pagination state
            const ITEMS_PER_PAGE = 20;
            // currentTransactionPage and currentUtxoPage already declared at top
            // lastUpdateBlockHeight, currentBlockHeight and currentBlockTime already declared at top
            let blockPollInterval = null;
            
            // Export button element
            const exportUtxoBtn = document.getElementById('exportUtxoBtn');
            // importUtxoBtn is declared at the top with other elements
            // clearUtxoBtn is declared at the top with other elements
            const utxoFileInput = document.getElementById('utxoFileInput');
            // const offlineBalanceDisplay = document.getElementById('offlineBalanceDisplay'); // Removed with Cold Wallet reorganization
            // const offlineBalanceAmount = document.getElementById('offlineBalanceAmount'); // Removed with Cold Wallet reorganization
            // const offlineDataTimestamp = document.getElementById('offlineDataTimestamp'); // Removed with Cold Wallet reorganization
            // const offlineUtxoList = document.getElementById('offlineUtxoList'); // Removed with Cold Wallet reorganization
            
            // Update watch-only mode based on wallet and connection state
            function updateWatchOnlyMode() {
                const hasWallet = wallet.masterPrivateKey || (wallet.addresses && wallet.addresses.length > 0);
                const shouldShowWatchOnly = !hasWallet && electrumConnected;
                const wasInWatchOnlyMode = watchOnlyMode;
                
                if (shouldShowWatchOnly) {
                    watchOnlySection.style.display = 'block';
                    walletInfo.style.display = 'none';
                    watchOnlyMode = true;
                    // Only clear data when actually switching TO watch-only mode from wallet mode
                    if (!wasInWatchOnlyMode) {
                        currentTransactions = [];
                        currentUtxos = [];
                        // Reset pagination
                        currentTransactionPage = 1;
                        currentUtxoPage = 1;
                        updateTransactionHistory();
                        updateUtxoListDisplay();
                    }
                } else if (hasWallet) {
                    watchOnlySection.style.display = 'none';
                    walletInfo.style.display = 'block';
                    watchOnlyMode = false;
                    watchOnlyAddressValue = null;
                    
                    // Clear watch-only data when switching to wallet mode
                    if (watchOnlyMode) {
                        currentTransactions = [];
                        currentUtxos = [];
                        // Reset pagination
                        currentTransactionPage = 1;
                        currentUtxoPage = 1;
                        updateTransactionHistory();
                        updateUtxoListDisplay();
                    }
                    
                    // Subscribe to wallet address if connected
                    if (electrumConnected && wallet.addresses && wallet.addresses.length > 0) {
                        subscribeToAddressChanges(wallet.addresses[0].address);
                    }
                } else {
                    // Not connected and no wallet
                    watchOnlySection.style.display = 'none';
                    walletInfo.style.display = 'none';
                    watchOnlyMode = false;
                    watchOnlyAddressValue = null;
                    
                    // Clear data
                    currentTransactions = [];
                    currentUtxos = [];
                    // Reset pagination
                    currentTransactionPage = 1;
                    currentUtxoPage = 1;
                    
                    // Unsubscribe if connected
                    if (electrumConnected) {
                        unsubscribeFromAddressChanges();
                    }
                }
            }
            
            // Handle watch-only address input
            watchOnlyAddress.addEventListener('input', function(e) {
                const address = e.target.value.trim();
                
                // Validate Bech32 address format
                if (address.startsWith('alpha1') && address.length > 10) {
                    // Debounce the input
                    clearTimeout(watchOnlyAddress.debounceTimer);
                    watchOnlyAddress.debounceTimer = setTimeout(() => {
                        // Validate address format properly
                        try {
                            const decoded = decodeBech32(address);
                            if (decoded) {
                                const oldAddress = watchOnlyAddressValue;
                                watchOnlyAddressValue = address;
                                refreshWatchOnlyBalance(address);
                                
                                // Update subscription if connected
                                if (electrumConnected && address !== oldAddress) {
                                    // Clear transaction history when address changes
                                    currentTransactions = [];
                                    currentUtxos = [];
                                    // Reset pagination
                                    currentTransactionPage = 1;
                                    currentUtxoPage = 1;
                                    // Update UI to clear the transaction list immediately
                                    updateTransactionHistory();
                                    updateUtxoListDisplay();
                                    
                                    // Subscribe to the new address
                                    subscribeToAddressChanges(address);
                                    // Reset initial load flag when address changes
                                    isInitialLoad = true;
                                    setTimeout(() => {
                                        isInitialLoad = false;
                                    }, 2000);
                                }
                                
                                // Show notification
                                showInAppNotification('Watch-Only Address Set', `Monitoring address: ${address.substring(0, 10)}...${address.substring(address.length - 6)}`, 'info');
                            }
                        } catch (err) {
                            console.log('Invalid address format:', err);
                            watchOnlyAddressValue = null;
                            watchOnlyBalance.textContent = 'Invalid address';
                            watchOnlyUnconfirmed.textContent = '';
                            currentUtxos = [];
                            updateUtxoListDisplay();
                        }
                    }, 500);
                } else if (address === '') {
                    watchOnlyAddressValue = null;
                    watchOnlyBalance.textContent = '-';
                    watchOnlyUnconfirmed.textContent = '';
                    currentUtxos = [];
                    currentTransactions = [];
                    // Reset pagination
                    currentTransactionPage = 1;
                    currentUtxoPage = 1;
                    updateUtxoListDisplay();
                    updateTransactionHistory();
                    
                    // Unsubscribe if connected
                    if (electrumConnected) {
                        unsubscribeFromAddressChanges();
                    }
                    
                    // Show notification
                    showInAppNotification('Watch-Only Cleared', 'Watch-only address has been cleared', 'info');
                }
            });
            
            // Refresh balance for watch-only address
            function refreshWatchOnlyBalance(address) {
                if (!address || !electrumConnected) return;
                
                const scriptHash = addressToScriptHash(address);
                if (!scriptHash) {
                    watchOnlyBalance.textContent = 'Invalid address';
                    watchOnlyUnconfirmed.textContent = '';
                    return;
                }
                
                // Fetch UTXOs
                electrumRequest('blockchain.scripthash.listunspent', [scriptHash], function(result) {
                    if (result !== null && result !== undefined) {
                        const newUtxos = result.map(utxo => ({
                            ...utxo,
                            address: address
                        }));

                        // Only reprocess if UTXOs actually changed (prevents flicker and redundant work)
                        const utxosChanged = hasUtxoArrayChanged(currentUtxos, newUtxos);
                        currentUtxos = newUtxos;

                        // Calculate balances using BigInt for precision
                        let confirmed = 0n;
                        let unconfirmed = 0n;

                        result.forEach(utxo => {
                            if (utxo.height > 0) {
                                confirmed += BigInt(utxo.value);
                            } else {
                                unconfirmed += BigInt(utxo.value);
                            }
                        });

                        // Update display - use Fulcrum's direct balance when available
                        const displayBalance = fulcrumDirectBalance > 0n ? fulcrumDirectBalance : confirmed;
                        watchOnlyBalance.textContent = SatoshiMath.satoshisToAlpha(displayBalance) + ' ALPHA';
                        if (unconfirmed > 0n) {
                            watchOnlyUnconfirmed.textContent = '(' + SatoshiMath.satoshisToAlpha(unconfirmed) + ')';
                        } else {
                            watchOnlyUnconfirmed.textContent = '';
                        }

                        updateUtxoListDisplay();
                        updateCommonBalance(); // This will update Send button state

                        // Only reprocess classification when UTXOs changed
                        if (utxosChanged) {
                            processIncomingUtxos(currentUtxos, address);
                        }
                    }
                });

                // Also fetch transaction history
                electrumRequest('blockchain.scripthash.get_history', [scriptHash], function(result) {
                    if (result !== null && result !== undefined) {
                        // Transaction history fetched successfully
                        // Analyze changes
                        const changes = analyzeTransactionChanges(currentTransactions, result);
                        
                        if (changes.hasChanged || currentTransactions.length === 0 || result.length === 0) {
                            // Update if changed OR if we have no transactions (after clearing) OR if result is empty
                            // Only show notifications if not initial load
                            if (!isInitialLoad && changes.newTransactions.length > 0) {
                                // Only show notifications for truly new unconfirmed transactions
                                // When a new tx arrives, we should only notify about that one
                                const unconfirmedNewTxs = changes.newTransactions.filter(tx => tx.height === 0);
                                
                                // If we have many new transactions, it's likely a data refresh issue
                                // Only notify if we have 1-2 new unconfirmed transactions
                                if (unconfirmedNewTxs.length <= 2) {
                                    unconfirmedNewTxs.forEach(tx => {
                                const txid = tx.tx_hash || tx.txid;
                                const shortTxid = txid.substring(0, 8) + '...' + txid.substring(txid.length - 8);
                                
                                // Fetch transaction details to determine direction
                                electrumRequest('blockchain.transaction.get', [txid, true], function(txDetails) {
                                    // Cache the transaction details
                                    if (txDetails) {
                                        transactionDetailsCache[txid] = txDetails;
                                    }
                                    
                                    let notificationTitle, notificationBody;
                                    
                                    if (txDetails && watchOnlyAddressValue) {
                                        const result = calculateTransactionAmount(txDetails, watchOnlyAddressValue);
                                        const amount = SatoshiMath.satoshisToAlpha(Math.abs(result.netAmount));
                                        
                                        if (result.isIncoming) {
                                            notificationTitle = tx.height === 0 ? 
                                                ' Incoming to Watched Address' : 
                                                ' Incoming Transaction Confirmed';
                                            notificationBody = `Received ${amount} ALPHA${tx.height > 0 ? ' in block ' + tx.height : ' (unconfirmed)'}`;
                                        } else {
                                            notificationTitle = tx.height === 0 ? 
                                                ' Outgoing from Watched Address' : 
                                                ' Outgoing Transaction Confirmed';
                                            notificationBody = `Sent ${amount} ALPHA${tx.height > 0 ? ' in block ' + tx.height : ' (unconfirmed)'}`;
                                        }
                                    } else {
                                        // Fallback if we can't get details
                                        notificationTitle = tx.height === 0 ? 
                                            ' New Transaction (Watched)' : 
                                            ' Transaction Confirmed (Watched)';
                                        notificationBody = `Transaction ${shortTxid}${tx.height > 0 ? ' in block ' + tx.height : ' detected'}`;
                                    }
                                    
                                    showNotification(notificationTitle, notificationBody);
                                });
                                    });
                                }
                            }
                            
                            // Show notifications for newly confirmed transactions (always show these)
                            if (!isInitialLoad && changes.confirmedTransactions.length > 0) {
                                changes.confirmedTransactions.forEach(tx => {
                                const txid = tx.tx_hash || tx.txid;
                                const shortTxid = txid.substring(0, 8) + '...' + txid.substring(txid.length - 8);
                                
                                showNotification(
                                    ' Transaction Confirmed',
                                    `Transaction ${shortTxid} confirmed in block ${tx.height}`
                                );
                                });
                            }
                            
                            currentTransactions = result;
                            updateTransactionHistory();
                        }
                    }
                });
            }
            
            // Update common balance display
            // Get list of UTXOs consumed by pending or complete transactions in queue
            function getConsumedUtxos() {
                const consumedUtxos = new Set();
                
                broadcastQueue.forEach(item => {
                    // Only consider pending, broadcasting, and complete transactions
                    if (item.status === 'pending' || item.status === 'broadcasting' || item.status === 'complete') {
                        // Add the consumed UTXO to the set
                        if (item.tx.input) {
                            consumedUtxos.add(`${item.tx.input.txid}:${item.tx.input.vout}`);
                        }
                    }
                });
                
                return consumedUtxos;
            }
            
            function updateCommonBalance() {
                let confirmedBalance = 0n;
                let unconfirmedBalance = 0n;
                let utxoSource = 'none';
                let blockHeight = currentBlockHeight || lastUpdateBlockHeight;
                let lastUpdate = currentBlockTime;

                // Get consumed UTXOs
                const consumedUtxos = getConsumedUtxos();

                // Calculate balances from UTXOs using BigInt for precision
                if (currentUtxos && currentUtxos.length > 0) {
                    currentUtxos.forEach(utxo => {
                        const utxoKey = `${utxo.txid}:${utxo.vout}`;
                        // Only count UTXO if it's not consumed
                        if (!consumedUtxos.has(utxoKey)) {
                            if (utxo.height > 0) {
                                confirmedBalance += BigInt(utxo.value);
                            } else {
                                unconfirmedBalance += BigInt(utxo.value);
                            }
                        }
                    });
                    utxoSource = 'online';
                    lastUpdateBlockHeight = currentBlockHeight;
                    // Use block time if available, otherwise current time
                    if (!lastUpdate) {
                        lastUpdate = new Date();
                    }
                } else if (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0) {
                    offlineUtxoData.utxos.forEach(utxo => {
                        const utxoKey = `${utxo.txid}:${utxo.vout}`;
                        // Only count UTXO if it's not consumed
                        if (!consumedUtxos.has(utxoKey)) {
                            if (utxo.height > 0) {
                                confirmedBalance += BigInt(utxo.value);
                            } else {
                                unconfirmedBalance += BigInt(utxo.value);
                            }
                        }
                    });
                    utxoSource = 'offline';
                    if (offlineUtxoData.blockHeight) {
                        lastUpdateBlockHeight = offlineUtxoData.blockHeight;
                        blockHeight = offlineUtxoData.blockHeight;
                    }
                    if (offlineUtxoData.timestamp) {
                        lastUpdate = new Date(offlineUtxoData.timestamp);
                    }
                }

                // Update wallet info display if it exists
                // Use Fulcrum's direct balance as authoritative total when available
                if (walletBalance) {
                    const displayBalance = fulcrumDirectBalance > 0n ? fulcrumDirectBalance : confirmedBalance;
                    walletBalance.textContent = `${SatoshiMath.satoshisToAlpha(displayBalance)} ALPHA`;
                }
                if (walletUnconfirmed) {
                    if (unconfirmedBalance > 0n) {
                        walletUnconfirmed.style.display = 'inline';
                        walletUnconfirmed.textContent = `(${SatoshiMath.satoshisToAlpha(unconfirmedBalance)})`;
                    } else {
                        walletUnconfirmed.style.display = 'none';
                    }
                }

                // Update total balance in scanned wallets if current address balance changed
                if (lastScannedWalletData && lastScannedWalletData.wallets && wallet && wallet.addresses && wallet.addresses.length > 0) {
                    const currentAddress = wallet.addresses[0].address;
                    const totalBalance = confirmedBalance + unconfirmedBalance;
                    
                    // Find and update the current wallet in scanned wallets
                    let walletUpdated = false;
                    let walletIndex = -1;
                    const totalBalanceNum = Number(totalBalance);  // Convert for storage
                    lastScannedWalletData.wallets.forEach((w, idx) => {
                        if (w.address === currentAddress) {
                            const oldBalance = w.balance || 0;
                            if (oldBalance !== totalBalanceNum) {
                                w.balance = totalBalanceNum;
                                walletUpdated = true;
                                walletIndex = idx;
                            }
                        }
                    });

                    if (walletUpdated) {
                        // Recalculate total balance by summing all individual balances using BigInt
                        let newTotalBalance = 0n;
                        lastScannedWalletData.wallets.forEach((w, idx) => {
                            if (w.balance > 0) {
                                newTotalBalance += BigInt(w.balance);
                            }
                        });
                        const oldTotal = lastScannedWalletData.totalBalance || 0;
                        lastScannedWalletData.totalBalance = Number(newTotalBalance);  // Convert for storage
                        
                        // Update cache only if we have master keys
                        if (lastScannedWalletData.masterKey) {
                            const fingerprint = generateWalletFingerprint(
                                lastScannedWalletData.masterKey,
                                lastScannedWalletData.masterChainCode
                            );
                            if (fingerprint) {
                                saveScanResultsToCache(fingerprint, lastScannedWalletData);
                            }
                        } else {
                            // Skip cache update if no master key available (e.g., watch-only mode)
                        }
                        
                        // Update display
                        updateScannedWalletsDisplay();
                    }
                }
                
                // Update last update time
                if (lastUpdateTime) {
                    if (blockHeight && lastUpdate) {
                        lastUpdateTime.textContent = `Block #${blockHeight} at ${lastUpdate.toLocaleString()}`;
                    } else if (blockHeight) {
                        lastUpdateTime.textContent = `Block #${blockHeight}`;
                    } else if (lastUpdate) {
                        lastUpdateTime.textContent = lastUpdate.toLocaleString();
                    } else {
                        lastUpdateTime.textContent = '-';
                    }
                }
                
                // Update old balance display elements for backwards compatibility
                const totalBalanceEl = document.getElementById('totalBalance');
                if (totalBalanceEl) {
                    totalBalanceEl.textContent = SatoshiMath.satoshisToAlpha(confirmedBalance + unconfirmedBalance);
                }
                
                const lastUpdateBlockEl = document.getElementById('lastUpdateBlock');
                if (lastUpdateBlockEl) {
                    if (lastUpdateBlockHeight) {
                        lastUpdateBlockEl.textContent = `Block ${lastUpdateBlockHeight}`;
                    } else {
                        lastUpdateBlockEl.textContent = 'Never';
                    }
                }
                
                const currentBlockHeightEl = document.getElementById('currentBlockHeight');
                if (currentBlockHeightEl && blockHeight) {
                    currentBlockHeightEl.textContent = blockHeight;
                }
                
                // Update import button state based on connection
                if (importUtxoBtn) {
                    importUtxoBtn.disabled = electrumConnected;
                    if (electrumConnected) {
                        importUtxoBtn.title = "UTXO imports are disabled while connected to Fulcrum";
                    } else {
                        importUtxoBtn.title = "Import UTXO data from file";
                    }
                }
                
                // Update import & broadcast button state based on connection
                const importBroadcastBtn = document.getElementById('importBroadcastBtn');
                if (importBroadcastBtn) {
                    importBroadcastBtn.disabled = !electrumConnected;
                    if (electrumConnected) {
                        importBroadcastBtn.title = "Import and broadcast signed transactions";
                    } else {
                        importBroadcastBtn.title = "Connect to Fulcrum to broadcast transactions";
                    }
                }
                
                // Update Send button state based on available UTXOs, wallet state, and watch-only mode
                if (sendTransactionBtn) {
                    const hasUtxos = (currentUtxos && currentUtxos.length > 0) || 
                                   (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0);
                    
                    const hasWallet = wallet.addresses && wallet.addresses.length > 0;
                    
                    // Disable if no UTXOs, or if in watch-only mode without UTXOs, or if no wallet and not watch-only
                    sendTransactionBtn.disabled = !hasUtxos || (!hasWallet && !watchOnlyMode);
                    
                    if (!hasWallet && !watchOnlyMode) {
                        sendTransactionBtn.title = "Please load a wallet or use watch-only mode";
                    } else if (watchOnlyMode && hasUtxos) {
                        sendTransactionBtn.title = "Prepare transaction for offline signing";
                    } else if (hasUtxos) {
                        sendTransactionBtn.title = "Send Alpha to another address";
                    } else {
                        sendTransactionBtn.title = "No UTXOs available to spend";
                    }
                }
                
                // Handle watch-only mode visibility
                updateWatchOnlyMode();

            }

            /**
             * Classify all current UTXOs by vesting status
             * This runs asynchronously after UTXOs are fetched
             */
            async function classifyAllUtxos() {
                if (serverProvidesVesting) {
                    console.log('[ServerVesting] Skipping client-side classification (server provides vesting)');
                    return;
                }

                if (vestingClassificationInProgress) {
                    console.log('Vesting classification already in progress');
                    return;
                }

                // Ensure we have current block height for accurate classification
                if (currentBlockHeight === null || currentBlockHeight === undefined) {
                    console.log('Waiting for block height before vesting classification...');
                    // Retry after a short delay
                    setTimeout(() => {
                        if (currentBlockHeight !== null && currentBlockHeight !== undefined) {
                            classifyAllUtxos();
                        }
                    }, 1000);
                    return;
                }

                // Get current address for caching
                const currentAddress = getCurrentVestingAddress();
                if (!currentAddress) {
                    console.log('No current address for vesting classification');
                    updateVestingBalanceDisplay();
                    return;
                }

                // Get or initialize cache for this address
                const addressCache = getAddressVestingCache(currentAddress);

                if (!currentUtxos || currentUtxos.length === 0) {
                    // Reset classified UTXOs for this address
                    addressCache.classifiedUtxos = { vested: [], unvested: [], all: [] };
                    addressCache.vestingBalances = { vested: 0n, unvested: 0n, all: 0n };
                    updateVestingBalanceDisplay();
                    return;
                }

                vestingClassificationInProgress = true;
                const progressEl = document.getElementById('vestingClassificationProgress');
                const progressTextEl = document.getElementById('vestingProgressText');

                // Show progress indicator
                if (progressEl) {
                    progressEl.style.display = 'block';
                }

                try {
                    const result = await VestingClassifier.classifyUtxos(currentUtxos, (current, total) => {
                        if (progressTextEl) {
                            progressTextEl.textContent = `${current}/${total}`;
                        }
                    });

                    // Update classified UTXOs for this address
                    addressCache.classifiedUtxos = {
                        vested: result.vested,
                        unvested: result.unvested,
                        all: [...result.vested, ...result.unvested]
                    };

                    // Calculate balances for each mode using BigInt
                    const consumedUtxos = getConsumedUtxos();

                    addressCache.vestingBalances.vested = result.vested.reduce((sum, utxo) => {
                        const utxoKey = `${utxo.tx_hash || utxo.txid}:${utxo.tx_pos || utxo.vout}`;
                        if (!consumedUtxos.has(utxoKey)) {
                            return sum + BigInt(utxo.value);
                        }
                        return sum;
                    }, 0n);

                    addressCache.vestingBalances.unvested = result.unvested.reduce((sum, utxo) => {
                        const utxoKey = `${utxo.tx_hash || utxo.txid}:${utxo.tx_pos || utxo.vout}`;
                        if (!consumedUtxos.has(utxoKey)) {
                            return sum + BigInt(utxo.value);
                        }
                        return sum;
                    }, 0n);

                    addressCache.vestingBalances.all = addressCache.vestingBalances.vested + addressCache.vestingBalances.unvested;

                    // Update display
                    updateVestingBalanceDisplay();

                    if (result.errors.length > 0) {
                        console.warn('Vesting classification errors:', result.errors.length, 'errors');
                        // Log first few error details for debugging
                        result.errors.slice(0, 5).forEach((err, i) => {
                            console.warn(`  Error ${i+1}: ${err.error} for UTXO ${err.utxo?.tx_hash?.substring(0, 16)}...`);
                        });
                    }
                } catch (error) {
                    console.error('Error during vesting classification:', error);
                } finally {
                    vestingClassificationInProgress = false;
                    if (progressEl) {
                        progressEl.style.display = 'none';
                    }
                }
            }

            /**
             * Update the vesting balance display in the UI
             */
            function updateVestingBalanceDisplay() {
                const vestedBalanceEl = document.getElementById('vestedBalance');
                const unvestedBalanceEl = document.getElementById('unvestedBalance');
                const vestedUnconfirmedEl = document.getElementById('vestedUnconfirmed');
                const unvestedUnconfirmedEl = document.getElementById('unvestedUnconfirmed');

                // Get balances from current address cache
                const currentAddress = getCurrentVestingAddress();
                const addressCache = currentAddress ? getAddressVestingCache(currentAddress) : null;
                const vestingBalances = addressCache ? addressCache.vestingBalances : { vested: 0n, unvested: 0n, all: 0n };

                if (vestedBalanceEl) {
                    vestedBalanceEl.textContent = SatoshiMath.satoshisToAlpha(vestingBalances.vested) + ' ALPHA';
                }
                if (unvestedBalanceEl) {
                    unvestedBalanceEl.textContent = SatoshiMath.satoshisToAlpha(vestingBalances.unvested) + ' ALPHA';
                }

                // Update row selection highlighting
                const allRow = document.querySelector('.vesting-row-all');
                const vestedRow = document.querySelector('.vesting-row-vested');
                const unvestedRow = document.querySelector('.vesting-row-unvested');

                if (allRow) allRow.classList.toggle('selected', vestingMode === 'all');
                if (vestedRow) vestedRow.classList.toggle('selected', vestingMode === 'vested');
                if (unvestedRow) unvestedRow.classList.toggle('selected', vestingMode === 'unvested');
            }

            /**
             * Set the current vesting mode and update UI
             * @param {string} mode - 'all', 'vested', or 'unvested'
             */
            window.setVestingMode = function(mode) {
                if (!['all', 'vested', 'unvested'].includes(mode)) {
                    console.error('Invalid vesting mode:', mode);
                    return;
                }

                vestingMode = mode;
                console.log('Vesting mode changed to:', mode);

                // Update radio button selection
                const radioButtons = document.querySelectorAll('input[name="vestingMode"]');
                radioButtons.forEach(radio => {
                    radio.checked = (radio.value === mode);
                });

                // Update row highlighting
                updateVestingBalanceDisplay();

                // Update UTXO list to show only UTXOs of selected mode
                updateUtxoListDisplay();
            };

            /**
             * Get UTXOs filtered by current vesting mode
             * @returns {Array} Filtered UTXOs based on vesting mode
             */
            function getFilteredUtxos() {
                const consumedUtxos = getConsumedUtxos();

                // Get per-address cache
                const currentAddress = getCurrentVestingAddress();
                const addressCache = currentAddress ? getAddressVestingCache(currentAddress) : null;
                const classifiedUtxos = addressCache ? addressCache.classifiedUtxos : { vested: [], unvested: [], all: [] };

                let utxoSource = [];
                if (classifiedUtxos.all.length > 0) {
                    // Use classified UTXOs if available
                    switch (vestingMode) {
                        case 'vested':
                            utxoSource = classifiedUtxos.vested;
                            break;
                        case 'unvested':
                            utxoSource = classifiedUtxos.unvested;
                            break;
                        default:
                            utxoSource = classifiedUtxos.all;
                    }
                } else if (currentUtxos && currentUtxos.length > 0) {
                    // Fall back to currentUtxos if not yet classified
                    utxoSource = currentUtxos;
                } else if (offlineUtxoData && offlineUtxoData.utxos) {
                    utxoSource = offlineUtxoData.utxos;
                }

                // Filter out consumed UTXOs
                return utxoSource.filter(utxo => {
                    const utxoKey = `${utxo.tx_hash || utxo.txid}:${utxo.tx_pos || utxo.vout}`;
                    return !consumedUtxos.has(utxoKey);
                });
            }

            /**
             * Get available balance for current vesting mode
             * @returns {BigInt} Available balance in satoshis
             */
            function getAvailableBalanceForMode() {
                // Get per-address cache
                const currentAddress = getCurrentVestingAddress();
                const addressCache = currentAddress ? getAddressVestingCache(currentAddress) : null;
                const vestingBalances = addressCache ? addressCache.vestingBalances : { vested: 0n, unvested: 0n, all: 0n };

                if (vestingMode === 'all') {
                    return vestingBalances.all;
                } else if (vestingMode === 'vested') {
                    return vestingBalances.vested;
                } else {
                    return vestingBalances.unvested;
                }
            }

            // Format transaction for display
            function formatTransactionDisplay(tx, ourAddress, confirmations, txDetails) {
                const rawTxid = tx.tx_hash || tx.txid || tx.id || '';
                // Sanitize txid: must be hex only (prevents innerHTML injection)
                const txid = rawTxid.replace(/[^a-fA-F0-9]/g, '');
                const truncatedTxid = txid.substring(0, 6) + '...' + txid.substring(txid.length - 6);
                const txLink = `https://www.unicity.network/tx/${txid}`;
                
                const txDiv = document.createElement('div');
                txDiv.style.cssText = 'padding: 15px; border-bottom: 1px solid #e9ecef; font-size: 14px;';
                txDiv.setAttribute('data-txid', txid);
                txDiv.setAttribute('data-vesting', 'pending');
                
                let statusColor = confirmations > 0 ? '#34d399' : '#fbbf24';
                let statusText = confirmations > 0 ? `${confirmations} confirmations` : 'Unconfirmed';
                
                // Check if we're still loading transaction details
                const isLoading = !txDetails;
                
                // Default display while loading
                let isIncoming = true;
                let amount = '0.00000000';
                let destinations = [];
                let senderAddress = null;
                let directionText = 'Loading...';
                let directionColor = '#9ca3af'; // Gray color for loading
                let amountColor = '#9ca3af';
                let amountSign = '';
                
                // Vesting status for this transaction: 'vested', 'unvested', 'mixed', or 'unknown'
                let vestingStatus = 'unknown';

                if (!isLoading) {
                    // Calculate net amount and direction from full transaction details
                    const result = calculateTransactionAmount(txDetails, ourAddress);
                    isIncoming = result.isIncoming;
                    amount = SatoshiMath.satoshisToAlpha(Math.abs(result.netAmount));
                    destinations = result.destinations;
                    senderAddress = result.senderAddress;

                    // Determine vesting status from our outputs in this transaction
                    if (result.ourOutputs && result.ourOutputs.length > 0) {
                        let hasVested = false, hasUnvested = false;
                        for (const out of result.ourOutputs) {
                            const cacheKey = `${txid}:${out.vout}`;
                            const cached = txoClassificationCache.get(cacheKey);
                            if (cached) {
                                if (cached.isVested) hasVested = true;
                                else hasUnvested = true;
                            }
                        }
                        if (hasVested && hasUnvested) vestingStatus = 'mixed';
                        else if (hasVested) vestingStatus = 'vested';
                        else if (hasUnvested) vestingStatus = 'unvested';
                    }

                    // Set direction text and colors based on transaction type
                    if (!ourAddress) {
                        // No wallet loaded - show neutral transaction
                        directionText = ' Transaction';
                        directionColor = '#6b7280';
                        amountColor = '#333';
                        amountSign = '';
                    } else {
                        directionText = isIncoming ? ' Received' : ' Sent';
                        directionColor = isIncoming ? '#34d399' : '#ef4444';
                        amountColor = isIncoming ? '#34d399' : '#333';
                        amountSign = isIncoming ? '+' : '-';
                    }
                }
                
                // Sanitize address for safe innerHTML use (alphanumeric + bech32 chars only)
                const sanitizeAddr = (a) => (a || '').replace(/[^a-zA-Z0-9]/g, '');

                let addressHtml = '';
                if (isLoading) {
                    // Show loading state for address
                    addressHtml = '<div style="margin-top: 5px; font-size: 12px; color: #9ca3af;">Loading...</div>';
                } else {
                    // Always show From address if available
                    let fromAddresses = txDetails._fromAddresses || [];
                    if (fromAddresses.length > 0) {
                        // Remove duplicates
                        fromAddresses = [...new Set(fromAddresses)];

                        addressHtml += '<div style="margin-top: 5px; font-size: 12px; color: #666;">From: ';
                        fromAddresses.forEach((addr, idx) => {
                            if (idx > 0) addressHtml += ', ';
                            const safeAddr = sanitizeAddr(addr);
                            const truncAddr = safeAddr.substring(0, 11) + '...' + safeAddr.substring(safeAddr.length - 6);
                            addressHtml += `<a href="https://www.unicity.network/address/${safeAddr}" target="_blank" style="color: #3b82f6; text-decoration: none;">${truncAddr}</a>`;
                        });
                        addressHtml += '</div>';
                    }

                    // For incoming transactions, show sender
                    if (isIncoming && senderAddress && fromAddresses.length === 0) {
                        const safeSender = sanitizeAddr(senderAddress);
                        const truncAddr = safeSender.substring(0, 11) + '...' + safeSender.substring(safeSender.length - 6);
                        addressHtml += `<div style="margin-top: 5px; font-size: 12px; color: #666;">From: <a href="https://www.unicity.network/address/${safeSender}" target="_blank" style="color: #3b82f6; text-decoration: none;">${truncAddr}</a></div>`;
                    }

                    // Show destinations
                    if (destinations.length > 0) {
                        // If no wallet is loaded (ourAddress is null), show all destinations
                        // Otherwise, only show destinations for outgoing transactions
                        if (!ourAddress || !isIncoming) {
                            addressHtml += '<div style="margin-top: 5px; font-size: 12px; color: #666;">To: ';
                            destinations.forEach((dest, idx) => {
                                if (idx > 0) addressHtml += ', ';
                                const safeDest = sanitizeAddr(dest.address);
                                const truncAddr = safeDest.substring(0, 11) + '...' + safeDest.substring(safeDest.length - 6);
                                addressHtml += `<a href="https://www.unicity.network/address/${safeDest}" target="_blank" style="color: #3b82f6; text-decoration: none;">${truncAddr}</a>`;
                            });
                            addressHtml += '</div>';
                        }
                    }
                }
                
                // Vesting visual indicators (only for classified outputs)
                const vestingColors = {
                    vested: '#ef4444',
                    unvested: '#4CAF50',
                    mixed: '#2196F3'
                };
                const vestingLabels = {
                    vested: 'Locked',
                    unvested: 'Unlocked',
                    mixed: 'Mixed'
                };
                const borderColor = vestingColors[vestingStatus] || null;
                const vestingLabel = vestingLabels[vestingStatus] || '';

                if (borderColor) {
                    txDiv.style.borderLeft = `3px solid ${borderColor}`;
                }
                txDiv.setAttribute('data-vesting', vestingStatus);

                const vestingBadgeHtml = vestingLabel ?
                    `<span style="font-size: 10px; padding: 1px 6px; border-radius: 3px; background-color: ${borderColor}20; color: ${borderColor}; font-weight: 600; margin-left: 8px;">${vestingLabel}</span>` : '';

                // Sanitize height to integer for safe innerHTML use
                const safeHeight = parseInt(tx.height, 10) || 0;

                txDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                <span style="color: ${directionColor}; font-weight: bold; margin-right: 10px;">
                                    ${directionText}
                                </span>
                                <a href="${txLink}" target="_blank" style="font-family: monospace; font-size: 12px; color: #3b82f6; text-decoration: none;">
                                    ${truncatedTxid}
                                </a>
                                ${vestingBadgeHtml}
                            </div>
                            <div style="color: #666; font-size: 12px;">
                                <span style="color: ${statusColor};">${statusText}</span>
                                ${safeHeight > 0 ? ` &bull; Block ${safeHeight}` : ''}
                                <span class="block-timestamp" data-height="${safeHeight}"></span>
                            </div>
                            ${addressHtml}
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 16px; font-weight: bold; color: ${amountColor};">
                                ${amountSign}${amount} ALPHA
                            </div>
                        </div>
                    </div>
                `;
                
                return txDiv;
            }
            
            // Calculate transaction amount and determine if incoming/outgoing
            function calculateTransactionAmount(txDetails, ourAddress) {
                let inputAmount = 0;
                let outputAmount = 0;
                let isOurInput = false;
                let destinations = [];
                let ourOutputs = [];
                let senderAddress = null;
                let fromAddresses = [];
                
                // Validate input
                if (!txDetails) {
                    console.warn('calculateTransactionAmount: txDetails is null/undefined');
                    return { amount: 0, isIncoming: false, destinations, ourOutputs, senderAddress, fromAddresses };
                }
                
                // Normalize our address to lowercase for comparison
                const ourAddressLower = ourAddress ? ourAddress.toLowerCase() : null;
                
                // Get all wallet addresses for comparison (to identify change outputs)
                const allOurAddresses = new Set();
                if (ourAddressLower) {
                    allOurAddresses.add(ourAddressLower);
                }
                if (wallet && wallet.addresses) {
                    wallet.addresses.forEach(addr => {
                        if (addr.address) {
                            allOurAddresses.add(addr.address.toLowerCase());
                        }
                    });
                }
                
                // If this is an imported Alpha wallet, also check first 20 change addresses
                if (wallet && wallet.isImportedAlphaWallet && wallet.masterPrivateKey && wallet.masterChainCode) {
                    for (let i = 0; i < 20; i++) {
                        const changeAddr = deriveAddressAtIndex(
                            wallet.masterPrivateKey,
                            wallet.masterChainCode,
                            i,
                            true, // isAlphaWallet
                            true, // isChange
                            wallet.descriptorPath
                        );
                        allOurAddresses.add(changeAddr.address.toLowerCase());
                    }
                }
                
                // Debug logging
                const txid = txDetails.txid || txDetails.id || 'unknown';
                
                // Check if sender address was already fetched and passed in
                if (txDetails._senderAddress) {
                    senderAddress = txDetails._senderAddress;
                }
                if (txDetails._fromAddresses) {
                    fromAddresses = txDetails._fromAddresses;
                }
                
                // First check all outputs to see what we received
                if (txDetails.vout) {
                    txDetails.vout.forEach((output, index) => {
                        const value = Math.round(output.value * 100000000); // Convert to satoshis (round to avoid floating-point errors)
                        
                        if (output.scriptPubKey) {
                            // Extract address from various possible fields
                            let outputAddress = null;
                            
                            // Check multiple possible locations for the address
                            if (output.scriptPubKey.addresses && output.scriptPubKey.addresses.length > 0) {
                                outputAddress = output.scriptPubKey.addresses[0];
                            } else if (output.scriptPubKey.address) {
                                outputAddress = output.scriptPubKey.address;
                            }
                            
                            // If no address found, try to decode from hex (for SegWit outputs)
                            if (!outputAddress && output.scriptPubKey.hex) {
                                // Log the scriptPubKey structure for debugging
                                
                                // Try to decode SegWit address from hex
                                // SegWit v0 P2WPKH starts with 0014 (OP_0 + 20 bytes)
                                if (output.scriptPubKey.hex.startsWith('0014') && output.scriptPubKey.hex.length === 44) {
                                    const witnessProgramHex = output.scriptPubKey.hex.substring(4);
                                    const witnessProgram = [];
                                    for (let i = 0; i < witnessProgramHex.length; i += 2) {
                                        witnessProgram.push(parseInt(witnessProgramHex.substr(i, 2), 16));
                                    }
                                    // Convert to bech32 address
                                    outputAddress = createBech32('alpha', [0].concat(convertBits(witnessProgram, 8, 5, true)));
                                }
                            }
                            
                            if (outputAddress) {
                                const isOurs = allOurAddresses.has(outputAddress.toLowerCase());
                                
                                // Debug: log only our outputs
                                if (isOurs) {
                                    console.log(`  Output ${index} is OURS: ${outputAddress}`);
                                }
                                
                                if (isOurs) {
                                    outputAmount += value;
                                    ourOutputs.push({vout: index, value: value, address: outputAddress});
                                } else {
                                    // Track destination addresses for outgoing transactions
                                    destinations.push({address: outputAddress, value: value});
                                }
                                
                                // If no wallet is loaded, all outputs are destinations
                                if (allOurAddresses.size === 0) {
                                    destinations.push({address: outputAddress, value: value});
                                }
                            } else {
                            }
                        }
                    });
                }
                
                // Check if any inputs are spending from our address
                // We need to check both current UTXOs and historical transactions
                if (txDetails.vin) {
                    txDetails.vin.forEach(input => {
                        if (!input) return; // Skip null/undefined inputs
                        const prevTxid = input.txid;
                        const prevVout = input.vout;
                        if (!prevTxid) return; // Skip if no txid
                        
                        // First check current UTXOs
                        if (currentUtxos) {
                            const matchingUtxo = currentUtxos.find(utxo => 
                                utxo && utxo.tx_hash && prevTxid && 
                                utxo.tx_hash.toLowerCase() === prevTxid.toLowerCase() && utxo.tx_pos === prevVout
                            );
                            
                            if (matchingUtxo) {
                                isOurInput = true;
                                inputAmount += matchingUtxo.value;
                                return; // Found it, continue to next input
                            }
                        }
                        
                        // Also check offline UTXO data if available
                        if (offlineUtxoData && offlineUtxoData.utxos) {
                            const matchingUtxo = offlineUtxoData.utxos.find(utxo => 
                                utxo && utxo.tx_hash && prevTxid &&
                                utxo.tx_hash.toLowerCase() === prevTxid.toLowerCase() && utxo.tx_pos === prevVout
                            );
                            
                            if (matchingUtxo) {
                                isOurInput = true;
                                inputAmount += matchingUtxo.value;
                                return; // Found it, continue to next input
                            }
                        }
                        
                        // If not in current UTXOs, we need to check if this specific output was ours
                        // by fetching the previous transaction details
                        if (transactionDetailsCache[prevTxid]) {
                            // We already have the transaction details cached
                            const prevTxDetails = transactionDetailsCache[prevTxid];
                            if (prevTxDetails && prevTxDetails.vout && prevTxDetails.vout[prevVout]) {
                                const prevOutput = prevTxDetails.vout[prevVout];
                                
                                // Extract address from the previous output
                                let prevOutputAddress = null;
                                if (prevOutput.scriptPubKey) {
                                    if (prevOutput.scriptPubKey.addresses && prevOutput.scriptPubKey.addresses.length > 0) {
                                        prevOutputAddress = prevOutput.scriptPubKey.addresses[0];
                                    } else if (prevOutput.scriptPubKey.address) {
                                        prevOutputAddress = prevOutput.scriptPubKey.address;
                                    }
                                }
                                
                                if (prevOutputAddress && allOurAddresses.has(prevOutputAddress.toLowerCase())) {
                                    isOurInput = true;
                                    inputAmount += Math.round(prevOutput.value * 100000000); // Convert to satoshis (round to avoid floating-point errors)
                                }
                            }
                        } else if (currentTransactions) {
                            // Check if this transaction is in our history
                            const prevTx = currentTransactions.find(tx => 
                                tx && prevTxid &&
                                ((tx.tx_hash || tx.txid) || '').toLowerCase() === prevTxid.toLowerCase()
                            );
                            
                            if (prevTx) {
                                // Transaction is in our history, but we need to fetch details to check the specific output
                                // Note: We can't determine ownership without fetching the transaction
                                // This will be handled asynchronously later
                            }
                        }
                    });
                    
                    // If we identified this as our input but don't have the amount,
                    // we'll handle this case later in the logic
                    // Don't estimate input amounts as it leads to incorrect transaction classification
                }
                
                // Determine transaction type and calculate net amount
                let isIncoming = false;
                let netAmount = 0;
                
                // If no wallet is loaded (ourAddressLower is null), show all transactions as neutral
                if (!ourAddressLower) {
                    // No wallet loaded - can't determine direction
                    isIncoming = false; // Default to false for neutral display
                    // Sum all outputs as the transaction amount
                    let totalOutput = 0;
                    destinations.forEach(dest => {
                        totalOutput += dest.value;
                    });
                    netAmount = totalOutput;
                } else {
                    // Simple logic based on your rules:
                    // 1. If ANY input is from our address -> OUTBOUND transaction
                    // 2. If NO inputs are from our address -> INBOUND transaction
                    
                    if (isOurInput) {
                        // OUTBOUND transaction
                        isIncoming = false;
                        
                        // For outbound transactions, we want to show the amount sent to others
                        // (excluding change back to ourselves)
                        let sentToOthers = 0;
                        destinations.forEach(dest => {
                            sentToOthers += dest.value;
                        });
                        
                        // Debug logging
                        if (ourOutputs.length > 0) {
                            console.log(`  - Our change addresses:`, ourOutputs.map(o => o.address));
                        }
                        
                        // If we have destinations (outputs to other addresses), use that amount
                        // Otherwise, if all outputs went back to us (rare case), calculate total spent
                        if (sentToOthers > 0) {
                            netAmount = sentToOthers;
                            // Using sent to others as netAmount
                        } else if (inputAmount > 0) {
                            // Rare case: all outputs are back to us (maybe a consolidation transaction)
                            // Show the fee amount (input - output)
                            netAmount = inputAmount - outputAmount;
                            console.log(`  - All outputs back to us, showing fee: ${netAmount} satoshis`);
                        } else {
                            // Fallback: we couldn't determine the exact amount
                            netAmount = 0;
                            console.log(`  - Could not determine amount, using 0`);
                        }
                    } else {
                        // INBOUND transaction
                        isIncoming = true;
                        netAmount = outputAmount; // Sum of all outputs to our address
                    }
                }
                
                // Validation: If we found no outputs to our address and no inputs from our address,
                // this transaction shouldn't be in our history
                if (outputAmount === 0 && !isOurInput) {
                    console.error(`  ERROR: Transaction ${txid} has no relation to our address ${ourAddress}`);
                    console.error(`  This should not happen - transaction history should only contain our transactions`);
                }
                
                
                // Check if sender address was provided via _senderAddress field
                if (!senderAddress && txDetails._senderAddress) {
                    senderAddress = txDetails._senderAddress;
                }
                
                return {
                    isIncoming,
                    netAmount: Math.abs(netAmount),
                    destinations,
                    ourOutputs,
                    senderAddress,
                    fromAddresses
                };
            }
            
            // Update transaction history display
            // Collect all transactions that need to be fetched
            function collectRequiredTransactions(transactions) {
                const requiredTxIds = new Set();
                
                // Add all transaction IDs
                transactions.forEach(tx => {
                    const txid = tx.tx_hash || tx.txid;
                    requiredTxIds.add(txid);
                });
                
                // Also collect all input transactions we might need
                transactions.forEach(tx => {
                    const txid = tx.tx_hash || tx.txid;
                    if (transactionDetailsCache[txid] && transactionDetailsCache[txid].vin) {
                        transactionDetailsCache[txid].vin.forEach(input => {
                            if (input.txid) {
                                requiredTxIds.add(input.txid);
                            }
                        });
                    }
                });
                
                return Array.from(requiredTxIds);
            }
            
            // Fetch all required transaction details
            function fetchAllTransactionDetails(txIds, callback) {
                let pending = txIds.length;
                let completed = 0;
                
                if (pending === 0) {
                    callback();
                    return;
                }
                
                txIds.forEach(txid => {
                    if (transactionDetailsCache[txid]) {
                        // Already cached
                        completed++;
                        if (completed === pending) {
                            callback();
                        }
                    } else {
                        // Fetch transaction details
                        electrumRequest('blockchain.transaction.get', [txid, true], function(txDetails) {
                            if (txDetails) {
                                transactionDetailsCache[txid] = txDetails;
                            }
                            completed++;
                            if (completed === pending) {
                                callback();
                            }
                        });
                    }
                });
            }
            
            function updateTransactionHistory() {
                if (!electrumConnected || !currentTransactions || currentTransactions.length === 0) {
                    document.getElementById('transactionHistoryContainer').style.display = 'none';
                    return;
                }
                
                document.getElementById('transactionHistoryContainer').style.display = 'block';
                const historyList = document.getElementById('transactionHistoryList');
                historyList.innerHTML = '';
                
                // Sort by height (most recent first)
                const sortedTxs = [...currentTransactions].sort((a, b) => {
                    if (a.height === 0 && b.height === 0) return 0;
                    if (a.height === 0) return -1;
                    if (b.height === 0) return 1;
                    return b.height - a.height;
                });
                
                // Calculate pagination
                const totalPages = Math.ceil(sortedTxs.length / ITEMS_PER_PAGE);
                const startIndex = (currentTransactionPage - 1) * ITEMS_PER_PAGE;
                const endIndex = startIndex + ITEMS_PER_PAGE;
                const pageTxs = sortedTxs.slice(startIndex, endIndex);
                
                const currentHeight = currentBlockHeight || 0;
                const ourAddress = watchOnlyMode && watchOnlyAddressValue ? 
                    watchOnlyAddressValue : 
                    (wallet.addresses && wallet.addresses.length > 0 ? wallet.addresses[0].address : null);
                
                if (!ourAddress) return;
                
                // First, display all transactions with loading state
                pageTxs.forEach(tx => {
                    const confirmations = tx.height > 0 ? Math.max(0, currentHeight - tx.height + 1) : 0;
                    const txElement = formatTransactionDisplay(tx, ourAddress, confirmations, null);
                    historyList.appendChild(txElement);
                });
                
                // Add pagination controls
                if (totalPages > 1) {
                    const paginationDiv = document.createElement('div');
                    paginationDiv.style.cssText = 'display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #e9ecef;';
                    
                    // Previous button
                    const prevBtn = document.createElement('button');
                    prevBtn.textContent = ' Previous';
                    prevBtn.style.cssText = 'padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    prevBtn.disabled = currentTransactionPage === 1;
                    prevBtn.onclick = () => {
                        if (currentTransactionPage > 1) {
                            currentTransactionPage--;
                            updateTransactionHistory();
                        }
                    };
                    
                    // Page info
                    const pageInfo = document.createElement('span');
                    pageInfo.textContent = `Page ${currentTransactionPage} of ${totalPages} (${sortedTxs.length} total)`;
                    pageInfo.style.cssText = 'font-size: 12px; color: #666;';
                    
                    // Next button
                    const nextBtn = document.createElement('button');
                    nextBtn.textContent = 'Next ';
                    nextBtn.style.cssText = 'padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    nextBtn.disabled = currentTransactionPage === totalPages;
                    nextBtn.onclick = () => {
                        if (currentTransactionPage < totalPages) {
                            currentTransactionPage++;
                            updateTransactionHistory();
                        }
                    };
                    
                    paginationDiv.appendChild(prevBtn);
                    paginationDiv.appendChild(pageInfo);
                    paginationDiv.appendChild(nextBtn);
                    historyList.appendChild(paginationDiv);
                }
                
                // Collect all transaction IDs we need to fetch
                const txIdsToFetch = pageTxs.map(tx => tx.tx_hash || tx.txid);
                
                // First round: fetch all main transactions
                fetchAllTransactionDetails(txIdsToFetch, function() {
                    // Now collect all input transactions we need
                    const inputTxIds = new Set();
                    
                    pageTxs.forEach(tx => {
                        const txid = tx.tx_hash || tx.txid;
                        const txDetails = transactionDetailsCache[txid];
                        if (txDetails && txDetails.vin) {
                            txDetails.vin.forEach(input => {
                                if (input.txid) {
                                    inputTxIds.add(input.txid);
                                }
                            });
                        }
                    });
                    
                    // Second round: fetch all input transactions
                    fetchAllTransactionDetails(Array.from(inputTxIds), function() {
                        // Now update all transactions with complete details
                        pageTxs.forEach(tx => {
                            const confirmations = tx.height > 0 ? Math.max(0, currentHeight - tx.height + 1) : 0;
                            const txid = tx.tx_hash || tx.txid;
                            const txDetails = transactionDetailsCache[txid];
                            
                            if (txDetails) {
                                // Check if this is an incoming transaction and get sender address
                                const result = calculateTransactionAmount(txDetails, ourAddress);
                                
                                // Always try to get sender addresses for all transactions
                                if (txDetails.vin && txDetails.vin.length > 0) {
                                    const fromAddresses = [];
                                    
                                    // Collect all sender addresses
                                    txDetails.vin.forEach(input => {
                                        const prevTxid = input.txid;
                                        const prevVout = input.vout;
                                        const prevTxDetails = transactionDetailsCache[prevTxid];
                                        
                                        if (prevTxDetails && prevTxDetails.vout && prevTxDetails.vout[prevVout]) {
                                            const prevOutput = prevTxDetails.vout[prevVout];
                                            if (prevOutput.scriptPubKey) {
                                                let address = null;
                                                if (prevOutput.scriptPubKey.addresses && prevOutput.scriptPubKey.addresses.length > 0) {
                                                    address = prevOutput.scriptPubKey.addresses[0];
                                                } else if (prevOutput.scriptPubKey.address) {
                                                    address = prevOutput.scriptPubKey.address;
                                                }
                                                if (address) {
                                                    fromAddresses.push(address);
                                                }
                                            }
                                        }
                                    });
                                    
                                    // For incoming transactions, set the first sender as the main sender
                                    if (result.isIncoming && fromAddresses.length > 0) {
                                        result.senderAddress = fromAddresses[0];
                                    }
                                    
                                    // Update with sender info
                                    const txDetailsWithSender = Object.assign({}, txDetails, {
                                        _senderAddress: result.senderAddress,
                                        _fromAddresses: fromAddresses
                                    });
                                    const updatedElement = formatTransactionDisplay(tx, ourAddress, confirmations, txDetailsWithSender);
                                    const oldElement = historyList.querySelector(`[data-txid="${txid}"]`);
                                    if (oldElement) {
                                        oldElement.replaceWith(updatedElement);
                                    }
                                } else {
                                    // Update the element with full details
                                    const updatedElement = formatTransactionDisplay(tx, ourAddress, confirmations, txDetails);
                                    const oldElement = historyList.querySelector(`[data-txid="${txid}"]`);
                                    if (oldElement) {
                                        oldElement.replaceWith(updatedElement);
                                    }
                                }
                                
                                // Fetch and display block timestamp
                                if (tx.height > 0) {
                                    getBlockTimestamp(tx.height, function(timestamp) {
                                        const timestampElement = historyList.querySelector(`[data-txid="${txid}"] .block-timestamp`);
                                        if (timestampElement && timestamp) {
                                            timestampElement.textContent = `  ${formatBlockTimestamp(timestamp)}`;
                                        }
                                    });
                                }
                            }
                        });
                    });
                });
            }
            
            // Cache for block timestamps
            const blockTimestampCache = {};
            
            // Get block timestamp
            function getBlockTimestamp(height, callback) {
                if (!height || height <= 0) {
                    callback(null);
                    return;
                }
                
                // Check cache first
                if (blockTimestampCache[height]) {
                    callback(blockTimestampCache[height]);
                    return;
                }
                
                // Fetch block header
                electrumRequest('blockchain.block.header', [height], function(header) {
                    if (header) {
                        // Extract timestamp from block header (at bytes 68-71, little-endian)
                        const timestampHex = header.substring(136, 144);
                        const timestamp = parseInt(timestampHex.match(/../g).reverse().join(''), 16);
                        const date = new Date(timestamp * 1000);
                        blockTimestampCache[height] = date;
                        callback(date);
                    } else {
                        callback(null);
                    }
                });
            }
            
            // Format block timestamp for display
            function formatBlockTimestamp(date) {
                if (!date) return '';
                const options = { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric', 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                };
                return date.toLocaleString(undefined, options);
            }
            
            // Start polling for new blocks (reduced frequency since we have subscriptions)
            function startBlockPolling() {
                // Clear any existing interval
                if (blockPollInterval) {
                    clearInterval(blockPollInterval);
                }
                
                // Only poll as a backup every 5 minutes since we have real-time subscriptions
                blockPollInterval = setInterval(function() {
                    if (!electrumConnected) {
                        stopBlockPolling();
                        return;
                    }
                    
                    // This is now just a fallback check since we have subscriptions
                    console.log('Performing periodic connection health check...');
                    
                    // Simple ping to keep connection alive
                    electrumRequest('server.ping', [], function(result) {
                        console.log('Connection health check:', result !== null ? 'OK' : 'Failed');
                    });
                }, 300000); // 5 minutes - just for connection health
            }
            
            // Stop polling for blocks
            function stopBlockPolling() {
                if (blockPollInterval) {
                    clearInterval(blockPollInterval);
                    blockPollInterval = null;
                }
            }
            
            // Export UTXO data
            function exportUtxoData() {
                // Get address from either watch-only mode or regular wallet
                const address = watchOnlyMode && watchOnlyAddressValue ? 
                    watchOnlyAddressValue : 
                    (wallet.addresses && wallet.addresses.length > 0 ? wallet.addresses[0].address : null);
                
                if (!address) {
                    alert('No wallet address available');
                    return;
                }
                
                if (!electrumConnected) {
                    alert('Please connect to Fulcrum server first to fetch UTXO data');
                    return;
                }
                
                const scriptHash = addressToScriptHash(address);
                
                if (!scriptHash) {
                    alert('Failed to convert address to script hash');
                    return;
                }
                
                // First get the current block height
                electrumRequest('blockchain.headers.subscribe', [], function(headerInfo, error) {
                    if (error) {
                        console.error('Failed to get block height:', error);
                        // Continue without block height
                        fetchAndExportUtxos(null);
                        return;
                    }
                    
                    const blockHeight = headerInfo ? (headerInfo.height || headerInfo.block_height) : null;
                    fetchAndExportUtxos(blockHeight);
                });
                
                function fetchAndExportUtxos(blockHeight) {
                    // Fetch UTXOs
                    electrumRequest('blockchain.scripthash.listunspent', [scriptHash], function(utxos, error) {
                        if (error) {
                            showInAppNotification('Export Failed', 'Failed to fetch UTXOs: ' + error.message, 'error');
                            return;
                        }
                        
                        // Create export data with blockchain state info
                        const exportData = {
                            version: '1.1',
                            network: 'alpha',
                            address: address,
                            scriptHash: scriptHash,
                            blockchain: {
                                height: blockHeight,
                                timestamp: new Date().toISOString(),
                                exportDate: new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString()
                            },
                            utxos: (utxos || []).map(utxo => ({
                                ...utxo,
                                address: address
                            })),
                            transactions: currentTransactions.slice(0, 20), // Last 20 transactions
                            metadata: {
                                walletVersion: '1.0.0',
                                exportedFrom: window.location.hostname || 'offline-wallet',
                                utxoCount: (utxos || []).length,
                                totalValue: Number(SatoshiMath.sum((utxos || []).map(u => u.value || 0)))
                            }
                        };
                        
                        // Convert to JSON with nice formatting
                        const jsonData = JSON.stringify(exportData, null, 2);
                        
                        // Create download with block height in filename
                        const blob = new Blob([jsonData], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const blockStr = blockHeight ? `_block${blockHeight}` : '';
                        a.download = `utxo_${address.substring(0, 10)}${blockStr}_${Date.now()}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        const blockInfo = blockHeight ? ` at block ${blockHeight}` : '';
                        showInAppNotification('Export Successful', `UTXO data exported${blockInfo}`, 'success');
                    });
                }
            }
            
            // Export transaction template for watch-only mode
            function exportTransactionTemplate(transactions, recipientAddress, totalAmount, senderAddress) {
                // Get current block height if connected
                if (electrumConnected) {
                    electrumRequest('blockchain.headers.subscribe', [], function(headerInfo, error) {
                        const blockHeight = headerInfo ? (headerInfo.height || headerInfo.block_height) : null;
                        createAndExportTemplate(blockHeight);
                    });
                } else {
                    createAndExportTemplate(null);
                }
                
                function createAndExportTemplate(blockHeight) {
                    // Collect only the UTXOs that will be spent
                    const spentUtxos = transactions.map(tx => tx.input);
                    
                    // Create export data with transaction templates
                    const exportData = {
                        version: '1.2',
                        network: 'alpha',
                        address: senderAddress,
                        scriptHash: addressToScriptHash(senderAddress),
                        blockchain: {
                            height: blockHeight,
                            timestamp: new Date().toISOString(),
                            exportDate: new Date().toLocaleDateString() + ' ' + new Date().toLocaleTimeString()
                        },
                        utxos: spentUtxos,
                        transactionTemplates: transactions.map((tx, index) => ({
                            index: index,
                            inputs: [tx.input],
                            outputs: tx.outputs,
                            fee: tx.fee,
                            changeAmount: tx.changeAmount,
                            changeAddress: tx.changeAddress
                        })),
                        metadata: {
                            walletVersion: '1.0.0',
                            exportedFrom: window.location.hostname || 'offline-wallet',
                            utxoCount: spentUtxos.length,
                            totalValue: Number(SatoshiMath.sum(spentUtxos.map(u => u.value || 0))),
                            recipientAddress: recipientAddress,
                            sendAmount: totalAmount,
                            exportType: 'transaction_template'
                        }
                    };
                    
                    // Convert to JSON with nice formatting
                    const jsonData = JSON.stringify(exportData, null, 2);
                    
                    // Create download with descriptive filename
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    a.download = `alpha_tx_template_${totalAmount}ALPHA_${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showInAppNotification('Transaction Template Exported', `Exported template to send ${totalAmount} ALPHA to ${recipientAddress.substring(0, 10)}...`, 'success');
                }
            }
            
            // Import UTXO data
            function importUtxoData() {
                if (electrumConnected) {
                    alert('UTXO imports are disabled while connected to Fulcrum server');
                    return;
                }
                utxoFileInput.click();
            }
            
            // Handle file selection for import
            utxoFileInput.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Validate data structure (require new format)
                        if (!data.version || !data.address || !data.utxos || !data.blockchain) {
                            throw new Error('Invalid UTXO data format. Please export fresh data from an online session.');
                        }
                        
                        // Check if address matches current wallet
                        if (wallet.addresses && wallet.addresses.length > 0) {
                            if (data.address.toLowerCase() !== wallet.addresses[0].address.toLowerCase()) {
                                const confirmImport = confirm(
                                    'Warning: The imported data is for a different address.\n\n' +
                                    'Imported: ' + data.address + '\n' +
                                    'Current: ' + wallet.addresses[0].address + '\n\n' +
                                    'Do you want to continue?'
                                );
                                if (!confirmImport) return;
                            }
                        }
                        
                        // Check block height freshness
                        if (lastUpdateBlockHeight && data.blockchain && data.blockchain.height && 
                            data.blockchain.height < lastUpdateBlockHeight) {
                            const confirmImport = confirm(
                                `Warning: This UTXO data is from block ${data.blockchain.height}, but you have more recent data from block ${lastUpdateBlockHeight}.\n\n` +
                                `Importing this will overwrite your newer data. Continue?`
                            );
                            if (!confirmImport) {
                                utxoFileInput.value = '';
                                return;
                            }
                        }
                        
                        // Check data freshness
                        const exportDate = new Date(data.blockchain.timestamp);
                        const now = new Date();
                        const hoursDiff = Math.abs(now - exportDate) / 36e5; // Convert to hours
                        
                        if (hoursDiff > 24) {
                            const daysDiff = Math.floor(hoursDiff / 24);
                            const confirmStale = confirm(
                                `Warning: This UTXO data is ${daysDiff} day${daysDiff > 1 ? 's' : ''} old (block ${data.blockchain.height}).\n\n` +
                                `Exported: ${data.blockchain.exportDate}\n\n` +
                                'The balance information may be outdated. Continue?'
                            );
                            if (!confirmStale) return;
                        }
                        
                        // Check if this is a transaction template
                        if (data.transactionTemplates && data.metadata && data.metadata.exportType === 'transaction_template') {
                            // This is a transaction template - handle differently
                            offlineUtxoData = data;
                            localStorage.setItem('offlineUtxoData', JSON.stringify(data));
                            
                            // Update displays
                            updateCommonBalance();
                            updateUtxoListDisplay();
                            
                            showInAppNotification('Transaction Template Imported', 
                                `Template to send ${data.metadata.sendAmount} ALPHA to ${data.metadata.recipientAddress.substring(0, 10)}...`, 
                                'success');
                            
                            // Auto-open transaction confirmation modal with the template data
                            setTimeout(() => {
                                showTransactionTemplateConfirmation(data.transactionTemplates, data.metadata.recipientAddress, data.metadata.sendAmount);
                            }, 500);
                        } else {
                            // Regular UTXO import
                            offlineUtxoData = data;
                            localStorage.setItem('offlineUtxoData', JSON.stringify(data));
                            
                            // Update displays
                            // displayOfflineBalance(); // Removed with Cold Wallet reorganization
                            updateCommonBalance();
                            updateUtxoListDisplay();
                            
                            showInAppNotification('Import Successful', `UTXO data imported (block ${data.blockchain.height})`, 'success');
                        }
                    } catch (err) {
                        showInAppNotification('Import Failed', err.message, 'error');
                    }
                };
                reader.readAsText(file);
                
                // Reset the input
                event.target.value = '';
            };
            
            /* // Display offline balance - Removed with Cold Wallet reorganization
            function displayOfflineBalance() {
                if (!offlineUtxoData) {
                    offlineBalanceDisplay.style.display = 'none';
                    clearUtxoBtn.style.display = 'none';
                    return;
                }
                
                offlineBalanceDisplay.style.display = 'block';
                clearUtxoBtn.style.display = 'inline-flex';
                
                // Calculate total balance from UTXOs
                let totalBalance = 0;
                const utxos = offlineUtxoData.utxos || [];
                
                // Always calculate from UTXOs (single source of truth)
                utxos.forEach(utxo => {
                    totalBalance += utxo.value || 0;
                });
                
                // Display balance
                const alphaBalance = SatoshiMath.satoshisToAlpha(totalBalance);
                offlineBalanceAmount.textContent = alphaBalance + ' ALPHA';
                
                // Display timestamp and block height
                const timestamp = new Date(offlineUtxoData.blockchain.timestamp);
                const blockHeight = offlineUtxoData.blockchain.height;
                offlineDataTimestamp.textContent = `Last updated: ${timestamp.toLocaleString()}  Block #${blockHeight}`;
                
                // Display UTXOs
                offlineUtxoList.innerHTML = '';
                
                if (utxos.length === 0) {
                    offlineUtxoList.innerHTML = '<p style="color: #999; text-align: center;">No UTXOs available</p>';
                } else {
                    const utxoHeader = document.createElement('div');
                    utxoHeader.style.cssText = 'font-weight: bold; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #e9ecef;';
                    utxoHeader.innerHTML = `${utxos.length} UTXO${utxos.length > 1 ? 's' : ''} available`;
                    offlineUtxoList.appendChild(utxoHeader);
                    
                    utxos.forEach((utxo, index) => {
                        const utxoDiv = document.createElement('div');
                        utxoDiv.style.cssText = 'padding: 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px;';
                        
                        const txId = utxo.tx_hash || utxo.txid || 'Unknown';
                        const vout = utxo.tx_pos !== undefined ? utxo.tx_pos : (utxo.vout || 0);
                        const value = SatoshiMath.satoshisToAlpha(utxo.value);
                        const height = utxo.height;
                        
                        utxoDiv.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-family: monospace; font-size: 11px; color: #666;">
                                        ${txId.substring(0, 8)}...${txId.substring(txId.length - 8)}:${vout}
                                    </div>
                                    <div style="color: #333; font-weight: bold; margin-top: 2px;">
                                        ${value} ALPHA
                                    </div>
                                    <div style="color: #999; font-size: 11px;">
                                        ${height > 0 ? 'Block ' + height : 'Unconfirmed'}
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        offlineUtxoList.appendChild(utxoDiv);
                    });
                }
            }
            */ // End of displayOfflineBalance - Removed with Cold Wallet reorganization
            
            // Update UTXO list display
            function updateUtxoListDisplay() {
                const utxoListElement = document.getElementById('currentUtxoList');
                if (!utxoListElement) {
                    return;
                }
                
                // Determine which UTXOs to display
                let allUtxos = [];
                let isOfflineData = false;
                
                if (currentUtxos && currentUtxos.length > 0) {
                    // Online UTXOs from Fulcrum
                    allUtxos = currentUtxos.map(utxo => ({
                        ...utxo,
                        source: 'online'
                    }));
                } else if (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0) {
                    // Offline imported UTXOs
                    allUtxos = offlineUtxoData.utxos.map(utxo => ({
                        ...utxo,
                        source: 'offline'
                    }));
                    isOfflineData = true;
                }
                
                // Show/hide clear button based on offline data and connection status
                if (clearUtxoBtn) {
                    clearUtxoBtn.style.display = (isOfflineData && !electrumConnected) ? 'inline-flex' : 'none';
                }
                
                // Clear current display
                utxoListElement.innerHTML = '';
                
                if (allUtxos.length === 0) {
                    utxoListElement.innerHTML = '<div style="color: #666; font-style: italic; font-size: 11px;">No UTXOs available</div>';
                    return;
                }
                
                // Calculate pagination
                const totalPages = Math.ceil(allUtxos.length / ITEMS_PER_PAGE);
                const startIndex = (currentUtxoPage - 1) * ITEMS_PER_PAGE;
                const endIndex = startIndex + ITEMS_PER_PAGE;
                const pageUtxos = allUtxos.slice(startIndex, endIndex);
                
                // Get consumed UTXOs
                const consumedUtxos = getConsumedUtxos();
                
                // Display each UTXO on the current page
                pageUtxos.forEach((utxo, pageIndex) => {
                    const globalIndex = startIndex + pageIndex;
                    const utxoDiv = document.createElement('div');

                    const amount = SatoshiMath.satoshisToAlpha(utxo.value);
                    const rawUtxoTxid = utxo.tx_hash || utxo.txid || '';
                    const txid = rawUtxoTxid.replace(/[^a-fA-F0-9]/g, '');
                    const vout = parseInt(utxo.tx_pos !== undefined ? utxo.tx_pos : utxo.vout, 10) || 0;
                    const height = parseInt(utxo.height, 10) || 0;
                    const source = utxo.source === 'offline' ? ' (imported)' : '';
                    
                    // Check if this UTXO is consumed
                    const utxoKey = `${txid}:${vout}`;
                    const isConsumed = consumedUtxos.has(utxoKey);

                    // Determine UTXO vesting status from cache
                    const utxoClassification = txoClassificationCache.get(utxoKey);
                    let utxoVestingColor = null;
                    let utxoVestingLabel = '';
                    if (utxoClassification) {
                        if (utxoClassification.isVested) {
                            utxoVestingColor = '#ef4444'; // red = locked
                            utxoVestingLabel = 'Locked';
                        } else {
                            utxoVestingColor = '#4CAF50'; // green = unlocked
                            utxoVestingLabel = 'Unlocked';
                        }
                    }

                    const borderStyle = utxoVestingColor ? `border-left: 3px solid ${utxoVestingColor};` : '';
                    // Style based on consumption status
                    if (isConsumed) {
                        utxoDiv.style.cssText = `padding: 8px; background-color: #e5e7eb; border-radius: 4px; margin-bottom: 6px; font-size: 11px; opacity: 0.6; ${borderStyle}`;
                    } else {
                        utxoDiv.style.cssText = `padding: 8px; background-color: #f8f9fa; border-radius: 4px; margin-bottom: 6px; font-size: 11px; ${borderStyle}`;
                    }

                    const utxoBadgeHtml = utxoVestingLabel ?
                        `<span style="font-size: 9px; padding: 1px 5px; border-radius: 3px; background-color: ${utxoVestingColor}20; color: ${utxoVestingColor}; font-weight: 600; margin-left: 6px;">${utxoVestingLabel}</span>` : '';

                    utxoDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: ${isConsumed ? '#6b7280' : '#06d6a0'};">${amount} ALPHA${source}${isConsumed ? ' (pending)' : ''}${utxoBadgeHtml}</div>
                                <div style="font-family: monospace; color: #666; word-break: break-all;">
                                    ${txid}:${vout}
                                </div>
                                <div style="color: #888; margin-top: 2px;">
                                    ${height > 0 ? 
                                        (currentBlockHeight ? 
                                            `${Math.max(0, currentBlockHeight - height + 1)} confirmations` : 
                                            `Block: ${height}`) : 
                                        'Unconfirmed'}
                                    <span class="utxo-timestamp" data-height="${height}" data-index="${globalIndex}"></span>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    utxoListElement.appendChild(utxoDiv);
                });
                
                // Add pagination controls if needed
                if (totalPages > 1) {
                    const paginationDiv = document.createElement('div');
                    paginationDiv.style.cssText = 'display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #e9ecef;';
                    
                    // Previous button
                    const prevBtn = document.createElement('button');
                    prevBtn.textContent = ' Previous';
                    prevBtn.style.cssText = 'padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    prevBtn.disabled = currentUtxoPage === 1;
                    prevBtn.onclick = () => {
                        if (currentUtxoPage > 1) {
                            currentUtxoPage--;
                            updateUtxoListDisplay();
                        }
                    };
                    
                    // Page info
                    const pageInfo = document.createElement('span');
                    pageInfo.textContent = `Page ${currentUtxoPage} of ${totalPages} (${allUtxos.length} total)`;
                    pageInfo.style.cssText = 'font-size: 12px; color: #666;';
                    
                    // Next button
                    const nextBtn = document.createElement('button');
                    nextBtn.textContent = 'Next ';
                    nextBtn.style.cssText = 'padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; font-size: 12px;';
                    nextBtn.disabled = currentUtxoPage === totalPages;
                    nextBtn.onclick = () => {
                        if (currentUtxoPage < totalPages) {
                            currentUtxoPage++;
                            updateUtxoListDisplay();
                        }
                    };
                    
                    paginationDiv.appendChild(prevBtn);
                    paginationDiv.appendChild(pageInfo);
                    paginationDiv.appendChild(nextBtn);
                    utxoListElement.appendChild(paginationDiv);
                }
                
                // Fetch and display timestamps for all UTXOs with block heights (only when connected)
                if (electrumConnected) {
                    pageUtxos.forEach((utxo, pageIndex) => {
                        const globalIndex = startIndex + pageIndex;
                        const height = utxo.height || 0;
                        if (height > 0) {
                            getBlockTimestamp(height, function(timestamp) {
                                const timestampElement = utxoListElement.querySelector(`.utxo-timestamp[data-index="${globalIndex}"]`);
                                if (timestampElement && timestamp) {
                                    timestampElement.textContent = `  ${formatBlockTimestamp(timestamp)}`;
                                }
                            });
                        }
                    });
                }
            }
            
            // Clear offline UTXO data
            function clearOfflineUtxoData() {
                if (confirm('Are you sure you want to clear the offline UTXO data?')) {
                    offlineUtxoData = null;
                    localStorage.removeItem('offlineUtxoData');
                    // displayOfflineBalance(); // Removed with Cold Wallet reorganization
                    updateCommonBalance();
                    updateUtxoListDisplay();
                    showInAppNotification('Data Cleared', 'Offline UTXO data has been cleared', 'info');
                }
            }
            
            // Load offline UTXO data from localStorage on startup
            function loadOfflineUtxoData() {
                const stored = localStorage.getItem('offlineUtxoData');
                if (stored) {
                    try {
                        offlineUtxoData = JSON.parse(stored);
                        // displayOfflineBalance(); // Removed with Cold Wallet reorganization
                        updateCommonBalance();
                        updateUtxoListDisplay();
                    } catch (err) {
                        console.error('Failed to load offline UTXO data:', err);
                    }
                }
            }
            
            // Request notification permission on page load
            async function requestNotificationPermission() {
                if ('Notification' in window && Notification.permission === 'default') {
                    try {
                        const permission = await Notification.requestPermission();
                        console.log('Notification permission:', permission);
                    } catch (err) {
                        console.error('Error requesting notification permission:', err);
                    }
                }
            }
            
            // Copy address to clipboard
            window.copyAddress = function(type) {
                let address = '';
                if (type === 'wallet') {
                    const walletAddressEl = document.getElementById('walletAddress');
                    // Use data-address attribute if available (for BIP32 addresses), otherwise use textContent
                    address = walletAddressEl.dataset.address || walletAddressEl.textContent;
                } else if (type === 'watchonly') {
                    address = document.getElementById('watchOnlyAddress').value;
                }
                
                if (address && address !== '-') {
                    // Check if clipboard API is available (requires HTTPS)
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(address).then(function() {
                            showInAppNotification('Copied', 'Address copied to clipboard', 'success');
                        }).catch(function(err) {
                            // If clipboard API fails, use fallback
                            copyUsingFallback(address);
                        });
                    } else {
                        // Use fallback method for HTTP or older browsers
                        copyUsingFallback(address);
                    }
                }
            }
            
            function copyUsingFallback(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                textArea.style.top = "-999999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    showInAppNotification('Copied', 'Address copied to clipboard', 'success');
                } catch (err) {
                    showInAppNotification('Failed', 'Failed to copy address', 'error');
                }
                document.body.removeChild(textArea);
            }
            
            // Show help modal
            window.showHelpModal = function() {
                document.getElementById('helpModal').style.display = 'block';
            }
            
            // Close help modal
            window.closeHelpModal = function() {
                document.getElementById('helpModal').style.display = 'none';
            }
            
            // Switch help modal tabs
            window.switchHelpTab = function(tab) {
                // Hide all tab contents
                const tabContents = document.querySelectorAll('.help-tab-content');
                tabContents.forEach(content => {
                    content.style.display = 'none';
                });
                
                // Remove active class from all tab buttons
                const tabButtons = document.querySelectorAll('.help-tab-button');
                tabButtons.forEach(button => {
                    button.style.borderBottom = '3px solid transparent';
                    button.style.color = '#666';
                    button.style.fontWeight = 'normal';
                });
                
                // Show selected tab content
                if (tab === 'general') {
                    document.getElementById('generalTabContent').style.display = 'block';
                    document.getElementById('generalTab').style.borderBottom = '3px solid #4CAF50';
                    document.getElementById('generalTab').style.color = '#333';
                    document.getElementById('generalTab').style.fontWeight = '600';
                } else if (tab === 'coldWallet') {
                    document.getElementById('coldWalletHelpTabContent').style.display = 'block';
                    document.getElementById('coldWalletTab').style.borderBottom = '3px solid #4CAF50';
                    document.getElementById('coldWalletTab').style.color = '#333';
                    document.getElementById('coldWalletTab').style.fontWeight = '600';
                } else if (tab === 'debug') {
                    document.getElementById('debugTabContent').style.display = 'block';
                    document.getElementById('debugTab').style.borderBottom = '3px solid #4CAF50';
                    document.getElementById('debugTab').style.color = '#333';
                    document.getElementById('debugTab').style.fontWeight = '600';
                }
            }
            
            // Switch main tabs
            window.switchMainTab = function(tab) {
                // Hide all tab contents
                const tabContents = document.querySelectorAll('.main-tab-content');
                tabContents.forEach(content => {
                    content.style.display = 'none';
                });
                
                // Remove active class from all tab buttons
                const tabButtons = document.querySelectorAll('.main-tab-button');
                tabButtons.forEach(button => {
                    button.style.borderBottom = '3px solid transparent';
                    button.style.color = '#666';
                    button.style.fontWeight = 'normal';
                    button.style.backgroundColor = 'white';
                });
                
                // Show selected tab content
                if (tab === 'wallet') {
                    document.getElementById('walletTabContent').style.display = 'block';
                    const btn = document.getElementById('walletTabBtn');
                    btn.style.borderBottom = '3px solid #4CAF50';
                    btn.style.color = '#333';
                    btn.style.fontWeight = '600';
                } else if (tab === 'coldWallet') {
                    document.getElementById('coldWalletTabContent').style.display = 'block';
                    const btn = document.getElementById('coldWalletTabBtn');
                    btn.style.borderBottom = '3px solid #4CAF50';
                    btn.style.color = '#333';
                    btn.style.fontWeight = '600';
                }
            }
            
            // Open disclaimer modal
            window.openDisclaimerModal = function() {
                document.getElementById('disclaimerModal').style.display = 'block';
            }
            
            // Close disclaimer modal
            window.closeDisclaimerModal = function() {
                document.getElementById('disclaimerModal').style.display = 'none';
            }
            
            // Open security notes modal
            window.openSecurityNotesModal = function() {
                document.getElementById('securityNotesModal').style.display = 'block';
            }
            
            // Close security notes modal
            window.closeSecurityNotesModal = function() {
                document.getElementById('securityNotesModal').style.display = 'none';
            }
            
            // Close modal when clicking outside
            window.onclick = function(event) {
                const helpModal = document.getElementById('helpModal');
                const disclaimerModal = document.getElementById('disclaimerModal');
                const securityNotesModal = document.getElementById('securityNotesModal');
                
                if (event.target == helpModal) {
                    helpModal.style.display = 'none';
                } else if (event.target == disclaimerModal) {
                    disclaimerModal.style.display = 'none';
                } else if (event.target == securityNotesModal) {
                    securityNotesModal.style.display = 'none';
                }
            }
            
            // Download the wallet page for offline use
            window.downloadWalletPage = function() {
                showInAppNotification('Preparing Download', 'Creating clean wallet file...', 'info');
                
                // Clone the current document
                const clonedDoc = document.documentElement.cloneNode(true);
                
                // Remove any dynamic content that shouldn't be saved
                // Remove any wallet data from displayed elements
                const elementsToClean = clonedDoc.querySelectorAll([
                    '#walletAddress',
                    '#walletBalance', 
                    '#walletUnconfirmed',
                    '#watchOnlyAddress',
                    '#watchOnlyBalance',
                    '#watchOnlyUnconfirmed',
                    '#transactionHistoryList',
                    '#currentUtxoList',
                    '#recipientAddress',
                    '#sendAmount'
                ].join(','));
                
                elementsToClean.forEach(el => {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                        el.value = '';
                    } else {
                        if (el.id === 'walletAddress') {
                            el.textContent = '-';
                        } else if (el.id === 'walletBalance' || el.id === 'watchOnlyBalance') {
                            el.textContent = '0.00000000 ALPHA';
                        } else if (el.id === 'transactionHistoryList') {
                            el.innerHTML = '<p style="color: #999; text-align: center;">No transactions yet</p>';
                        } else if (el.id === 'currentUtxoList') {
                            el.innerHTML = '<p style="color: #999; text-align: center;">No UTXOs loaded</p>';
                        } else {
                            el.textContent = '';
                        }
                    }
                });
                
                // Reset any inline styles that might have been set dynamically
                const dynamicElements = clonedDoc.querySelectorAll('[style*="display: block"], [style*="display: none"]');
                dynamicElements.forEach(el => {
                    // Reset to original display states
                    if (el.id === 'watchOnlySection' || el.id === 'transactionHistoryContainer') {
                        el.style.display = 'none';
                    }
                });
                
                // Clear any script-injected content
                const notificationContainer = clonedDoc.querySelector('#notificationContainer');
                if (notificationContainer) {
                    notificationContainer.innerHTML = '';
                }
                
                // Get the cleaned HTML
                const cleanHtml = '<!DOCTYPE html>\n' + clonedDoc.outerHTML;
                
                // Create blob and download
                const blob = new Blob([cleanHtml], { type: 'text/html;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'unicity-wallet.html';
                a.style.display = 'none';
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showInAppNotification('Download Complete', 'Clean wallet saved as unicity-wallet.html', 'success');
            }
            
            // ============================================
            // Transaction Debugging System
            // ============================================
            
            // SECURITY: Sanitize debug data to prevent private key leakage
            function sanitizeDebugData(data) {
                if (!data || typeof data !== 'object') return data;
                
                // List of sensitive field names to exclude
                const sensitiveFields = [
                    'privatekey', 'private_key', 'privateKey',
                    'masterprivatekey', 'master_private_key', 'masterPrivateKey',
                    'childprivatekey', 'child_private_key', 'childPrivateKey',
                    'secret', 'password', 'passphrase', 'seed', 'mnemonic',
                    'encryptedkey', 'encrypted_key', 'encryptedKey',
                    'wif', 'wifkey', 'wif_key', 'wifKey'
                ];
                
                // List of patterns that might contain private keys (hex or WIF format)
                const privateKeyPatterns = [
                    /^[0-9a-fA-F]{64}$/,  // 64 hex chars (private key)
                    /^[KL][1-9A-HJ-NP-Za-km-z]{51}$/,  // WIF format mainnet
                    /^[c][1-9A-HJ-NP-Za-km-z]{51}$/,   // WIF format testnet
                ];
                
                // Deep clone the object to avoid modifying the original
                const sanitized = JSON.parse(JSON.stringify(data));
                
                // Recursive function to sanitize nested objects
                function sanitizeObject(obj, path = '') {
                    for (const key in obj) {
                        if (!obj.hasOwnProperty(key)) continue;
                        
                        const fullPath = path ? `${path}.${key}` : key;
                        const lowerKey = key.toLowerCase();
                        const value = obj[key];
                        
                        // IMPORTANT: Never redact transaction IDs, hashes, or broadcast results - they are public info needed for debugging
                        const isTransactionData = lowerKey.includes('txid') || lowerKey.includes('tx_hash') || 
                                              lowerKey.includes('txhash') || lowerKey.includes('transaction_id') ||
                                              lowerKey.includes('transactionid') || key === 'hex' || 
                                              key === 'result' || lowerKey === 'result' || 
                                              lowerKey.includes('broadcast_result') || lowerKey.includes('broadcastresult');
                        
                        if (isTransactionData) {
                            // Keep transaction IDs, hex, and broadcast results as-is - they're public once broadcast
                            continue;
                        }
                        
                        // Check if field name suggests sensitive data
                        if (sensitiveFields.some(field => lowerKey.includes(field))) {
                            obj[key] = '[REDACTED]';
                            console.warn(`Debug sanitization: Redacted potentially sensitive field: ${fullPath}`);
                            continue;
                        }
                        
                        // Check if value looks like a private key
                        if (typeof value === 'string' && value.length > 50) {
                            if (privateKeyPatterns.some(pattern => pattern.test(value))) {
                                obj[key] = '[REDACTED - POTENTIAL PRIVATE KEY]';
                                console.warn(`Debug sanitization: Redacted potential private key in field: ${fullPath}`);
                                continue;
                            }
                        }
                        
                        // Check for wallet object that might contain keys
                        if (key === 'wallet' && typeof value === 'object') {
                            // Only keep safe wallet information
                            obj[key] = {
                                hasAddresses: !!(value.addresses && value.addresses.length > 0),
                                addressCount: value.addresses ? value.addresses.length : 0,
                                isBip32: value.isBip32 || false,
                                isEncrypted: value.isEncrypted || false,
                                createdAt: value.createdAt || null
                            };
                            console.warn(`Debug sanitization: Filtered wallet object in field: ${fullPath}`);
                            continue;
                        }
                        
                        // Recursively sanitize nested objects
                        if (typeof value === 'object' && value !== null) {
                            sanitizeObject(value, fullPath);
                        }
                    }
                }
                
                sanitizeObject(sanitized);
                return sanitized;
            }
            
            // Start a new transaction debug session
            function startTransactionDebug(operation) {
                const debugSession = {
                    id: Date.now().toString(36) + Math.random().toString(36).substr(2),
                    operation: operation,
                    startTime: new Date().toISOString(),
                    logs: [],
                    status: 'active',
                    
                    log: function(level, message, data = {}) {
                        // SECURITY: Sanitize data to ensure no private keys are logged
                        const sanitizedData = sanitizeDebugData(data);
                        
                        const logEntry = {
                            timestamp: new Date().toISOString(),
                            level: level,
                            message: message,
                            data: sanitizedData
                        };
                        this.logs.push(logEntry);
                        
                        // Also log to console for immediate visibility
                        const consoleMsg = `[TX Debug ${this.id}] [${level.toUpperCase()}] ${message}`;
                        if (data && Object.keys(data).length > 0) {
                            console.log(consoleMsg, data);
                        } else {
                            console.log(consoleMsg);
                        }
                    },
                    
                    complete: function(message) {
                        this.status = 'completed';
                        this.endTime = new Date().toISOString();
                        this.log('info', message || 'Debug session completed');
                        this.save();
                    },
                    
                    error: function(message, error) {
                        this.status = 'error';
                        this.endTime = new Date().toISOString();
                        this.log('error', message, { error: error });
                        this.save();
                    },
                    
                    save: function() {
                        console.log('[DEBUG] save() called for session:', this.id, 'operation:', this.operation);
                        console.log('[DEBUG] Before save - transactionDebugLog length:', window.transactionDebugLog.length);

                        // Add to global debug log
                        window.transactionDebugLog.push({
                            id: this.id,
                            operation: this.operation,
                            startTime: this.startTime,
                            endTime: this.endTime,
                            status: this.status,
                            logs: this.logs
                        });

                        console.log('[DEBUG] After save - transactionDebugLog length:', window.transactionDebugLog.length);

                        // Keep only last MAX_DEBUG_LOGS entries
                        if (window.transactionDebugLog.length > MAX_DEBUG_LOGS) {
                            window.transactionDebugLog = window.transactionDebugLog.slice(-MAX_DEBUG_LOGS);
                        }

                        // Save to localStorage for persistence
                        try {
                            localStorage.setItem('transactionDebugLog', JSON.stringify(window.transactionDebugLog));
                            console.log('[DEBUG] Saved to localStorage successfully');
                        } catch (e) {
                            console.error('Failed to save debug log to localStorage:', e);
                        }
                    }
                };

                window.currentTransactionDebug = debugSession;
                return debugSession;
            }
            
            // Load debug log from localStorage on startup
            function loadDebugLog() {
                try {
                    const saved = localStorage.getItem('transactionDebugLog');
                    if (saved) {
                        window.transactionDebugLog = JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Failed to load debug log from localStorage:', e);
                }
            }
            
            // Show transaction error with debug info
            function showTransactionError(title, message, debugSession) {
                // Log the error
                if (debugSession) {
                    debugSession.error(title, message);
                }
                
                // Show error notification with debug button
                const notificationId = Date.now().toString();
                const notification = document.createElement('div');
                notification.id = 'notification-' + notificationId;
                notification.className = 'notification notification-error';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    max-width: 400px;
                    padding: 16px;
                    background-color: #fef2f2;
                    border: 1px solid #fecaca;
                    border-radius: 8px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                    z-index: 9999;
                    animation: slideIn 0.3s ease-out;
                `;
                
                notification.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 8px 0; color: #dc2626; font-weight: 600;">${title}</h4>
                            <p style="margin: 0 0 12px 0; color: #7f1d1d;">${message}</p>
                            ${debugSession ? `
                                <button onclick="showTransactionDebugModal('${debugSession.id}')" 
                                        style="padding: 6px 12px; background-color: #dc2626; color: white; 
                                               border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    View Debug Info
                                </button>
                            ` : ''}
                        </div>
                        <button onclick="document.getElementById('notification-${notificationId}').remove()" 
                                style="background: none; border: none; color: #6b7280; cursor: pointer; 
                                       font-size: 20px; line-height: 1; padding: 0; margin-left: 12px;">
                            
                        </button>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                // Auto-remove after 10 seconds
                setTimeout(() => {
                    const elem = document.getElementById('notification-' + notificationId);
                    if (elem) elem.remove();
                }, 10000);
            }
            
            // Validate Bech32 address
            function validateBech32Address(address) {
                if (!address || !address.startsWith('alpha1')) {
                    throw new Error('Address must start with alpha1');
                }
                
                // Basic length check
                if (address.length < 42 || address.length > 62) {
                    throw new Error('Invalid address length');
                }
                
                // Check for invalid characters
                const validChars = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
                const addrLower = address.toLowerCase();
                
                for (let i = 6; i < addrLower.length; i++) {
                    if (!validChars.includes(addrLower[i])) {
                        throw new Error(`Invalid character '${address[i]}' at position ${i}`);
                    }
                }
                
                return true;
            }
            
            // Load debug log on startup
            document.addEventListener('DOMContentLoaded', function() {
                loadDebugLog();

                // Initialize TXO classification cache from IndexedDB
                loadTxoCacheFromIndexedDB().then(() => {
                    console.log('[Init] TXO cache initialized with', txoClassificationCache.size, 'entries');
                }).catch(err => {
                    console.warn('[Init] Failed to load TXO cache:', err);
                });

                // Add debug button to main interface
                const debugButton = document.createElement('button');
                debugButton.innerHTML = ' Debug';
                debugButton.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    padding: 10px 20px;
                    background-color: #6b7280;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    z-index: 1000;
                    font-weight: 600;
                `;
                debugButton.onclick = () => showTransactionDebugModal();
                document.body.appendChild(debugButton);
            });
            
            // Show in-browser notification
            function showInAppNotification(title, message, type = 'info') {
                const container = document.getElementById('notificationContainer');
                
                // Limit to 3 visible notifications
                const visibleNotifications = container.querySelectorAll('.notification:not(.removing)');
                if (visibleNotifications.length >= 3) {
                    // Remove the oldest notification
                    removeNotification(visibleNotifications[0]);
                }
                
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                
                // Choose icon based on type
                let icon = '';
                switch(type) {
                    case 'success':
                        icon = '';
                        break;
                    case 'error':
                        icon = '';
                        break;
                    case 'warning':
                        icon = '';
                        break;
                    case 'info':
                    default:
                        icon = '';
                        break;
                }
                
                // Build notification DOM safely (no innerHTML with user/server data)
                const iconDiv = document.createElement('div');
                iconDiv.className = 'notification-icon';
                iconDiv.textContent = icon;

                const titleDiv = document.createElement('div');
                titleDiv.className = 'notification-title';
                titleDiv.textContent = title;

                const msgDiv = document.createElement('div');
                msgDiv.className = 'notification-message';
                msgDiv.textContent = message;

                const contentDiv = document.createElement('div');
                contentDiv.className = 'notification-content';
                contentDiv.appendChild(titleDiv);
                contentDiv.appendChild(msgDiv);

                const closeBtn = document.createElement('button');
                closeBtn.className = 'notification-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => removeNotification(notification);

                notification.appendChild(iconDiv);
                notification.appendChild(contentDiv);
                notification.appendChild(closeBtn);
                
                // Add to container
                container.appendChild(notification);
                
                // Auto-remove after 8 seconds
                setTimeout(() => removeNotification(notification), 8000);
            }
            
            // Remove notification with animation
            function removeNotification(notification) {
                if (!notification || notification.classList.contains('removing')) return;
                
                notification.classList.add('removing');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }
            
            // Make showInAppNotification globally accessible
            window.showInAppNotification = showInAppNotification;
            
            // Show system notification (only for transactions)
            function showNotification(title, body, icon = null) {
                // Determine if this is a transaction notification
                const isTransaction = title.includes('Transaction') || title.includes('Incoming') || 
                                    title.includes('Outgoing') || title.includes('Confirmed');
                
                // Always show in-app notification
                let type = 'info';
                if (title.includes('') || title.includes('Confirmed')) type = 'success';
                else if (title.includes('') || title.includes('Incoming')) type = 'success';
                else if (title.includes('') || title.includes('Outgoing')) type = 'info';
                else if (title.includes('') || title.includes('Block')) type = 'info';
                else if (title.includes('Error') || title.includes('Failed')) type = 'error';
                
                showInAppNotification(title, body, type);
                
                // Only show system notification for transactions
                if (!isTransaction) return;
                
                // Show system notification if supported
                if (!('Notification' in window)) {
                    console.log('This browser does not support system notifications');
                    return;
                }
                
                if (Notification.permission === 'granted') {
                    const notification = new Notification(title, {
                        body: body,
                        icon: icon || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiMzNGQzOTkiIHN0cm9rZS13aWR0aD0iMiI+PHJlY3QgeD0iMyIgeT0iMTEiIHdpZHRoPSIxOCIgaGVpZ2h0PSIxMSIgcng9IjIiIHJ5PSIyIi8+PHBhdGggZD0iTTcgMTFWN2E1IDUgMCAwIDEgMTAgMHY0Ii8+PC9zdmc+',
                        tag: 'alpha-wallet-' + Date.now(),
                        requireInteraction: false,
                        silent: false
                    });
                    
                    setTimeout(() => notification.close(), 5000);
                    
                    notification.onclick = function() {
                        window.focus();
                        notification.close();
                    };
                }
            }
            
            // Helper to compare arrays for changes and detect specific changes
            function analyzeTransactionChanges(oldArray, newArray) {
                const changes = {
                    hasChanged: false,
                    newTransactions: [],
                    confirmedTransactions: []
                };
                
                if (!oldArray || !newArray) {
                    changes.hasChanged = true;
                    return changes;
                }
                
                if (oldArray.length !== newArray.length) {
                    changes.hasChanged = true;
                }
                
                // Create maps for comparison (using lowercase txids)
                const oldMap = new Map();
                oldArray.forEach(item => {
                    const txid = (item.tx_hash || item.txid || '').toLowerCase();
                    oldMap.set(txid, item);
                });
                
                const newMap = new Map();
                newArray.forEach(item => {
                    const txid = (item.tx_hash || item.txid || '').toLowerCase();
                    newMap.set(txid, item);
                });
                
                // Check for new transactions
                newMap.forEach((newItem, txid) => {
                    if (!oldMap.has(txid)) {
                        changes.newTransactions.push(newItem);
                        changes.hasChanged = true;
                    }
                });
                
                // Check for confirmed transactions (height changed from 0 to positive)
                newMap.forEach((newItem, txid) => {
                    const oldItem = oldMap.get(txid);
                    if (oldItem && oldItem.height === 0 && newItem.height > 0) {
                        changes.confirmedTransactions.push(newItem);
                        changes.hasChanged = true;
                    }
                });
                
                return changes;
            }
            
            // Helper to compare arrays for changes
            function hasArrayChanged(oldArray, newArray) {
                return analyzeTransactionChanges(oldArray, newArray).hasChanged;
            }

            // Compare UTXO arrays including vesting fields to avoid redundant reprocessing
            function hasUtxoArrayChanged(oldUtxos, newUtxos) {
                if (!oldUtxos || !newUtxos) return true;
                if (oldUtxos.length !== newUtxos.length) return true;
                const oldKeys = new Map();
                for (const u of oldUtxos) {
                    oldKeys.set(`${u.tx_hash}:${u.tx_pos}`, { value: u.value, height: u.height, vested: u.vested });
                }
                for (const u of newUtxos) {
                    const key = `${u.tx_hash}:${u.tx_pos}`;
                    const old = oldKeys.get(key);
                    if (!old) return true;
                    if (old.value !== u.value || old.height !== u.height || old.vested !== u.vested) return true;
                }
                return false;
            }
            
            // Update refreshBalance to store current data
            const originalRefreshBalance = refreshBalance;
            refreshBalance = function() {
                originalRefreshBalance();
                
                // Also fetch and store current transactions for export
                if (wallet.addresses && wallet.addresses.length > 0) {
                    const scriptHash = addressToScriptHash(wallet.addresses[0].address);
                    if (scriptHash) {
                        // Store transactions
                        electrumRequest('blockchain.scripthash.get_history', [scriptHash], function(result) {
                            if (result) {
                                // Regular wallet transaction history fetched successfully
                                // Analyze changes
                                const changes = analyzeTransactionChanges(currentTransactions, result);
                                
                                if (changes.hasChanged) {
                                    // Only show notifications if not initial load
                                    if (!isInitialLoad && changes.newTransactions.length > 0) {
                                        // Only show notifications for truly new unconfirmed transactions
                                        // When a new tx arrives, we should only notify about that one
                                        const unconfirmedNewTxs = changes.newTransactions.filter(tx => tx.height === 0);
                                        
                                        // If we have many new transactions, it's likely a data refresh issue
                                        // Only notify if we have 1-2 new unconfirmed transactions
                                        if (unconfirmedNewTxs.length <= 2) {
                                            unconfirmedNewTxs.forEach(tx => {
                                        const txid = tx.tx_hash || tx.txid;
                                        const shortTxid = txid.substring(0, 8) + '...' + txid.substring(txid.length - 8);
                                        
                                        // Fetch transaction details to determine direction
                                        electrumRequest('blockchain.transaction.get', [txid, true], function(txDetails) {
                                            // Cache the transaction details
                                            if (txDetails) {
                                                transactionDetailsCache[txid] = txDetails;
                                            }
                                            
                                            let notificationTitle, notificationBody;
                                            
                                            if (txDetails) {
                                                const address = wallet.addresses && wallet.addresses.length > 0 ? 
                                                    wallet.addresses[0].address : watchOnlyAddressValue;
                                                const result = calculateTransactionAmount(txDetails, address);
                                                const amount = SatoshiMath.satoshisToAlpha(Math.abs(result.netAmount));
                                                
                                                if (result.isIncoming) {
                                                    notificationTitle = tx.height === 0 ? 
                                                        ' Incoming Transaction' : 
                                                        ' Incoming Transaction Confirmed';
                                                    notificationBody = `Received ${amount} ALPHA${tx.height > 0 ? ' in block ' + tx.height : ' (unconfirmed)'}`;
                                                } else {
                                                    notificationTitle = tx.height === 0 ? 
                                                        ' Outgoing Transaction' : 
                                                        ' Outgoing Transaction Confirmed';
                                                    notificationBody = `Sent ${amount} ALPHA${tx.height > 0 ? ' in block ' + tx.height : ' (unconfirmed)'}`;
                                                }
                                            } else {
                                                // Fallback if we can't get details
                                                notificationTitle = tx.height === 0 ? 
                                                    ' New Transaction' : 
                                                    ' Transaction Confirmed';
                                                notificationBody = `Transaction ${shortTxid}${tx.height > 0 ? ' in block ' + tx.height : ' detected'}`;
                                            }
                                            
                                            showNotification(notificationTitle, notificationBody);
                                        });
                                            });
                                        }
                                    }
                                    
                                    // Show notifications for newly confirmed transactions (always show these)
                                    if (!isInitialLoad && changes.confirmedTransactions.length > 0) {
                                        changes.confirmedTransactions.forEach(tx => {
                                        const txid = tx.tx_hash || tx.txid;
                                        const shortTxid = txid.substring(0, 8) + '...' + txid.substring(txid.length - 8);
                                        
                                        showNotification(
                                            ' Transaction Confirmed',
                                            `Transaction ${shortTxid} confirmed in block ${tx.height}`
                                        );
                                        });
                                    }
                                    
                                    currentTransactions = result;
                                    updateTransactionHistory();
                                }
                            }
                        });
                        
                        // Store UTXOs
                        electrumRequest('blockchain.scripthash.listunspent', [scriptHash], function(result) {
                            if (result) {
                                const currentAddress = wallet.addresses[0].address;
                                const newUtxos = result.map(utxo => ({
                                    ...utxo,
                                    address: currentAddress
                                }));

                                // Only reprocess if UTXOs actually changed
                                const utxosChanged = hasUtxoArrayChanged(currentUtxos, newUtxos);
                                currentUtxos = newUtxos;
                                updateCommonBalance();
                                updateUtxoListDisplay();

                                // Only reprocess classification when UTXOs changed
                                if (utxosChanged) {
                                    processIncomingUtxos(currentUtxos, currentAddress);
                                }
                            }
                        });
                    }
                }
            };
            
            // Event listeners for UTXO buttons
            exportUtxoBtn.onclick = exportUtxoData;
            importUtxoBtn.onclick = importUtxoData;
            clearUtxoBtn.onclick = clearOfflineUtxoData;
            
            // Load offline data on startup
            loadOfflineUtxoData();
            
            // Initial button state update
            updateCommonBalance();
            
            // Request notification permission
            requestNotificationPermission();
            
            // Transaction functionality
            let pendingTransactions = [];
            
            // Calculate maximum sendable amount
            window.calculateMaxAmount = function() {
                // Use vesting-filtered UTXOs based on current mode
                let availableUtxos = getFilteredUtxos();

                // Get per-address cache for classification check
                const currentAddress = getCurrentVestingAddress();
                const addressCache = currentAddress ? getAddressVestingCache(currentAddress) : null;
                const classifiedUtxos = addressCache ? addressCache.classifiedUtxos : { vested: [], unvested: [], all: [] };

                // If classification not done yet, fall back to original logic
                if (availableUtxos.length === 0 && classifiedUtxos.all.length === 0) {
                    const consumedUtxos = getConsumedUtxos();
                    if (currentUtxos && currentUtxos.length > 0) {
                        availableUtxos = currentUtxos.filter(utxo => {
                            const utxoKey = `${utxo.tx_hash || utxo.txid}:${utxo.tx_pos || utxo.vout}`;
                            return !consumedUtxos.has(utxoKey);
                        });
                    } else if (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0) {
                        availableUtxos = offlineUtxoData.utxos.filter(utxo => {
                            const utxoKey = `${utxo.txid}:${utxo.vout}`;
                            return !consumedUtxos.has(utxoKey);
                        });
                    }
                }

                if (availableUtxos.length === 0) {
                    const modeText = vestingMode === 'all' ? '' : ` (${vestingMode} mode)`;
                    showInAppNotification('No UTXOs', `No UTXOs available to calculate maximum amount${modeText}`, 'warning');
                    return;
                }

                // Calculate total available using BigInt for precision
                const totalAvailable = SatoshiMath.sum(availableUtxos.map(u => u.value));

                // Calculate fees - we need one transaction per UTXO in Alpha
                const feePerTx = SatoshiMath.FEE_PER_TX;
                const totalFees = BigInt(availableUtxos.length) * feePerTx;

                // Calculate maximum sendable amount
                const maxSendable = totalAvailable - totalFees;

                if (maxSendable <= 0n) {
                    showInAppNotification('Insufficient Balance', 'Total balance is too low to cover transaction fees', 'error');
                    return;
                }

                // Convert to ALPHA and set the amount field
                const maxAlphaStr = SatoshiMath.satoshisToAlpha(maxSendable);
                document.getElementById('sendAmount').value = maxAlphaStr;

                // Show notification with vesting mode info
                const feesAlphaStr = SatoshiMath.satoshisToAlpha(totalFees);
                const modeText = vestingMode === 'all' ? '' : ` [${vestingMode}]`;
                showInAppNotification('Max Amount', `Maximum sendable${modeText}: ${maxAlphaStr} ALPHA (${availableUtxos.length} UTXOs, ${feesAlphaStr} ALPHA in fees)`, 'info');
            };
            
            // Prepare send transaction with enhanced debugging
            window.prepareSendTransaction = function() {
                // Start debug session
                const debugSession = startTransactionDebug('prepare_send');

                try {
                    const recipientAddress = document.getElementById('recipientAddress').value.trim();
                    const sendAmountStr = document.getElementById('sendAmount').value.trim();

                    // Parse amount using BigInt for precision
                    let amountSatoshis;
                    try {
                        amountSatoshis = SatoshiMath.alphaToSatoshis(sendAmountStr);
                    } catch (parseError) {
                        debugSession.log('error', 'Amount parsing failed', { error: parseError.message, input: sendAmountStr });
                        showTransactionError('Invalid Amount Format', 'Please enter a valid ALPHA amount (e.g., 1.23456789)', debugSession);
                        return;
                    }

                    debugSession.log('info', 'Starting transaction preparation', {
                        recipientAddress,
                        sendAmount: sendAmountStr,
                        amountSatoshis: amountSatoshis.toString(),
                        timestamp: new Date().toISOString()
                    });

                    // Validate inputs with detailed error reporting
                    if (!recipientAddress) {
                        const error = 'No recipient address provided';
                        debugSession.log('error', error);
                        showTransactionError(error, 'Please enter a recipient address', debugSession);
                        return;
                    }

                    if (!recipientAddress.startsWith('alpha1')) {
                        const error = 'Invalid address format';
                        debugSession.log('error', error, { providedAddress: recipientAddress });
                        showTransactionError(error, 'Address must start with "alpha1"', debugSession);
                        return;
                    }

                    // Validate address checksum
                    try {
                        validateBech32Address(recipientAddress);
                        debugSession.log('success', 'Address validation passed');
                    } catch (addrError) {
                        debugSession.log('error', 'Address validation failed', { error: addrError.message });
                        showTransactionError('Invalid Address', `Address validation failed: ${addrError.message}`, debugSession);
                        return;
                    }

                    if (!sendAmountStr || amountSatoshis <= 0n) {
                        const error = 'Invalid amount';
                        debugSession.log('error', error, { providedAmount: sendAmountStr, satoshis: amountSatoshis.toString() });
                        showTransactionError(error, 'Please enter a valid amount greater than 0', debugSession);
                        return;
                    }
                
                    // Check if wallet is loaded - but allow watch-only mode
                    if (!watchOnlyMode && !wallet.masterPrivateKey && !wallet.childPrivateKey) {
                        const error = 'No wallet loaded';
                        debugSession.log('error', error, { watchOnlyMode, hasKeys: false });
                        showTransactionError(error, 'Please create or import a wallet first', debugSession);
                        return;
                    }
                    
                    debugSession.log('info', 'Wallet check passed', {
                        watchOnlyMode,
                        hasPrivateKeys: !!(wallet.masterPrivateKey || wallet.childPrivateKey),
                        addressCount: wallet.addresses ? wallet.addresses.length : 0
                    });
                
                // Check if we have a wallet address (or watch-only address)
                if (!watchOnlyMode && (!wallet.addresses || wallet.addresses.length === 0)) {
                    alert('No wallet address available. Please generate an address first.');
                    return;
                }
                
                // In watch-only mode, check if we have an address
                if (watchOnlyMode && !watchOnlyAddressValue) {
                    alert('No watch-only address set. Please enter an address to monitor.');
                    return;
                }
                
                    // Check if we have UTXOs with detailed logging
                    // Use vesting-filtered UTXOs based on current mode
                    const consumedUtxos = getConsumedUtxos();

                    // Get per-address cache for classification check
                    const currentAddress = getCurrentVestingAddress();
                    const addressCache = currentAddress ? getAddressVestingCache(currentAddress) : null;
                    const classifiedUtxos = addressCache ? addressCache.classifiedUtxos : { vested: [], unvested: [], all: [] };

                    debugSession.log('info', 'Checking UTXO availability', {
                        hasCurrentUtxos: !!(currentUtxos && currentUtxos.length > 0),
                        currentUtxosCount: currentUtxos ? currentUtxos.length : 0,
                        hasOfflineUtxos: !!(offlineUtxoData && offlineUtxoData.utxos),
                        offlineUtxosCount: offlineUtxoData?.utxos ? offlineUtxoData.utxos.length : 0,
                        consumedCount: consumedUtxos.size,
                        vestingMode: vestingMode,
                        classifiedVested: classifiedUtxos.vested.length,
                        classifiedUnvested: classifiedUtxos.unvested.length
                    });

                    // Get UTXOs filtered by vesting mode (already excludes consumed UTXOs)
                    let availableUtxos = getFilteredUtxos();

                    // If classification not done yet, fall back to original logic
                    if (availableUtxos.length === 0 && classifiedUtxos.all.length === 0) {
                        if (currentUtxos && currentUtxos.length > 0) {
                            availableUtxos = currentUtxos.filter(utxo => {
                                const utxoKey = `${utxo.tx_hash || utxo.txid}:${utxo.tx_pos || utxo.vout}`;
                                const isConsumed = consumedUtxos.has(utxoKey);
                                if (isConsumed) {
                                    debugSession.log('debug', `UTXO consumed: ${utxoKey}`);
                                }
                                return !isConsumed;
                            });
                            debugSession.log('info', `Filtered ${availableUtxos.length} available UTXOs from ${currentUtxos.length} current UTXOs (classification pending)`);
                        } else if (offlineUtxoData && offlineUtxoData.utxos && offlineUtxoData.utxos.length > 0) {
                            availableUtxos = offlineUtxoData.utxos.filter(utxo => {
                                const utxoKey = `${utxo.txid}:${utxo.vout}`;
                                return !consumedUtxos.has(utxoKey);
                            });
                            debugSession.log('info', `Using ${availableUtxos.length} offline UTXOs`);
                        }
                    } else {
                        debugSession.log('info', `Using ${availableUtxos.length} vesting-filtered UTXOs (mode: ${vestingMode})`);
                    }
                    
                    if (availableUtxos.length === 0) {
                        const error = 'No UTXOs available';
                        debugSession.log('error', error, {
                            reason: currentUtxos ? 'All UTXOs consumed' : 'No UTXO data loaded'
                        });
                        showTransactionError(error, 'Please load UTXO data first (either connect online or import UTXO file)', debugSession);
                        return;
                    }

                // Get the sender address (wallet address or watch-only address)
                const senderAddress = watchOnlyMode ? watchOnlyAddressValue : wallet.addresses[0].address;

                    // Collect UTXOs for the required amount
                    debugSession.log('info', 'Collecting UTXOs for transaction', {
                        amountSatoshis: amountSatoshis.toString(),
                        amountAlpha: sendAmountStr,
                        availableUtxosCount: availableUtxos.length,
                        senderAddress
                    });

                    const txPlan = collectUtxosForAmount(availableUtxos, amountSatoshis, recipientAddress, senderAddress);
                    
                    if (!txPlan.success) {
                        debugSession.log('error', 'Transaction planning failed', {
                            error: txPlan.error,
                            details: txPlan.details || {}
                        });
                        showTransactionError('Transaction Planning Failed', txPlan.error, debugSession);
                        return;
                    }
                    
                    debugSession.log('success', 'Transaction plan created', {
                        transactionCount: txPlan.transactions.length,
                        totalInputs: txPlan.transactions.reduce((sum, tx) => sum + 1, 0),
                        totalOutputs: txPlan.transactions.reduce((sum, tx) => sum + tx.outputs.length, 0),
                        totalFees: txPlan.transactions.reduce((sum, tx) => sum + tx.fee, 0)
                    });
                    
                    // Store transaction plan in debug session for later reference
                    debugSession.transactionPlan = txPlan;
                
                    // In watch-only mode, export transaction template instead of showing confirmation
                    if (watchOnlyMode) {
                        debugSession.log('info', 'Exporting transaction template (watch-only mode)');
                        exportTransactionTemplate(txPlan.transactions, recipientAddress, sendAmountStr, senderAddress);
                    } else {
                        debugSession.log('info', 'Showing transaction confirmation dialog');
                        showTransactionConfirmation(txPlan.transactions, recipientAddress, sendAmountStr);
                    }
                    
                    debugSession.complete('Transaction preparation completed successfully');
                    
                } catch (error) {
                    debugSession.log('critical', 'Unexpected error in prepareSendTransaction', {
                        error: error.message,
                        stack: error.stack
                    });
                    showTransactionError('Unexpected Error', `An unexpected error occurred: ${error.message}`, debugSession);
                }
            };
            
            // Collect UTXOs for required amount
            function collectUtxosForAmount(utxoList, amountSatoshis, recipientAddress, senderAddress) {
                // Sort UTXOs by value (ascending) to minimize number of transactions
                const sortedUtxos = [...utxoList].sort((a, b) => a.value - b.value);

                // Calculate total available using BigInt for precision
                const totalAvailable = SatoshiMath.sum(sortedUtxos.map(u => u.value));
                const amountBI = BigInt(amountSatoshis);

                if (totalAvailable < amountBI) {
                    return {
                        success: false,
                        error: `Insufficient funds. Available: ${SatoshiMath.satoshisToAlpha(totalAvailable)} ALPHA, Required: ${SatoshiMath.satoshisToAlpha(amountBI)} ALPHA`
                    };
                }

                const transactions = [];
                let remainingAmount = amountBI;
                const feePerTx = SatoshiMath.FEE_PER_TX;

                // Since Alpha requires one input per transaction, we need to create multiple transactions
                for (const utxo of sortedUtxos) {
                    if (remainingAmount <= 0n) break;

                    const utxoValue = BigInt(utxo.value);
                    let txAmount;
                    let changeAmount = 0n;

                    if (utxoValue >= remainingAmount + feePerTx) {
                        // This UTXO covers the remaining amount plus fee
                        txAmount = remainingAmount;
                        changeAmount = utxoValue - remainingAmount - feePerTx;
                        remainingAmount = 0n;
                    } else {
                        // Use entire UTXO minus fee
                        txAmount = utxoValue - feePerTx;
                        remainingAmount -= txAmount;

                        if (txAmount <= 0n) {
                            // UTXO too small to cover fee
                            continue;
                        }
                    }

                    transactions.push({
                        input: utxo,
                        outputs: [
                            { address: recipientAddress, value: Number(txAmount) }  // Convert for compatibility
                        ],
                        fee: Number(feePerTx),
                        changeAmount: Number(changeAmount),
                        changeAddress: senderAddress // Send change back to sender address
                    });

                    // Add change output if needed (but avoid dust outputs)
                    // Dust threshold: 546 satoshis is typical for P2WPKH
                    const DUST_THRESHOLD = SatoshiMath.DUST_THRESHOLD;
                    if (changeAmount > DUST_THRESHOLD) {
                        transactions[transactions.length - 1].outputs.push({
                            address: senderAddress,
                            value: Number(changeAmount)  // Convert for compatibility
                        });
                    } else if (changeAmount > 0n) {
                        // If change is dust, add it to the fee instead
                        console.log(`Change amount ${changeAmount} is below dust threshold, adding to fee`);
                    }
                }

                if (remainingAmount > 0n) {
                    return {
                        success: false,
                        error: `Unable to collect enough UTXOs. Short by ${SatoshiMath.satoshisToAlpha(remainingAmount)} ALPHA after fees.`
                    };
                }
                
                // Apply dust rebalancing
                const rebalancedTransactions = rebalanceDustOutputs(transactions, recipientAddress, senderAddress, sortedUtxos, feePerTx);
                
                return {
                    success: true,
                    transactions: rebalancedTransactions
                };
            }
            
            // Rebalance transactions to avoid dust outputs
            function rebalanceDustOutputs(transactions, recipientAddress, senderAddress, availableUtxos, feePerTx) {
                const DUST_THRESHOLD = 546;
                
                // First pass: rebalance recipient dust outputs across transactions
                for (let i = 0; i < transactions.length; i++) {
                    const tx = transactions[i];
                    const recipientOutput = tx.outputs.find(o => o.address === recipientAddress);
                    
                    if (recipientOutput && recipientOutput.value < DUST_THRESHOLD && transactions.length > 1) {
                        // Find another transaction to rebalance with
                        for (let j = 0; j < transactions.length; j++) {
                            if (i === j) continue;
                            
                            const otherTx = transactions[j];
                            const otherRecipientOutput = otherTx.outputs.find(o => o.address === recipientAddress);
                            
                            if (otherRecipientOutput) {
                                // Calculate how much we need to move to make both outputs non-dust
                                const totalAmount = recipientOutput.value + otherRecipientOutput.value;
                                const halfAmount = Math.floor(totalAmount / 2);
                                
                                if (halfAmount > DUST_THRESHOLD) {
                                    // Rebalance the outputs
                                    recipientOutput.value = halfAmount;
                                    otherRecipientOutput.value = totalAmount - halfAmount;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Second pass: handle dust change outputs
                const finalTransactions = [];
                const usedUtxos = new Set(transactions.map(tx => `${tx.input.txid}:${tx.input.vout}`));
                
                for (const tx of transactions) {
                    finalTransactions.push(tx);
                    
                    // Check if we have dust change that needs to be handled
                    if (tx.changeAmount > 0 && tx.changeAmount <= DUST_THRESHOLD) {
                        const recipientOutput = tx.outputs.find(o => o.address === recipientAddress);
                        
                        if (recipientOutput && recipientOutput.value > DUST_THRESHOLD * 2) {
                            // Split the recipient output to create non-dust change
                            const halfRecipientAmount = Math.floor(recipientOutput.value / 2);
                            recipientOutput.value = halfRecipientAmount;
                            
                            // Create proper change output
                            const newChangeAmount = tx.input.value - halfRecipientAmount - tx.fee;
                            if (newChangeAmount > DUST_THRESHOLD) {
                                tx.outputs.push({
                                    address: senderAddress,
                                    value: newChangeAmount
                                });
                                tx.changeAmount = newChangeAmount;
                                
                                // Now we need to create a follow-up transaction for the remaining recipient amount
                                // Find an unused UTXO
                                const nextUtxo = availableUtxos.find(utxo => 
                                    !usedUtxos.has(`${utxo.txid}:${utxo.vout}`)
                                );
                                
                                if (nextUtxo) {
                                    // Create follow-up transaction
                                    const remainingRecipientAmount = recipientOutput.value;
                                    const followUpTx = {
                                        input: nextUtxo,
                                        outputs: [
                                            { address: recipientAddress, value: remainingRecipientAmount }
                                        ],
                                        fee: feePerTx,
                                        changeAmount: nextUtxo.value - remainingRecipientAmount - feePerTx,
                                        changeAddress: senderAddress
                                    };
                                    
                                    // Add change output if non-dust
                                    if (followUpTx.changeAmount > DUST_THRESHOLD) {
                                        followUpTx.outputs.push({
                                            address: senderAddress,
                                            value: followUpTx.changeAmount
                                        });
                                    }
                                    
                                    finalTransactions.push(followUpTx);
                                    usedUtxos.add(`${nextUtxo.txid}:${nextUtxo.vout}`);
                                    console.log(`Created follow-up transaction to handle dust change rebalancing`);
                                }
                            }
                        }
                    }
                }
                
                return finalTransactions;
            }
            
            // Show transaction confirmation modal
            function showTransactionConfirmation(transactions, recipientAddress, totalAmount) {
                pendingTransactions = transactions;
                
                // Log transaction details for debugging
                if (currentTransactionDebug) {
                    currentTransactionDebug.log('info', 'Showing transaction confirmation', {
                        recipientAddress,
                        totalAmount,
                        transactionCount: transactions.length
                    });
                }
                
                let detailsHtml = `
                    <div style="margin-bottom: 20px;">
                        <strong>Recipient:</strong> <span style="font-family: monospace; word-break: break-all;">${recipientAddress}</span>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>Total Amount:</strong> ${SatoshiMath.satoshisToAlpha(SatoshiMath.alphaToSatoshis(totalAmount))} ALPHA
                    </div>
                    <div style="margin-bottom: 20px;">
                        <strong>Number of Transactions:</strong> ${transactions.length}
                    </div>
                    <div style="border-top: 1px solid #e5e7eb; padding-top: 15px;">
                        <h4>Transaction Details:</h4>
                `;
                
                let totalFees = 0;
                transactions.forEach((tx, index) => {
                    totalFees += tx.fee;
                    detailsHtml += `
                        <div style="margin-top: 15px; padding: 10px; background: #f9fafb; border-radius: 8px;">
                            <div><strong>Transaction ${index + 1}:</strong></div>
                            <div style="margin-top: 5px; font-size: 0.9em;">
                                <div>Input UTXO: ${SatoshiMath.satoshisToAlpha(tx.input.value)} ALPHA</div>
                                <div>Send to recipient: ${SatoshiMath.satoshisToAlpha(tx.outputs[0].value)} ALPHA</div>
                                ${tx.changeAmount > 0 ? `<div>Change to wallet: ${SatoshiMath.satoshisToAlpha(tx.changeAmount)} ALPHA</div>` : ''}
                                <div>Fee: ${SatoshiMath.satoshisToAlpha(tx.fee)} ALPHA</div>
                            </div>
                        </div>
                    `;
                });
                
                detailsHtml += `
                    </div>
                    <div style="margin-top: 20px; padding: 10px; background: #fef3c7; border-radius: 8px;">
                        <strong>Total Fees:</strong> ${SatoshiMath.satoshisToAlpha(totalFees)} ALPHA
                    </div>
                `;
                
                document.getElementById('txConfirmDetails').innerHTML = detailsHtml;
                document.getElementById('txConfirmModal').style.display = 'block';
            }
            
            // Show transaction confirmation for imported templates
            function showTransactionTemplateConfirmation(transactionTemplates, recipientAddress, totalAmount) {
                // Convert templates back to transaction format
                const transactions = transactionTemplates.map(template => ({
                    input: template.inputs[0],
                    outputs: template.outputs,
                    fee: template.fee,
                    changeAmount: template.changeAmount,
                    changeAddress: template.changeAddress
                }));
                
                // Use the regular confirmation modal
                showTransactionConfirmation(transactions, recipientAddress, totalAmount);
            }
            
            // Cancel transaction
            window.cancelTransaction = function() {
                pendingTransactions = [];
                document.getElementById('txConfirmModal').style.display = 'none';
            };
            
            // Confirm and sign transactions
            window.confirmAndSignTransactions = function() {
                if (pendingTransactions.length === 0) return;
                
                try {
                    const signedTransactions = [];
                    
                    // Sign each transaction
                    for (const txPlan of pendingTransactions) {
                        try {
                            const signedTx = createAndSignTransaction(txPlan);
                            signedTransactions.push(signedTx);
                            
                            // Log signed transaction for debugging
                            if (currentTransactionDebug) {
                                currentTransactionDebug.log('success', 'Transaction signed', {
                                    txid: signedTx.txid,
                                    size: signedTx.raw ? signedTx.raw.length / 2 : 0,
                                    hex: signedTx.raw,
                                    inputs: txPlan.input ? [{
                                        txid: txPlan.input.txid,
                                        vout: txPlan.input.vout,
                                        value: txPlan.input.value
                                    }] : [],
                                    outputs: txPlan.outputs
                                });
                            }
                        } catch (txError) {
                            console.error('Error signing individual transaction:', txError);
                            if (currentTransactionDebug) {
                                currentTransactionDebug.log('error', 'Failed to sign transaction', {
                                    error: txError.message,
                                    stack: txError.stack,
                                    txPlan: txPlan
                                });
                            }
                            throw txError;
                        }
                    }
                    
                    
                    // Check if we're online (electrumSocket is defined in the connection scope)
                    // For now, we'll check if we can access the Electrum connection
                    const isOnline = (typeof electrumSocket !== 'undefined' && electrumSocket && electrumSocket.readyState === WebSocket.OPEN);
                    
                    if (isOnline) {
                        // Broadcast transactions
                        broadcastTransactions(signedTransactions);
                    } else {
                        // Save transactions for offline broadcast
                        saveTransactionsOffline(signedTransactions);
                    }
                    
                    // Clear form and close modal
                    document.getElementById('recipientAddress').value = '';
                    document.getElementById('sendAmount').value = '';
                    document.getElementById('txConfirmModal').style.display = 'none';
                    pendingTransactions = [];
                    
                } catch (error) {
                    showInAppNotification('Signing Failed', 'Error signing transactions: ' + error.message, 'error');
                    console.error('Signing error:', error);
                }
            };
            
            // Create and sign a transaction
            function createAndSignTransaction(txPlan) {
                
                // Get the private key
                const privateKeyHex = wallet.childPrivateKey || wallet.masterPrivateKey;
                if (!privateKeyHex) {
                    throw new Error('No private key available');
                }
                
                
                const ec = new elliptic.ec('secp256k1');
                const keyPair = ec.keyFromPrivate(privateKeyHex, 'hex');
                const publicKey = keyPair.getPublic(true, 'hex'); // compressed
                
                // Verify the public key matches our wallet address
                const pubKeyHash = CryptoJS.RIPEMD160(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey))).toString();
                
                // Check if this pubkey hash matches the wallet address
                const decoded = decodeBech32(wallet.addresses[0].address);
                if (decoded) {
                    const addressPubKeyHash = decoded.data.map(b => b.toString(16).padStart(2, '0')).join('');
                    if (pubKeyHash !== addressPubKeyHash) {
                        // CRITICAL FIX: This is NOT just a warning - it's a fatal error
                        // If the signing key doesn't match the address, the transaction will fail
                        // at the blockchain level with: mandatory-script-verify-flag-failed
                        // We must abort the transaction to prevent user confusion
                        const errorMsg = `CRITICAL: Wallet integrity error. The private key does not match the wallet address. ` +
                            `Expected pubkey hash: ${addressPubKeyHash}, but derived: ${pubKeyHash}. ` +
                            `This indicates a corrupted wallet or a bug. Transaction signing aborted for your security.`;
                        console.error('WALLET INTEGRITY ERROR: ' + errorMsg);
                        throw new Error('Wallet integrity error: signing key does not match wallet address. ' +
                            'This wallet may be corrupted. Please restore from a backup or create a new wallet.');
                    }
                }
                
                // Build the transaction for SegWit (P2WPKH)
                const tx = buildSegWitTransaction(txPlan, keyPair, publicKey);
                
                
                const result = {
                    raw: tx.hex,
                    txid: tx.txid,
                    details: txPlan
                };
                
                console.log('createAndSignTransaction returning:', result);
                
                return result;
            }
            
            // Build a proper SegWit transaction
            function buildSegWitTransaction(txPlan, keyPair, publicKey) {
                
                // Transaction components
                let txHex = '';
                
                // Version (4 bytes, little-endian)
                txHex += '02000000'; // version 2
                
                // Marker and flag for SegWit
                txHex += '00'; // marker
                txHex += '01'; // flag
                
                // Number of inputs (varint)
                txHex += '01'; // 1 input
                
                // Input
                // Previous tx hash (32 bytes, reversed for little-endian)
                const prevTxHash = txPlan.input.tx_hash;
                
                // Log the UTXO we're trying to spend to verify it belongs to us
                
                // Verify the UTXO scriptPubKey matches our address
                const ourScriptPubKey = createScriptPubKey(wallet.addresses[0].address);
                
                const reversedHash = prevTxHash.match(/../g).reverse().join('');
                txHex += reversedHash;
                
                // Previous output index (4 bytes, little-endian)
                const vout = txPlan.input.tx_pos;
                txHex += ('00000000' + vout.toString(16)).slice(-8).match(/../g).reverse().join('');
                
                // Script length (varint) - 0 for witness transactions
                txHex += '00';
                
                // Sequence (4 bytes)
                txHex += 'feffffff';
                
                // Number of outputs (varint)
                const outputCount = txPlan.outputs.length;
                txHex += ('0' + outputCount.toString(16)).slice(-2);
                
                // Outputs
                for (const output of txPlan.outputs) {
                    // Amount (8 bytes, little-endian)
                    const amountHex = output.value.toString(16).padStart(16, '0');
                    txHex += amountHex.match(/../g).reverse().join('');
                    
                    // Script pubkey
                    const scriptPubKey = createScriptPubKey(output.address);
                    const scriptLength = (scriptPubKey.length / 2).toString(16).padStart(2, '0');
                    txHex += scriptLength;
                    txHex += scriptPubKey;
                }
                
                // Witness data
                const witnessData = createWitnessData(txPlan, txHex, keyPair, publicKey);
                txHex += witnessData;
                
                // Locktime (4 bytes)
                txHex += '00000000';
                
                // Calculate transaction ID (double SHA256 of tx without witness data)
                // For SegWit, we need to construct the non-witness serialization
                let txForId = '';
                
                // Version (4 bytes) - use non-witness version
                txForId += '02000000';
                
                // Input count (1 byte)
                txForId += '01';
                
                // Input: txid (32 bytes reversed) + vout (4 bytes)
                const inputTxidBytes = txPlan.input.tx_hash.match(/../g).reverse().join('');
                txForId += inputTxidBytes;
                txForId += ('00000000' + txPlan.input.tx_pos.toString(16)).slice(-8).match(/../g).reverse().join('');
                
                // Script sig (empty for P2WPKH)
                txForId += '00';
                
                // Sequence (4 bytes)
                txForId += 'feffffff';
                
                // Output count
                txForId += ('0' + txPlan.outputs.length.toString(16)).slice(-2);
                
                // Add all outputs
                for (const output of txPlan.outputs) {
                    // Amount (8 bytes, little-endian)
                    const amountHex = ('0000000000000000' + output.value.toString(16)).slice(-16);
                    const amountLittleEndian = amountHex.match(/../g).reverse().join('');
                    txForId += amountLittleEndian;
                    
                    // Script pubkey
                    const scriptPubKey = createScriptPubKey(output.address);
                    const scriptLength = ('0' + (scriptPubKey.length / 2).toString(16)).slice(-2);
                    txForId += scriptLength;
                    txForId += scriptPubKey;
                }
                
                // Locktime (4 bytes)
                txForId += '00000000';
                
                // Now calculate the correct txid
                const hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(txForId));
                const hash2 = CryptoJS.SHA256(hash1);
                // Reverse the hash bytes for the final txid
                const txid = hash2.toString().match(/../g).reverse().join('');
                
                
                return {
                    hex: txHex,
                    txid: txid
                };
            }
            
            // Create witness data for the transaction
            function createWitnessData(txPlan, partialTx, keyPair, publicKey) {
                // For P2WPKH, witness contains: signature and public key
                
                // Create signature hash for witness
                const sigHash = createSignatureHash(txPlan, partialTx, publicKey);
                
                
                // Sign the hash
                const signature = keyPair.sign(sigHash);
                
                // Ensure low-S canonical signature (BIP62)
                const ec = new elliptic.ec('secp256k1');
                const halfOrder = ec.curve.n.shrn(1);
                if (signature.s.cmp(halfOrder) > 0) {
                    signature.s = ec.curve.n.sub(signature.s);
                }
                
                const derSig = signature.toDER('hex') + '01'; // SIGHASH_ALL
                
                // Verify our own signature to ensure it's valid
                const verifyResult = keyPair.verify(sigHash, signature);
                if (!verifyResult) {
                    console.error('ERROR: Our own signature verification failed!');
                }
                
                // Build witness
                let witness = '';
                witness += '02'; // 2 stack items
                
                // Signature
                const sigLen = (derSig.length / 2).toString(16).padStart(2, '0');
                witness += sigLen;
                witness += derSig;
                
                // Public key
                const pubKeyLen = (publicKey.length / 2).toString(16).padStart(2, '0');
                witness += pubKeyLen;
                witness += publicKey;
                
                return witness;
            }
            
            // Create signature hash for SegWit
            function createSignatureHash(txPlan, partialTx, publicKey) {
                // BIP143 signature hash for P2WPKH
                let preimage = '';
                
                // 1. nVersion (4 bytes, little-endian)
                preimage += '02000000';
                
                // 2. hashPrevouts (32 bytes)
                let prevouts = '';
                // For BIP143, prevout is txid (little-endian) + vout (little-endian)
                const txidBytes = txPlan.input.tx_hash.match(/../g).reverse().join('');
                const voutBytes = ('00000000' + txPlan.input.tx_pos.toString(16)).slice(-8).match(/../g).reverse().join('');
                prevouts = txidBytes + voutBytes;
                console.log('Prevout for hashing:', prevouts);
                const hashPrevouts = CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(prevouts))).toString();
                console.log('hashPrevouts:', hashPrevouts);
                preimage += hashPrevouts;
                
                // 3. hashSequence (32 bytes) 
                const sequence = 'feffffff';
                const hashSequence = CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(sequence))).toString();
                preimage += hashSequence;
                
                // 4. outpoint (36 bytes)
                preimage += txPlan.input.tx_hash.match(/../g).reverse().join('');
                preimage += ('00000000' + txPlan.input.tx_pos.toString(16)).slice(-8).match(/../g).reverse().join('');
                
                // 5. scriptCode for P2WPKH (includes length prefix)
                const pubKeyHash = CryptoJS.RIPEMD160(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey))).toString();
                const scriptCode = '1976a914' + pubKeyHash + '88ac'; // Length + OP_DUP OP_HASH160 <20-byte-hash> OP_EQUALVERIFY OP_CHECKSIG
                console.log('ScriptCode:', scriptCode);
                console.log('PubKeyHash in scriptCode:', pubKeyHash);
                preimage += scriptCode;
                
                // 6. amount (8 bytes, little-endian)
                const amountHex = txPlan.input.value.toString(16).padStart(16, '0');
                preimage += amountHex.match(/../g).reverse().join('');
                
                // 7. nSequence (4 bytes, little-endian)
                preimage += sequence;
                
                // 8. hashOutputs (32 bytes)
                let outputs = '';
                for (const output of txPlan.outputs) {
                    // Amount (8 bytes, little-endian)
                    const outAmountHex = output.value.toString(16).padStart(16, '0');
                    outputs += outAmountHex.match(/../g).reverse().join('');
                    // Script pubkey with length
                    const scriptPubKey = createScriptPubKey(output.address);
                    const scriptLength = (scriptPubKey.length / 2).toString(16).padStart(2, '0');
                    outputs += scriptLength;
                    outputs += scriptPubKey;
                }
                const hashOutputs = CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.enc.Hex.parse(outputs))).toString();
                preimage += hashOutputs;
                
                // 9. nLocktime (4 bytes, little-endian)
                preimage += '00000000';
                
                // 10. sighash type (4 bytes, little-endian)
                preimage += '01000000'; // SIGHASH_ALL
                
                
                // Double SHA256
                const hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(preimage));
                const hash2 = CryptoJS.SHA256(hash1);
                const sigHash = hash2.toString();
                
                
                return sigHash;
            }
            
            // Create scriptPubKey for address (P2WPKH for bech32)
            function createScriptPubKey(address) {
                if (!address || typeof address !== 'string') {
                    console.error('Invalid address provided to createScriptPubKey:', address);
                    throw new Error('Invalid address: must be a string');
                }
                
                const decoded = decodeBech32(address);
                if (!decoded) {
                    throw new Error('Invalid bech32 address: ' + address);
                }
                
                // Convert data array to hex string
                const dataHex = decoded.data.map(byte => byte.toString(16).padStart(2, '0')).join('');
                
                // P2WPKH scriptPubKey: OP_0 <20-byte-key-hash>
                return '0014' + dataHex;
            }
            
            
            // Transaction Broadcasting Queue System
            // Variables already declared at top of DOMContentLoaded
            
            // Initialize broadcast queue from localStorage
            function initBroadcastQueue() {
                try {
                    const savedQueue = localStorage.getItem('broadcastQueue');
                    if (savedQueue) {
                        broadcastQueue = JSON.parse(savedQueue);
                        // Validate queue items
                        broadcastQueue = broadcastQueue.filter(item => 
                            item && item.tx && item.tx.raw && item.tx.txid
                        );
                    }
                    
                    // Load broadcast state
                    const savedState = localStorage.getItem('broadcastState');
                    if (savedState) {
                        const state = JSON.parse(savedState);
                        lastBroadcastBlock = state.lastBroadcastBlock || null;
                        transactionsInCurrentBlock = state.transactionsInCurrentBlock || 0;
                    }
                } catch (e) {
                    console.error('Error loading broadcast queue:', e);
                    broadcastQueue = [];
                }
                
                // Update queue status display
                updateQueueDisplay();
                
                // Start processing if there are items in queue
                if (broadcastQueue.length > 0 && electrumConnected) {
                    processQueue();
                }
            }
            
            // Save queue to localStorage
            function saveQueue() {
                try {
                    localStorage.setItem('broadcastQueue', JSON.stringify(broadcastQueue));
                    
                    // Save broadcast state
                    localStorage.setItem('broadcastState', JSON.stringify({
                        lastBroadcastBlock: lastBroadcastBlock,
                        transactionsInCurrentBlock: transactionsInCurrentBlock
                    }));
                } catch (e) {
                    console.error('Error saving broadcast queue:', e);
                }
            }
            
            // Add transactions to queue
            function broadcastTransactions(signedTransactions) {
                // Start debug session for broadcast queue
                const debugSession = currentTransactionDebug || startTransactionDebug('broadcast_queue');
                
                debugSession.log('info', 'Adding transactions to broadcast queue', {
                    count: signedTransactions.length,
                    transactions: signedTransactions.map(tx => ({
                        txid: tx.txid,
                        size: tx.raw ? tx.raw.length / 2 : 0,
                        hex: tx.raw
                    }))
                });
                
                // Validate and add to queue
                let addedCount = 0;
                let skippedCount = 0;
                
                for (const signedTx of signedTransactions) {
                    // Ensure we have a hex string, not JSON
                    if (typeof signedTx.raw === 'object') {
                        console.error('ERROR: Transaction is JSON object, not hex string:', signedTx.raw);
                        showInAppNotification('Invalid Transaction', 'Transaction format is invalid. Must be a hex string.', 'error');
                        continue;
                    }
                    
                    // Check for duplicate transactions
                    const existingTx = broadcastQueue.find(item => item.tx.txid === signedTx.txid);
                    
                    if (existingTx) {
                        if (existingTx.status === 'cancelled') {
                            // Remove from cancelled and add as pending
                            broadcastQueue = broadcastQueue.filter(item => item.tx.txid !== signedTx.txid);
                            console.log(`Removed cancelled transaction ${signedTx.txid} from queue`);
                        } else if (existingTx.status === 'pending' || existingTx.status === 'complete' || existingTx.status === 'broadcasting') {
                            // Skip if already pending, broadcasting, or complete
                            console.log(`Skipping duplicate transaction ${signedTx.txid} (status: ${existingTx.status})`);
                            skippedCount++;
                            continue;
                        } else if (existingTx.status === 'failed') {
                            // Reset failed transaction for retry
                            existingTx.status = 'pending';
                            existingTx.attempts = 0;
                            existingTx.error = null;
                            existingTx.failedAt = null;
                            console.log(`Resetting failed transaction ${signedTx.txid} for retry`);
                            addedCount++;
                            continue;
                        }
                    }
                    
                    // Add to queue with metadata
                    broadcastQueue.push({
                        tx: signedTx,
                        addedAt: new Date().toISOString(),
                        attempts: 0,
                        status: 'pending'
                    });
                    addedCount++;
                }
                
                saveQueue();
                updateQueueDisplay();
                
                // Show notification about import results
                if (addedCount > 0 && skippedCount > 0) {
                    showInAppNotification('Import Complete', `Added ${addedCount} transaction(s), skipped ${skippedCount} duplicate(s)`, 'info');
                } else if (skippedCount > 0) {
                    showInAppNotification('No New Transactions', `All ${skippedCount} transaction(s) already in queue`, 'warning');
                } else if (addedCount > 0) {
                    showInAppNotification('Queued for Broadcast', 
                        `Added ${addedCount} transaction(s) to broadcast queue`, 
                        'info');
                }
                
                // Start processing if not already running
                if (!isQueueProcessing && electrumConnected && addedCount > 0) {
                    processQueue();
                }
            }
            
            // Process the broadcast queue
            function processQueue() {
                if (isQueueProcessing || !electrumConnected || broadcastQueue.length === 0) {
                    return;
                }
                
                isQueueProcessing = true;
                
                // Check if block has changed since last broadcast
                if (lastBroadcastBlock !== currentBlockHeight) {
                    // New block, reset counter
                    transactionsInCurrentBlock = 0;
                    lastBroadcastBlock = currentBlockHeight;
                }
                
                // Check if we've reached the limit for this block
                if (transactionsInCurrentBlock >= MAX_TRANSACTIONS_PER_BLOCK) {
                    // Wait for next block
                    console.log(`Reached limit of ${MAX_TRANSACTIONS_PER_BLOCK} transactions for block ${currentBlockHeight}. Waiting for next block.`);
                    isQueueProcessing = false;
                    updateQueueDisplay();
                    return;
                }
                
                // Get next pending transaction
                const nextItem = broadcastQueue.find(item => item.status === 'pending');
                if (!nextItem) {
                    isQueueProcessing = false;
                    updateQueueDisplay();
                    return;
                }
                
                // Broadcast the transaction
                nextItem.status = 'broadcasting';
                nextItem.attempts++;
                updateQueueDisplay();
                
                electrumRequest('blockchain.transaction.broadcast', [nextItem.tx.raw], function(result, error) {
                    // Create debug session for broadcast
                    const broadcastDebug = startTransactionDebug('broadcast_transaction');
                    broadcastDebug.log('info', 'Broadcasting transaction', {
                        txid: nextItem.tx.txid,
                        attempt: nextItem.attempts,
                        size: nextItem.tx.raw ? nextItem.tx.raw.length / 2 : 'unknown',
                        hex: nextItem.tx.raw,
                        details: nextItem.tx.details || null
                    });
                    
                    if (error) {
                        console.error('Broadcast error:', error);
                        broadcastDebug.log('error', 'Broadcast failed', {
                            error: error.message || error,
                            code: error.code,
                            txid: nextItem.tx.txid,
                            hex: nextItem.tx.raw,
                            attempts: nextItem.attempts,
                            details: nextItem.tx.details || null
                        });
                        
                        // Handle specific errors with detailed logging
                        if (error.message && error.message.includes('already in mempool')) {
                            // Transaction already broadcast, mark as complete
                            nextItem.status = 'complete';
                            nextItem.result = 'Already in mempool';
                            nextItem.completedAt = new Date().toISOString();
                        } else if (error.message && error.message.includes('already in block')) {
                            // Transaction already confirmed on blockchain - this is success, not failure
                            nextItem.status = 'complete';
                            nextItem.result = 'Already confirmed in blockchain';
                            nextItem.completedAt = new Date().toISOString();
                            broadcastDebug.log('success', 'Transaction already confirmed on blockchain', {
                                txid: nextItem.tx.txid
                            });
                        } else if (nextItem.attempts >= 3) {
                            // Max retries reached
                            nextItem.status = 'failed';
                            nextItem.error = error.message || error;
                            nextItem.failedAt = new Date().toISOString();
                            showInAppNotification('Broadcast Failed', 
                                `Failed to broadcast transaction after 3 attempts: ${error.message || error}`, 
                                'error');
                        } else {
                            // Retry later
                            nextItem.status = 'pending';
                        }
                    } else {
                        // Success
                        broadcastDebug.log('success', 'Transaction broadcast successful', {
                            txid: nextItem.tx.txid,
                            result: result,
                            blockHeight: currentBlockHeight,
                            hex: nextItem.tx.raw
                        });
                        
                        nextItem.status = 'complete';
                        nextItem.result = result;
                        nextItem.broadcastBlock = currentBlockHeight;
                        nextItem.completedAt = new Date().toISOString();
                        lastBroadcastBlock = currentBlockHeight;
                        transactionsInCurrentBlock++;
                        
                        console.log(`Transaction broadcast (${transactionsInCurrentBlock}/${MAX_TRANSACTIONS_PER_BLOCK} this block):`, result);
                        showInAppNotification('Transaction Sent', 
                            `Successfully broadcast transaction: ${nextItem.tx.txid.substring(0, 16)}...`, 
                            'success');
                        
                        // Refresh balance
                        refreshBalance();
                    }
                    
                    saveQueue();
                    updateQueueDisplay();
                    
                    // Clean up completed/failed items periodically
                    cleanupQueue();
                    
                    // Continue processing
                    isQueueProcessing = false;
                    
                    // Continue processing based on status
                    if (nextItem.status === 'complete') {
                        // Check if we can broadcast more in this block
                        if (transactionsInCurrentBlock < MAX_TRANSACTIONS_PER_BLOCK && 
                            broadcastQueue.some(item => item.status === 'pending')) {
                            // Continue with next transaction
                            setTimeout(() => processQueue(), 1000);
                        }
                        // Otherwise will resume on next block
                    } else {
                        // Try next item immediately if this one failed
                        setTimeout(() => processQueue(), 1000);
                    }
                });
            }
            
            // Clean up old completed/failed items
            function cleanupQueue() {
                const cutoffTime = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24 hours
                broadcastQueue = broadcastQueue.filter(item => {
                    if (item.status === 'pending' || item.status === 'broadcasting') {
                        return true; // Keep pending items
                    }
                    const itemTime = new Date(item.addedAt);
                    return itemTime > cutoffTime; // Keep recent completed/failed items
                });
                
                // If queue is now empty, clear from localStorage
                if (broadcastQueue.length === 0) {
                    localStorage.removeItem('broadcastQueue');
                    localStorage.removeItem('broadcastState');
                } else {
                    saveQueue();
                }
            }
            
            // Update queue display
            function updateQueueDisplay() {
                if (!queueStatusElement) {
                    // Create queue status element if it doesn't exist
                    createQueueStatusElement();
                }
                
                const pendingCount = broadcastQueue.filter(item => item.status === 'pending').length;
                const broadcastingCount = broadcastQueue.filter(item => item.status === 'broadcasting').length;
                const completeCount = broadcastQueue.filter(item => item.status === 'complete').length;
                const failedCount = broadcastQueue.filter(item => item.status === 'failed').length;
                const cancelledCount = broadcastQueue.filter(item => item.status === 'cancelled').length;
                
                if (broadcastQueue.length === 0) {
                    queueStatusElement.style.display = 'none';
                    // Clear any pending auto-clear timeout
                    if (autoClearTimeout) {
                        clearTimeout(autoClearTimeout);
                        autoClearTimeout = null;
                    }
                    return;
                }
                
                queueStatusElement.style.display = 'block';
                
                // Check if all transactions are complete (no pending, no broadcasting, no failed)
                if (pendingCount === 0 && broadcastingCount === 0 && failedCount === 0 && completeCount > 0) {
                    // Schedule auto-clear after 10 seconds
                    if (!autoClearTimeout) {
                        autoClearTimeout = setTimeout(() => {
                            clearCompletedQueue();
                            showInAppNotification('Queue Cleared', 'All completed transactions have been cleared from the queue', 'info');
                            autoClearTimeout = null;
                        }, 10000);
                    }
                } else {
                    // Cancel auto-clear if there are pending, broadcasting, or failed transactions
                    if (autoClearTimeout) {
                        clearTimeout(autoClearTimeout);
                        autoClearTimeout = null;
                    }
                }
                
                let statusHTML = '<div style="padding: 10px; background: #f8f9fa; border-radius: 4px; margin-bottom: 10px;">';
                statusHTML += '<h4 style="margin: 0 0 10px 0;">Broadcast Queue</h4>';
                
                // Calculate amounts for each status
                const pendingAmount = broadcastQueue
                    .filter(item => item.status === 'pending')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                const broadcastingAmount = broadcastQueue
                    .filter(item => item.status === 'broadcasting')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                const completeAmount = broadcastQueue
                    .filter(item => item.status === 'complete')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                const failedAmount = broadcastQueue
                    .filter(item => item.status === 'failed')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                const cancelledAmount = broadcastQueue
                    .filter(item => item.status === 'cancelled')
                    .reduce((sum, item) => sum + (item.tx.details?.outputs?.[0]?.value || 0), 0);
                
                const totalAmount = pendingAmount + broadcastingAmount + completeAmount + failedAmount + cancelledAmount;
                
                // Summary with clickable items
                statusHTML += '<div style="margin-bottom: 10px; font-size: 12px;">';
                if (broadcastingCount > 0) {
                    statusHTML += `<span style="color: #0066cc;"> Broadcasting now... (${SatoshiMath.satoshisToAlpha(broadcastingAmount)} ALPHA)</span><br>`;
                }
                if (pendingCount > 0) {
                    statusHTML += `<a href="#" onclick="showQueueDetails('pending'); return false;" style="color: #666; text-decoration: none; cursor: pointer;"> ${pendingCount} pending (${SatoshiMath.satoshisToAlpha(pendingAmount)} ALPHA)</a><br>`;
                }
                if (completeCount > 0) {
                    statusHTML += `<a href="#" onclick="showQueueDetails('complete'); return false;" style="color: #00a000; text-decoration: none; cursor: pointer;"> ${completeCount} complete (${SatoshiMath.satoshisToAlpha(completeAmount)} ALPHA)</a><br>`;
                }
                if (failedCount > 0) {
                    statusHTML += `<a href="#" onclick="showQueueDetails('failed'); return false;" style="color: #cc0000; text-decoration: none; cursor: pointer;"> ${failedCount} failed (${SatoshiMath.satoshisToAlpha(failedAmount)} ALPHA)</a><br>`;
                }
                if (cancelledCount > 0) {
                    statusHTML += `<a href="#" onclick="showQueueDetails('cancelled'); return false;" style="color: #f59e0b; text-decoration: none; cursor: pointer;"> ${cancelledCount} cancelled (${SatoshiMath.satoshisToAlpha(cancelledAmount)} ALPHA)</a><br>`;
                }

                statusHTML += `<br><strong>Total queued: ${SatoshiMath.satoshisToAlpha(totalAmount)} ALPHA</strong>`;
                
                // Progress bar
                if (totalAmount > 0) {
                    const progressPercent = (completeAmount / totalAmount) * 100;
                    statusHTML += `
                        <div style="margin-top: 10px;">
                            <div style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden; position: relative;">
                                <div style="background: #10b981; height: 100%; width: ${progressPercent}%; transition: width 0.3s ease;"></div>
                                <div style="position: absolute; top: 0; left: 0; right: 0; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600;">
                                    ${SatoshiMath.satoshisToAlpha(completeAmount)} / ${SatoshiMath.satoshisToAlpha(totalAmount)} ALPHA (${progressPercent.toFixed(1)}%)
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                if (lastBroadcastBlock === currentBlockHeight && transactionsInCurrentBlock >= MAX_TRANSACTIONS_PER_BLOCK && pendingCount > 0) {
                    const nextBlock = currentBlockHeight ? currentBlockHeight + 1 : 'next';
                    const transactionText = pendingCount === 1 ? 'transaction' : 'transactions';
                    statusHTML += `<br><em style="color: #666;">Limit reached (${MAX_TRANSACTIONS_PER_BLOCK} per block). ${pendingCount} more ${transactionText} to go, waiting for block ${nextBlock}...</em>`;
                } else if (pendingCount > 0 && transactionsInCurrentBlock > 0) {
                    const remaining = MAX_TRANSACTIONS_PER_BLOCK - transactionsInCurrentBlock;
                    const canBroadcast = Math.min(remaining, pendingCount);
                    if (canBroadcast > 0) {
                        statusHTML += `<br><em style="color: #666;">Can broadcast ${canBroadcast} more transaction${canBroadcast > 1 ? 's' : ''} in current block</em>`;
                    }
                }
                
                statusHTML += '</div>';
                
                // Queue control buttons
                statusHTML += '<div style="margin-top: 10px;">';
                
                // Cancel pending button
                if (pendingCount > 0 || broadcastingCount > 0) {
                    statusHTML += `<button onclick="cancelPendingTransactions()" style="padding: 4px 8px; font-size: 11px; background: #ef4444; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">Cancel Pending</button>`;
                }
                
                // Clear queue button
                if (completeCount > 0 || failedCount > 0 || cancelledCount > 0) {
                    statusHTML += `<button onclick="clearQueue()" style="padding: 4px 8px; font-size: 11px; background: #6b7280; color: white; border: none; border-radius: 3px; cursor: pointer;">Clear History</button>`;
                }
                
                statusHTML += '</div>';
                
                statusHTML += '</div>';
                
                queueStatusElement.innerHTML = statusHTML;
                
                // Update balance and UTXO display when queue changes
                updateCommonBalance();
                updateUtxoListDisplay();
            }
            
            // Create queue status element
            function createQueueStatusElement() {
                queueStatusElement = document.createElement('div');
                queueStatusElement.id = 'broadcastQueueStatus';
                queueStatusElement.style.display = 'none';
                
                // Insert after the wallet info section
                if (walletInfo && walletInfo.nextSibling) {
                    walletInfo.parentNode.insertBefore(queueStatusElement, walletInfo.nextSibling);
                } else {
                    // Fallback: insert at the beginning of the main content
                    const mainContent = document.querySelector('.container');
                    if (mainContent) {
                        mainContent.insertBefore(queueStatusElement, mainContent.firstChild);
                    }
                }
            }
            
            // Clear all items from queue except pending
            window.clearQueue = function() {
                broadcastQueue = broadcastQueue.filter(item => 
                    item.status === 'pending' || item.status === 'broadcasting'
                );
                
                // If queue is now empty, clear from localStorage
                if (broadcastQueue.length === 0) {
                    localStorage.removeItem('broadcastQueue');
                    localStorage.removeItem('broadcastState');
                } else {
                    saveQueue();
                }
                
                updateQueueDisplay();
            };
            
            // Cancel all pending transactions
            window.cancelPendingTransactions = function() {
                // Mark all pending and broadcasting transactions as cancelled
                broadcastQueue = broadcastQueue.map(item => {
                    if (item.status === 'pending' || item.status === 'broadcasting') {
                        return {
                            ...item,
                            status: 'cancelled',
                            cancelledAt: new Date().toISOString()
                        };
                    }
                    return item;
                });
                
                // Stop queue processing
                isQueueProcessing = false;
                
                // Save and update display
                saveQueue();
                updateQueueDisplay();
                
                showInAppNotification('Queue Cancelled', 'All pending transactions have been cancelled', 'warning');
            };
            
            // Clear completed items from queue (used by auto-clear)
            window.clearCompletedQueue = function() {
                broadcastQueue = broadcastQueue.filter(item => 
                    item.status !== 'complete'
                );
                
                // If queue is now empty, clear from localStorage
                if (broadcastQueue.length === 0) {
                    localStorage.removeItem('broadcastQueue');
                    localStorage.removeItem('broadcastState');
                } else {
                    saveQueue();
                }
                
                updateQueueDisplay();
            };
            
            // Handle new blocks
            function onNewBlock() {
                console.log(`New block ${currentBlockHeight} detected`);
                updateQueueDisplay();
                
                // Resume queue processing if we were waiting
                if (broadcastQueue.some(item => item.status === 'pending') && !isQueueProcessing) {
                    console.log('Resuming queue processing for new block');
                    processQueue();
                }
            }
            
            // Helper function to display modal
            function showModal(content) {
                const modal = document.createElement('div');
                modal.style.cssText = 'display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;';
                modal.id = 'queueDetailsModal';
                
                const modalInner = document.createElement('div');
                modalInner.style.cssText = 'position: relative; margin: 50px auto; max-width: 600px; max-height: 80vh; overflow-y: auto; background: white; border-radius: 12px; padding: 30px;';
                modalInner.innerHTML = content;
                
                modal.appendChild(modalInner);
                document.body.appendChild(modal);
                
                // Add close function to window
                window.closeQueueModal = function() {
                    modal.remove();
                };
                
                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // Close on Escape key
                document.addEventListener('keydown', function escHandler(e) {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escHandler);
                    }
                });
            }
            
            // Show queue details modal
            window.showQueueDetails = function(status) {
                const filteredItems = broadcastQueue.filter(item => item.status === status);
                if (filteredItems.length === 0) return;
                
                let modalContent = '';
                let modalTitle = '';
                
                switch(status) {
                    case 'pending':
                        modalTitle = 'Pending Transactions';
                        break;
                    case 'complete':
                        modalTitle = 'Completed Transactions';
                        break;
                    case 'failed':
                        modalTitle = 'Failed Transactions';
                        break;
                    case 'cancelled':
                        modalTitle = 'Cancelled Transactions';
                        break;
                }
                
                modalContent = `
                    <h2 style="margin-bottom: 20px; color: #111827;">${modalTitle}</h2>
                    <div style="max-height: 400px; overflow-y: auto;">`;
                
                filteredItems.forEach((item, index) => {
                    const details = item.tx.details;
                    const txid = item.tx.txid;
                    
                    // Calculate total amount from all outputs (excluding change)
                    let totalAmount = 0;
                    const outputs = details?.outputs || [];
                    let destinations = [];
                    
                    outputs.forEach(output => {
                        if (output.address && output.address !== details?.changeAddress) {
                            totalAmount += output.value || 0;
                            destinations.push(output.address);
                        }
                    });
                    
                    // If no non-change outputs, show all outputs
                    if (destinations.length === 0) {
                        destinations = outputs.map(output => output.address).filter(addr => addr);
                        totalAmount = outputs.reduce((sum, output) => sum + (output.value || 0), 0);
                    }

                    const amount = totalAmount > 0 ? SatoshiMath.satoshisToAlpha(totalAmount) : 'Unknown';
                    const recipient = destinations.length > 0 ? destinations.join(', ') : 'Unknown';
                    
                    // Get from address - the input is a UTXO that should have an address field
                    // or we can use the changeAddress which is the sender's address
                    const fromAddress = details?.changeAddress || details?.input?.address || 'Unknown';
                    
                    modalContent += `
                        <div style="margin-top: 15px; padding: 15px; background: #f9fafb; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="color: #111827; font-weight: 600; margin-bottom: 10px;">Transaction ${index + 1}</div>
                            <div style="font-size: 14px; color: #374151;">
                                <div style="margin-bottom: 5px;"><strong>From:</strong> <span style="font-family: monospace; word-break: break-all; color: #6b7280;">${fromAddress}</span></div>
                                <div style="margin-bottom: 5px;"><strong>To:</strong> <span style="font-family: monospace; word-break: break-all; color: #6b7280;">${recipient}</span></div>
                                <div style="margin-bottom: 5px;"><strong>Amount:</strong> ${amount} ALPHA</div>
                                <div style="margin-bottom: 5px;"><strong>TxID:</strong> <span style="font-family: monospace; word-break: break-all; color: #6b7280;">${txid}</span></div>
                                <div style="margin-bottom: 5px;"><strong>Added:</strong> ${new Date(item.addedAt).toLocaleString()}</div>
                    `;
                    
                    if (status === 'complete') {
                        modalContent += `<div style="margin-top: 10px;"><a href="https://www.unicity.network/tx/${txid}" target="_blank" style="color: #0066cc; text-decoration: none; font-weight: 500;">View on Explorer </a></div>`;
                    } else if (status === 'failed') {
                        modalContent += `<div style="color: #dc2626; margin-top: 10px; padding: 10px; background: #fee2e2; border-radius: 4px;">
                            <strong>Error:</strong> ${item.error || 'Unknown error'}<br>
                            <strong>Attempts:</strong> ${item.attempts}
                        </div>`;
                    } else if (status === 'cancelled') {
                        modalContent += `<div style="color: #d97706; margin-top: 10px; padding: 10px; background: #fef3c7; border-radius: 4px;">
                            <strong>Status:</strong> Cancelled by user<br>
                            <strong>Cancelled at:</strong> ${new Date(item.cancelledAt).toLocaleString()}
                        </div>`;
                        
                        // Add action buttons for cancelled transactions
                        modalContent += `
                            <div style="margin-top: 10px; display: flex; gap: 10px;">
                                <button onclick="resendTransaction('${txid}')" style="padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Resend</button>
                                <button onclick="saveSingleTransaction('${txid}')" style="padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Save</button>
                                <button onclick="deleteTransaction('${txid}')" style="padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Delete</button>
                            </div>
                        `;
                    }
                    
                    modalContent += '</div></div>';
                });
                
                modalContent += '</div>';
                
                // Add export button for failed or cancelled transactions
                if (status === 'failed' || status === 'cancelled') {
                    const buttonText = status === 'failed' ? 'Export Failed Transactions' : 'Export Cancelled Transactions';
                    const exportStatus = status === 'failed' ? "['failed']" : "['cancelled']";
                    modalContent += `
                        <div style="margin-top: 20px; padding: 15px; background: #fef3c7; border: 1px solid #f59e0b; border-radius: 4px;">
                            <button onclick="exportFailedTransactions(${exportStatus})" style="padding: 8px 16px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">${buttonText}</button>
                            <p style="margin: 10px 0 0 0; font-size: 12px; color: #92400e;">
                                ${status === 'failed' ? 
                                    'Please email the exported file to <strong>vladimir@unicity-labs.com</strong> for investigation.' :
                                    'You can re-import and broadcast these transactions later.'}
                            </p>
                        </div>
                    `;
                }
                
                // Add bulk action buttons for cancelled transactions
                if (status === 'cancelled' && filteredItems.length > 0) {
                    modalContent += `
                        <div style="margin-top: 20px; padding: 15px; background: #f3f4f6; border: 1px solid #e5e7eb; border-radius: 4px; text-align: center;">
                            <button onclick="resendAllCancelled()" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; margin-right: 10px;">Resend All</button>
                            <button onclick="deleteAllCancelled()" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Delete All</button>
                        </div>
                    `;
                }
                
                // Add close button
                modalContent += `
                    <div style="margin-top: 20px; text-align: center;">
                        <button onclick="closeQueueModal()" style="padding: 10px 30px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">Close</button>
                    </div>
                `;
                
                showModal(modalContent);
            };
            
            // Resend a single cancelled transaction
            window.resendTransaction = function(txid) {
                // Check if connected
                if (!electrumConnected) {
                    showInAppNotification('Not Connected', 'Please connect to Fulcrum server first', 'warning');
                    return;
                }
                
                // Find the transaction
                const item = broadcastQueue.find(item => item.tx.txid === txid);
                if (!item || item.status !== 'cancelled') {
                    showInAppNotification('Error', 'Transaction not found or not cancelled', 'error');
                    return;
                }
                
                // Update status to pending
                item.status = 'pending';
                item.attempts = 0;
                item.cancelledAt = null;
                
                saveQueue();
                updateQueueDisplay();
                closeQueueModal();
                
                showInAppNotification('Transaction Requeued', 'Transaction has been queued for broadcast', 'success');
                
                // Start processing if not already running
                if (!isQueueProcessing) {
                    processQueue();
                }
            };
            
            // Save a single transaction
            window.saveSingleTransaction = function(txid) {
                const item = broadcastQueue.find(item => item.tx.txid === txid);
                if (!item) {
                    showInAppNotification('Error', 'Transaction not found', 'error');
                    return;
                }
                
                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    network: 'alpha',
                    transactions: [{
                        raw: item.tx.raw,
                        txid: item.tx.txid,
                        details: item.tx.details || null,
                        status: item.status,
                        error: item.error || null,
                        attempts: item.attempts || 0,
                        cancelledAt: item.cancelledAt || null,
                        failedAt: item.failedAt || null
                    }]
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `transaction_${txid.substring(0, 8)}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                showInAppNotification('Saved', 'Transaction saved to file', 'info');
            };
            
            // Delete a transaction from the queue
            window.deleteTransaction = function(txid) {
                if (confirm('Are you sure you want to delete this transaction?')) {
                    broadcastQueue = broadcastQueue.filter(item => item.tx.txid !== txid);
                    
                    // Update localStorage
                    if (broadcastQueue.length === 0) {
                        localStorage.removeItem('broadcastQueue');
                    } else {
                        saveQueue();
                    }
                    
                    updateQueueDisplay();
                    
                    // Refresh the modal to show updated list
                    const remainingCancelled = broadcastQueue.filter(item => item.status === 'cancelled').length;
                    if (remainingCancelled > 0) {
                        closeQueueModal();
                        showQueueDetails('cancelled');
                    } else {
                        closeQueueModal();
                    }
                    
                    showInAppNotification('Deleted', 'Transaction removed from queue', 'info');
                }
            };
            
            // Resend all cancelled transactions
            window.resendAllCancelled = function() {
                // Check if connected
                if (!electrumConnected) {
                    showInAppNotification('Not Connected', 'Please connect to Fulcrum server first', 'warning');
                    return;
                }
                
                const cancelledItems = broadcastQueue.filter(item => item.status === 'cancelled');
                if (cancelledItems.length === 0) {
                    showInAppNotification('No Cancelled Transactions', 'No cancelled transactions to resend', 'info');
                    return;
                }
                
                // Update all cancelled transactions to pending
                cancelledItems.forEach(item => {
                    item.status = 'pending';
                    item.attempts = 0;
                    item.cancelledAt = null;
                });
                
                saveQueue();
                updateQueueDisplay();
                closeQueueModal();
                
                showInAppNotification('Transactions Requeued', `${cancelledItems.length} transaction(s) have been queued for broadcast`, 'success');
                
                // Start processing if not already running
                if (!isQueueProcessing) {
                    processQueue();
                }
            };
            
            // Delete all cancelled transactions
            window.deleteAllCancelled = function() {
                const cancelledCount = broadcastQueue.filter(item => item.status === 'cancelled').length;
                
                if (cancelledCount === 0) {
                    showInAppNotification('No Cancelled Transactions', 'No cancelled transactions to delete', 'info');
                    return;
                }
                
                if (confirm(`Are you sure you want to delete all ${cancelledCount} cancelled transaction(s)?`)) {
                    broadcastQueue = broadcastQueue.filter(item => item.status !== 'cancelled');
                    
                    // Update localStorage
                    if (broadcastQueue.length === 0) {
                        localStorage.removeItem('broadcastQueue');
                    } else {
                        saveQueue();
                    }
                    
                    updateQueueDisplay();
                    closeQueueModal();
                    
                    showInAppNotification('Deleted', `${cancelledCount} cancelled transaction(s) removed from queue`, 'info');
                }
            };
            
            // Export failed or cancelled transactions
            window.exportFailedTransactions = function(includeStatus = ['failed', 'cancelled']) {
                const exportItems = broadcastQueue.filter(item => 
                    includeStatus.includes(item.status)
                );
                if (exportItems.length === 0) return;
                
                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    network: 'alpha',
                    transactions: exportItems.map(item => ({
                        raw: item.tx.raw,
                        txid: item.tx.txid,
                        details: item.tx.details || null,
                        status: item.status,
                        error: item.error || null,
                        attempts: item.attempts || 0,
                        cancelledAt: item.cancelledAt || null,
                        failedAt: item.failedAt || null
                    }))
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                const filePrefix = includeStatus.includes('cancelled') && !includeStatus.includes('failed') ? 
                    'cancelled_transactions' : 'failed_transactions';
                link.download = `${filePrefix}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                // Show appropriate notification based on transaction type
                if (includeStatus.includes('cancelled') && !includeStatus.includes('failed')) {
                    showInAppNotification('Exported', 'Cancelled transactions exported. You can re-import and broadcast them later.', 'info');
                } else {
                    showInAppNotification('Exported', 'Failed transactions exported. Please email to vladimir@unicity-labs.com', 'info');
                }
            };
            
            // Save transactions for offline broadcast
            function saveTransactionsOffline(signedTransactions) {
                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    network: 'alpha',
                    transactions: signedTransactions.map(tx => ({
                        raw: tx.raw,
                        txid: tx.txid,
                        details: tx.details || null
                    }))
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `alpha-transactions-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showInAppNotification('Transactions Saved', `Saved ${signedTransactions.length} signed transaction(s) to file`, 'success');
            }
            
            // Import and broadcast transactions from file
            document.getElementById('txFileInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        
                        if (!importedData.transactions || !Array.isArray(importedData.transactions)) {
                            showInAppNotification('Import Failed', 'Invalid transaction file format', 'error');
                            return;
                        }
                        
                        // Check if we're online
                        if (!electrumSocket || electrumSocket.readyState !== WebSocket.OPEN) {
                            showInAppNotification('Not Connected', 'Please connect to Fulcrum server first', 'warning');
                            return;
                        }
                        
                        // Show confirmation
                        const txCount = importedData.transactions.length;
                        showInAppNotification('Transactions Loaded', `Loaded ${txCount} transaction(s) from file`, 'info');
                        
                        if (confirm(`Import and broadcast ${txCount} transaction(s)?`)) {
                            const rawTransactions = importedData.transactions.map(tx => {
                                // Check if raw is a JSON object (old format) or hex string (new format)
                                if (typeof tx.raw === 'object') {
                                    alert('Error: This transaction file contains an old format that cannot be broadcast. Please create new transactions.');
                                    throw new Error('Old transaction format detected');
                                }
                                
                                // Check if it's a JSON string (also old format)
                                if (typeof tx.raw === 'string' && tx.raw.startsWith('{')) {
                                    alert('Error: This transaction file contains JSON-formatted transactions from an old version. Please create new transactions with the updated wallet.');
                                    throw new Error('JSON transaction format detected - need hex format');
                                }
                                
                                // Check if it looks like a hex string
                                if (typeof tx.raw === 'string' && !tx.raw.match(/^[0-9a-fA-F]+$/)) {
                                    alert('Error: Transaction is not in valid hexadecimal format.');
                                    throw new Error('Invalid transaction hex format');
                                }
                                
                                return {
                                    raw: tx.raw,
                                    txid: tx.txid,
                                    details: tx.details || null
                                };
                            });
                            broadcastTransactions(rawTransactions);
                        }
                        
                    } catch (error) {
                        showInAppNotification('Read Error', 'Error reading transaction file: ' + error.message, 'error');
                        console.error('Import error:', error);
                    }
                };
                
                reader.readAsText(file);
                e.target.value = ''; // Clear input for re-use
            });
            
        });
    </script>

    <!-- Transaction Confirmation Modal -->
    <div id="txConfirmModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: relative; margin: 50px auto; max-width: 600px; max-height: 80vh; overflow-y: auto; background: white; border-radius: 12px; padding: 30px;">
            <h2 style="margin-bottom: 20px;">Confirm Transaction</h2>
            <div id="txConfirmDetails" style="margin-bottom: 20px;">
                <!-- Transaction details will be inserted here -->
            </div>
            <div class="button-container" style="justify-content: space-between;">
                <button onclick="cancelTransaction()" class="button" style="background-color: #ef4444;">
                    Cancel
                </button>
                <button onclick="confirmAndSignTransactions()" class="button" style="background-color: #10b981;">
                    Confirm & Sign
                </button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeHelpModal()">&times;</span>
            <h2>How to use this wallet</h2>
            
            <!-- Tab buttons -->
            <div style="display: flex; gap: 10px; margin-top: 20px; border-bottom: 2px solid #e0e0e0;">
                <button id="generalTab" class="help-tab-button active" onclick="switchHelpTab('general')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid #4CAF50; color: #333; font-weight: 600; cursor: pointer;">General Usage</button>
                <button id="coldWalletTab" class="help-tab-button" onclick="switchHelpTab('coldWallet')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #666; cursor: pointer;">Cold Wallet</button>
                <button id="debugTab" class="help-tab-button" onclick="switchHelpTab('debug')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #666; cursor: pointer;">Debug & Bug Reporting</button>
            </div>
            
            <!-- General Usage Tab Content -->
            <div id="generalTabContent" class="help-tab-content" style="display: block;">
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Interface Overview</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Main Page Tabs:</strong>
                    <ul style="margin-top: 5px;">
                        <li><strong>Wallet Tab:</strong> Main wallet operations (Create, Load, Save, Reset, Send, Broadcast)</li>
                        <li><strong>Cold Wallet Tools Tab:</strong> UTXO management for offline transactions (Export/Import UTXOs)</li>
                    </ul>
                </li>
                <li><strong>Help Tabs:</strong> This help window has two tabs - General Usage (this tab) and Cold Wallet (detailed cold wallet instructions)</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Getting Started</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Create New Wallet:</strong> Click the "Create" button to generate a new wallet with a secure private key</li>
                <li><strong>Load Existing Wallet:</strong> Click the "Load" button to import from:
                    <ul style="margin-top: 5px;">
                        <li><strong>Text Files (.txt):</strong> Import wallets from WIF private keys or previously saved BIP32 keys</li>
                        <li><strong>BIP32 Wallet Database (.dat):</strong> Import BIP32 hierarchical deterministic wallets from wallet.dat files</li>
                        <li><strong>Encrypted Backup:</strong> Restore from password-protected wallet backups (click "Decrypt" button after selecting file)</li>
                    </ul>
                </li>
                <li><strong>Wallet Scanning (BIP32):</strong>
                    <ul style="margin-top: 5px;">
                        <li>When opening a BIP32 wallet file, the wallet automatically scans for addresses with balances</li>
                        <li>The scanner will check up to 100 addresses (configurable) for funds</li>
                        <li>Found addresses are displayed with their balances and derivation paths</li>
                        <li>Select any discovered wallet to use for transactions</li>
                        <li>After initial scan, a "Rescan Wallets" button appears to force a fresh scan and clear cache</li>
                    </ul>
                </li>
                <li><strong>Network Connection:</strong> The wallet automatically connects to the Unicity network when online. You can also manually connect/disconnect using the endpoint controls</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Importing Wallets</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Standard Backup Import:</strong> Use the "Load" button to import wallet files. If the backup is encrypted, you'll need to enter the password.</li>
                <li><strong>BIP32 wallet.dat Import (EXPERIMENTAL):</strong>
                    <div style="margin-top: 10px; padding: 10px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px;">
                        <strong> Important Notes:</strong>
                        <ul style="margin-top: 5px;">
                            <li>Only <strong>unencrypted</strong> wallet.dat files are currently supported</li>
                            <li>No backup copy of wallet.dat is needed - the file is only read, not modified</li>
                            <li><strong>Verify imported addresses:</strong> We cannot guarantee correct address restoration. Always compare with alpha-qt or alpha-cli to ensure the right addresses were loaded</li>
                            <li>The scanner checks 100 regular addresses and 100 change addresses by default</li>
                            <li>You can select any non-empty address found during the scan</li>
                            <li>To decrypt wallet.dat: use <code>alpha-cli walletpassphrase "yourpassword" 600</code> then copy the wallet.dat</li>
                        </ul>
                    </div>
                </li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Exporting from Alpha Core (alpha-cli/alpha-qt)</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Method 1: Direct wallet.dat Copy (Recommended for BIP32 wallets):</strong>
                    <ol style="margin-top: 5px; margin-left: 20px;">
                        <li>Stop alpha-qt or alpha daemon: <code>alpha-cli stop</code></li>
                        <li>Locate your wallet.dat file (usually in ~/.alpha/ or datadir)</li>
                        <li>If wallet is encrypted, temporarily decrypt it:
                            <ul style="margin-top: 5px;">
                                <li>Start alpha daemon/qt again</li>
                                <li>Run: <code>alpha-cli walletpassphrase "yourpassword" 600</code></li>
                                <li>Stop the daemon and copy wallet.dat while it's decrypted</li>
                            </ul>
                        </li>
                        <li>Copy the wallet.dat file to a safe location</li>
                        <li>Use the "Load" button in this wallet to import the wallet.dat file</li>
                    </ol>
                </li>
                <li><strong>Method 2: Export with dumpwallet (Alternative):</strong>
                    <ol style="margin-top: 5px; margin-left: 20px;">
                        <li>If wallet is encrypted, unlock it: <code>alpha-cli walletpassphrase "yourpassword" 600</code></li>
                        <li>Export wallet keys: <code>alpha-cli dumpwallet "wallet_export.txt"</code></li>
                        <li>The exported file contains all private keys in WIF format</li>
                        <li>You can import individual WIF keys using the "Load" button</li>
                        <li>Lock wallet after export: <code>alpha-cli walletlock</code></li>
                    </ol>
                </li>
                <li><strong>Method 3: Backup wallet (For safekeeping):</strong>
                    <ol style="margin-top: 5px; margin-left: 20px;">
                        <li>Create a backup: <code>alpha-cli backupwallet "wallet_backup.dat"</code></li>
                        <li>This creates a copy of your wallet.dat that can be imported the same way</li>
                    </ol>
                </li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Security</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Save Your Wallet:</strong> Click the "Save" button to export your wallet with optional password protection. Write down the password - there's no recovery if forgotten!</li>
                <li><strong>Backup Regularly:</strong> Use the "Save" button to create wallet backups. Store backups in multiple secure locations</li>
                <li><strong>Offline Mode:</strong> For maximum security, <a href="#" onclick="downloadWalletPage(); return false;">download this page</a> and use it on an offline computer</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Receiving Funds</h3>
            <ul style="margin-bottom: 20px;">
                <li>Your address is displayed in the wallet section</li>
                <li>Click the QR code icon to show a scannable code</li>
                <li>Share your address or QR code with the sender</li>
                <li>When connected, balance updates automatically</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Sending Funds</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Online Mode:</strong> Enter recipient address and amount, review fees, then click Send and broadcast directly</li>
                <li><strong>Offline Mode (Cold Wallet) - Two Options:</strong>
                    <div style="margin-top: 10px; padding: 10px; background-color: #e6f7ff; border-radius: 4px;">
                        <strong>Option A: Prepare Transaction Online (Recommended)</strong>
                        <ol style="margin-top: 5px; margin-bottom: 0;">
                            <li>On online computer: Enter watch-only address, create transaction, export template</li>
                            <li>Transfer template to offline computer via USB</li>
                            <li>On offline computer: Import template, sign transaction, export signed file</li>
                            <li>Back online: Click <strong>Broadcast</strong> button to send to network</li>
                        </ol>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-radius: 4px;">
                        <strong>Option B: Prepare Transaction Offline</strong>
                        <ol style="margin-top: 5px; margin-bottom: 0;">
                            <li>On online computer: Go to <strong>Cold Wallet Tools tab</strong>, export UTXOs</li>
                            <li>Transfer UTXO file to offline computer</li>
                            <li>On offline computer: Import UTXOs, create and sign transaction</li>
                            <li>Back online: Click <strong>Broadcast</strong> button to send</li>
                        </ol>
                    </div>
                    <p style="margin-top: 10px; font-size: 13px; color: #666;">
                        <strong> Full Details:</strong> See the <strong>Cold Wallet tab</strong> in this help window for comprehensive step-by-step instructions, security setup, and best practices for cold wallet operations.
                    </p>
                </li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Transaction Broadcast Queue</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Automatic Queue Management:</strong> All transactions are added to a broadcast queue for reliable delivery</li>
                <li><strong>Rate Limiting:</strong> Up to 30 transactions can be broadcast per block to prevent network congestion</li>
                <li><strong>Queue Features:</strong>
                    <ul style="margin-top: 5px;">
                        <li><strong>Visual Progress:</strong> See pending, broadcasting, complete, failed, and cancelled transactions</li>
                        <li><strong>Persistence:</strong> Queue survives page refreshes and connection drops</li>
                        <li><strong>Automatic Retry:</strong> Failed transactions retry up to 3 times</li>
                        <li><strong>UTXO Protection:</strong> Prevents double-spending by tracking consumed UTXOs</li>
                    </ul>
                </li>
                <li><strong>Queue Actions:</strong>
                    <ul style="margin-top: 5px;">
                        <li>Click transaction counts to see detailed information</li>
                        <li>Export failed/cancelled transactions for troubleshooting</li>
                        <li>Cancel pending transactions if needed</li>
                        <li>Resend, save, or delete individual cancelled transactions</li>
                        <li>Clear completed transactions manually or wait for auto-cleanup after 24 hours</li>
                    </ul>
                </li>
                <li><strong>Broadcast Button:</strong> Located in the wallet actions bar (with Create, Load, Save, Reset). Click to import and broadcast signed transaction files</li>
                <li><strong>Max Available Button:</strong> Quickly calculate the maximum sendable amount accounting for fees</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Additional Features</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Reset Wallet:</strong> Click the "Reset" button to clear the current wallet data and start fresh</li>
            </ul>
            
            </div>
            <!-- End General Tab Content -->
            
            <!-- Cold Wallet Tab Content -->
            <div id="coldWalletHelpTabContent" class="help-tab-content" style="display: none;">
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Complete Cold Wallet Transaction Guide</h3>
            
            <div style="padding: 15px; background-color: #f0f9ff; border: 1px solid #bfdbfe; border-radius: 4px; margin-bottom: 20px;">
                <strong style="color: #1e40af;"> Cold Wallet Overview</strong>
                <p style="margin-top: 10px; margin-bottom: 10px;">
                    A cold wallet keeps your private keys on an permanently offline (air-gapped) computer. You prepare transactions online using watch-only mode, sign them offline, then broadcast online.
                </p>
                <strong>Key Components:</strong>
                <ul style="margin-top: 5px; margin-bottom: 0;">
                    <li><strong>Online Computer:</strong> Uses watch-only mode (public address only, no private keys)</li>
                    <li><strong>Offline Computer:</strong> Holds private keys, never connects to internet</li>
                    <li><strong>USB Drive:</strong> Transfers data between computers (JSON files only, never private keys)</li>
                </ul>
            </div>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Initial Setup</h3>
            <ol style="margin-bottom: 20px;">
                <li><strong>Prepare Offline Computer:</strong>
                    <ul style="margin-top: 5px;">
                        <li>Use a computer that will NEVER connect to internet</li>
                        <li>Download wallet HTML file on online computer</li>
                        <li>Transfer HTML file via USB to offline computer</li>
                        <li>Open wallet, click "Create" to generate new wallet</li>
                        <li>Click "Save" to backup wallet (with password protection)</li>
                        <li>Write down the wallet address (alpha1...)</li>
                    </ul>
                </li>
                <li><strong>Setup Online Computer:</strong>
                    <ul style="margin-top: 5px;">
                        <li>Open wallet in browser</li>
                        <li>DO NOT create or load any wallet</li>
                        <li>Enter your cold wallet address in "Watch:" field</li>
                        <li>This enables watch-only mode for monitoring</li>
                    </ul>
                </li>
            </ol>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Understanding Watch-Only Mode</h3>
            
            <div style="padding: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; margin-bottom: 20px;">
                <strong> What is Watch-Only Mode?</strong>
                <p style="margin-top: 10px; margin-bottom: 10px;">
                    Watch-only mode allows you to monitor any wallet address WITHOUT having its private key. This is the foundation of cold wallet security - you can prepare transactions on an online computer without ever exposing your private keys to the internet.
                </p>
                <strong>Key Features:</strong>
                <ul style="margin-top: 5px; margin-bottom: 0;">
                    <li>Monitor balance and transaction history</li>
                    <li>View all available UTXOs</li>
                    <li>Create unsigned transaction templates</li>
                    <li>Export data for offline signing</li>
                    <li>No risk - private keys never touch online computer</li>
                </ul>
            </div>
            
            <h4 style="margin-bottom: 10px;">How to Enable Watch-Only Mode:</h4>
            <ol style="margin-bottom: 20px;">
                <li><strong>Clear any loaded wallet:</strong> If you see wallet buttons, click "Reset" first</li>
                <li><strong>Locate Watch field:</strong> The "Watch:" input appears in wallet section when no wallet is loaded</li>
                <li><strong>Enter address:</strong> Type or paste your cold wallet's address (alpha1...)</li>
                <li><strong>Automatic loading:</strong> Balance, UTXOs, and history load immediately</li>
                <li><strong>Ready for transactions:</strong> You can now create unsigned transactions</li>
            </ol>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">PATH 1: Transaction Template Method (Recommended)</h3>
            <p style="margin-bottom: 15px; color: #666;">Create transaction template online  Sign offline  Broadcast online</p>
            
            <div style="margin-bottom: 20px;">
                <h4 style="color: #4CAF50; margin-bottom: 10px;">Step-by-Step Instructions</h4>
                <div style="padding: 15px; background-color: #e6f7ff; border-radius: 4px;">
                    <ol style="margin: 0;">
                        <li><strong>ONLINE: Create Watch-Only Session</strong>
                            <ul style="margin-top: 5px;">
                                <li>Open wallet in browser (do NOT load any wallet)</li>
                                <li>Find "Watch:" field in wallet section</li>
                                <li>Enter your cold wallet address (alpha1...)</li>
                                <li>Wait for balance and UTXOs to load</li>
                                <li>Verify the displayed balance is correct</li>
                            </ul>
                        </li>
                        <li><strong>ONLINE: Create Transaction Template</strong>
                            <ul style="margin-top: 5px;">
                                <li>In "Destination" field: enter recipient address</li>
                                <li>Enter amount to send</li>
                                <li>Optional: Click "Max" for entire balance</li>
                                <li>Click "Send" button</li>
                                <li>System creates unsigned transaction template</li>
                                <li>Click "Export Transaction" in popup</li>
                                <li>Save as "unsigned_tx_[date].json" to USB drive</li>
                                <li>Safely eject USB drive</li>
                            </ul>
                        </li>
                        <li><strong>OFFLINE: Import and Sign Transaction</strong>
                            <ul style="margin-top: 5px;">
                                <li>Insert USB into offline computer</li>
                                <li>Open wallet HTML file</li>
                                <li>Click "Load" and select your wallet file</li>
                                <li>Enter password if encrypted</li>
                                <li>Click "Load" again and select unsigned_tx_[date].json</li>
                                <li>Transaction details auto-populate</li>
                                <li>VERIFY: recipient address matches exactly</li>
                                <li>VERIFY: amount is correct</li>
                                <li>Click "Send" to sign transaction</li>
                                <li>Click "Export Transaction"</li>
                                <li>Save as "signed_tx_[date].json" to USB</li>
                                <li>Safely eject USB drive</li>
                            </ul>
                        </li>
                        <li><strong>ONLINE: Broadcast Signed Transaction</strong>
                            <ul style="margin-top: 5px;">
                                <li>Insert USB into online computer</li>
                                <li>In wallet, stay on "Wallet" tab</li>
                                <li>Click "Broadcast" button (next to Create, Load, Save, Reset)</li>
                                <li>Select signed_tx_[date].json from USB</li>
                                <li>Transaction appears in broadcast queue</li>
                                <li>Status changes: Pending  Broadcasting  Complete</li>
                                <li>Transaction ID appears when complete</li>
                                <li>Funds are now sent!</li>
                            </ul>
                        </li>
                    </ol>
                </div>
            </div>
            
            <h3 style="margin-top: 30px; margin-bottom: 15px; color: #333;">PATH 2: UTXO Export Method (Alternative)</h3>
            <p style="margin-bottom: 15px; color: #666;">Export UTXOs online  Create & sign offline  Broadcast online</p>
            
            <div style="margin-bottom: 20px;">
                <h4 style="color: #666; margin-bottom: 10px;">Step-by-Step Instructions</h4>
                <div style="padding: 15px; background-color: #f0f0f0; border-radius: 4px;">
                    <ol style="margin: 0;">
                        <li><strong>ONLINE: Export UTXOs</strong>
                            <ul style="margin-top: 5px;">
                                <li>Open wallet in browser (do NOT load any wallet)</li>
                                <li>Enter cold wallet address in "Watch:" field</li>
                                <li>Wait for balance and UTXOs to load</li>
                                <li>Click on "Cold Wallet Tools" tab (top of page)</li>
                                <li>Verify UTXOs are displayed in the list</li>
                                <li>Click "Export UTXO Data" button</li>
                                <li>Save as "utxos_[date].json" to USB drive</li>
                                <li>File contains all available UTXOs with amounts</li>
                                <li>Safely eject USB drive</li>
                            </ul>
                        </li>
                        <li><strong>OFFLINE: Import UTXOs and Create Transaction</strong>
                            <ul style="margin-top: 5px;">
                                <li>Insert USB into offline computer</li>
                                <li>Open wallet HTML file</li>
                                <li>Click "Load" and select your wallet file</li>
                                <li>Enter password if encrypted</li>
                                <li>Click on "Cold Wallet Tools" tab</li>
                                <li>Click "Import UTXO Data" button</li>
                                <li>Select utxos_[date].json from USB</li>
                                <li>UTXOs appear in the list below</li>
                                <li>Click back to "Wallet" tab</li>
                                <li>In "Destination": enter recipient address</li>
                                <li>Enter amount to send</li>
                                <li>Fee is calculated automatically</li>
                                <li>Optional: Click "Max" for entire balance minus fee</li>
                            </ul>
                        </li>
                        <li><strong>OFFLINE: Sign and Export Transaction</strong>
                            <ul style="margin-top: 5px;">
                                <li>VERIFY: recipient address is correct</li>
                                <li>VERIFY: amount and fee are acceptable</li>
                                <li>Click "Send" button</li>
                                <li>Review confirmation dialog carefully</li>
                                <li>Click "Export Transaction"</li>
                                <li>Save as "signed_tx_[date].json" to USB</li>
                                <li>Transaction is signed with your private key</li>
                                <li>Safely eject USB drive</li>
                            </ul>
                        </li>
                        <li><strong>ONLINE: Broadcast Signed Transaction</strong>
                            <ul style="margin-top: 5px;">
                                <li>Insert USB into online computer</li>
                                <li>In wallet, stay on "Wallet" tab</li>
                                <li>Click "Broadcast" button (next to Create, Load, Save, Reset)</li>
                                <li>Select signed_tx_[date].json from USB</li>
                                <li>Transaction appears in broadcast queue</li>
                                <li>Status changes: Pending  Broadcasting  Complete</li>
                                <li>Transaction ID appears when complete</li>
                                <li>Funds are now sent!</li>
                            </ul>
                        </li>
                    </ol>
                </div>
            </div>
            
            <h3 style="margin-top: 30px; margin-bottom: 15px; color: #333;">Important Notes & Tips</h3>
            
            <div style="padding: 15px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; margin-bottom: 20px;">
                <strong> Critical Points:</strong>
                <ul style="margin-top: 10px; margin-bottom: 0;">
                    <li><strong>File Naming:</strong> Use dates in filenames to avoid confusion (unsigned_tx_2024-01-15.json)</li>
                    <li><strong>Double Check:</strong> ALWAYS verify recipient address character-by-character on offline computer</li>
                    <li><strong>USB Safety:</strong> Use a dedicated USB only for wallet operations, never for general use</li>
                    <li><strong>Watch-Only Field:</strong> Only appears when NO wallet is loaded (no Create/Load)</li>
                    <li><strong>Transaction Template:</strong> Contains UTXOs and transaction details but NO signature</li>
                    <li><strong>Signed Transaction:</strong> Contains complete transaction ready for broadcast</li>
                </ul>
            </div>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Troubleshooting</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Watch field not visible?</strong> Click "Reset" to clear any loaded wallet first</li>
                <li><strong>UTXOs not showing?</strong> Ensure you're connected (green connection status)</li>
                <li><strong>Can't import transaction?</strong> Use "Load" button, not "Broadcast" for unsigned files</li>
                <li><strong>Broadcast fails?</strong> Check connection status and transaction queue for errors</li>
                <li><strong>Wrong balance?</strong> Click "Rescan Wallets" if using BIP32 wallet</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Security Best Practices</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Air Gap:</strong> Offline computer must NEVER connect to internet, even temporarily</li>
                <li><strong>USB Hygiene:</strong> 
                    <ul style="margin-top: 5px;">
                        <li>Use dedicated USB for wallet operations only</li>
                        <li>Format USB between uses if possible</li>
                        <li>Never plug wallet USB into untrusted computers</li>
                    </ul>
                </li>
                <li><strong>Verification:</strong> Always verify on offline computer:
                    <ul style="margin-top: 5px;">
                        <li>Recipient address (every character)</li>
                        <li>Amount being sent</li>
                        <li>Fee is reasonable (usually 0.0001-0.001 ALPHA)</li>
                    </ul>
                </li>
                <li><strong>Backups:</strong> Keep multiple encrypted backups of wallet in different physical locations</li>
                <li><strong>Practice:</strong> Test entire process with tiny amounts first (0.001 ALPHA)</li>
            </ul>
            
            <div style="padding: 15px; background-color: #fef2f2; border: 1px solid #fecaca; border-radius: 4px;">
                <strong style="color: #dc2626;"> Important Reminders:</strong>
                <ul style="margin-top: 10px; margin-bottom: 0;">
                    <li>Receiving funds only requires sharing your public address - this is always safe</li>
                    <li>The private key should ONLY exist on the offline computer</li>
                    <li>Cold wallets require more effort but provide maximum security for large holdings</li>
                    <li>Always verify transaction details on the offline computer before signing</li>
                </ul>
            </div>
            </div>
            <!-- End Cold Wallet Tab Content -->
            
            <!-- Debug & Bug Reporting Tab Content -->
            <div id="debugTabContent" class="help-tab-content" style="display: none;">
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;"> Debug & Bug Reporting System</h3>
            <p style="margin-bottom: 15px;">
                The wallet includes a comprehensive debug system that automatically tracks all transaction operations to help developers diagnose and fix issues. All debug data is stored locally and you control what gets shared.
            </p>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">How to Access Debug Features</h3>
            <ol style="margin-bottom: 20px;">
                <li><strong>Debug Button:</strong> Look for the gray <strong>" Debug"</strong> button in the bottom-right corner of the wallet interface</li>
                <li><strong>Click to Open:</strong> Click the button to open the Debug Modal with all your transaction history and logs</li>
                <li><strong>Automatic Tracking:</strong> The system automatically logs all transaction attempts, including successes and failures</li>
            </ol>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Debug Modal Features</h3>
            <div style="padding: 15px; background-color: #f0f8ff; border: 1px solid #3b82f6; border-radius: 4px; margin-bottom: 20px;">
                <strong>The Debug Modal has 4 tabs:</strong>
                <ul style="margin-top: 10px;">
                    <li><strong>Summary:</strong> Overview of the current debug session with statistics</li>
                    <li><strong>Logs:</strong> Detailed chronological log of all operations</li>
                    <li><strong>Errors:</strong> Filtered view showing only errors and warnings</li>
                    <li><strong>History:</strong> List of all recent transaction debug sessions</li>
                </ul>
            </div>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">What Gets Logged</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Transaction Preparation:</strong> Address validation, UTXO selection, fee calculation</li>
                <li><strong>Transaction Signing:</strong> Key derivation, signature creation, witness data</li>
                <li><strong>Broadcasting:</strong> Network submission, server responses, confirmations</li>
                <li><strong>Errors:</strong> Detailed error messages, stack traces, and context</li>
                <li><strong>Transaction Hex:</strong> Complete signed transaction data for debugging</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">How to Report a Bug</h3>
            
            <h4 style="margin-top: 15px; margin-bottom: 10px; color: #555;">Option 1: Automatic Submission (Recommended)</h4>
            <ol style="margin-bottom: 20px;">
                <li><strong>Open Debug Modal:</strong> Click the " Debug" button</li>
                <li><strong>Click Submit Report:</strong> Press the blue <strong>" Submit Report"</strong> button</li>
                <li><strong>Automatic Processing:</strong> The report is sent to the debug service at https://unicity-debug-report.dyndns.org:3487</li>
                <li><strong>Get Report ID:</strong> You'll receive a unique Report ID for tracking</li>
                <li><strong>Optional Cleanup:</strong> Choose whether to clear local debug logs after submission</li>
            </ol>
            
            <h4 style="margin-top: 15px; margin-bottom: 10px; color: #555;">Option 2: Manual Export</h4>
            <ol style="margin-bottom: 20px;">
                <li><strong>Open Debug Modal:</strong> Click the " Debug" button</li>
                <li><strong>Click Export:</strong> Press the green <strong>"Export Debug Log"</strong> button</li>
                <li><strong>Save File:</strong> A JSON file will download with all debug data</li>
                <li><strong>Share Manually:</strong> Send the file to developers via email or issue tracker</li>
            </ol>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Failed Transaction Recovery</h3>
            <div style="padding: 15px; background-color: #fef8e1; border: 1px solid #f59e0b; border-radius: 4px; margin-bottom: 20px;">
                <strong> Retry Failed Transactions:</strong>
                <ol style="margin-top: 10px; margin-bottom: 0;">
                    <li>Click <strong>"Show Failed TXs"</strong> in the Debug Modal</li>
                    <li>Review the list of failed transactions with their error messages</li>
                    <li>Click <strong>"Export for Retry"</strong> to save failed transactions</li>
                    <li>Use the <strong>"Import & Broadcast"</strong> button in the main wallet to retry</li>
                </ol>
            </div>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Privacy & Security</h3>
            <div style="padding: 15px; background-color: #f0fdf4; border: 1px solid #10b981; border-radius: 4px; margin-bottom: 20px;">
                <strong> Your Privacy is Protected:</strong>
                <ul style="margin-top: 10px; margin-bottom: 0;">
                    <li><strong>No Private Keys:</strong> Private keys are NEVER included in debug reports</li>
                    <li><strong>Automatic Sanitization:</strong> All sensitive fields are automatically removed</li>
                    <li><strong>Safe Transaction Data:</strong> Transaction IDs and hex are preserved (public once broadcast)</li>
                    <li><strong>Local Storage:</strong> Debug data is stored locally until you choose to share it</li>
                    <li><strong>You Control Sharing:</strong> Nothing is sent without your explicit action</li>
                </ul>
            </div>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Debug Service Web Interface</h3>
            <p style="margin-bottom: 15px;">
                Developers can view submitted reports at: <strong>https://unicity-debug-report.dyndns.org:3487</strong>
            </p>
            <ul style="margin-bottom: 20px;">
                <li><strong>Browse Reports:</strong> See all submitted debug reports with search and filtering</li>
                <li><strong>Analyze Issues:</strong> View detailed logs, errors, and transaction data</li>
                <li><strong>Extract Transactions:</strong> Export transaction hex for testing and analysis</li>
                <li><strong>Track Patterns:</strong> Identify common issues across multiple reports</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Common Issues to Report</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Transaction Failures:</strong> "Transaction failed to broadcast" or "Invalid transaction" errors</li>
                <li><strong>Balance Issues:</strong> Incorrect balance display or UTXO problems</li>
                <li><strong>Signing Errors:</strong> "Failed to sign transaction" or key-related errors</li>
                <li><strong>Network Problems:</strong> Connection issues with Fulcrum/Electrum servers</li>
                <li><strong>Import/Export Issues:</strong> Problems with wallet.dat import or UTXO import</li>
                <li><strong>UI Problems:</strong> Buttons not working, displays not updating</li>
            </ul>
            
            <h3 style="margin-top: 20px; margin-bottom: 15px; color: #333;">Tips for Better Bug Reports</h3>
            <ul style="margin-bottom: 20px;">
                <li><strong>Reproduce First:</strong> Try to reproduce the issue before reporting</li>
                <li><strong>Clear Steps:</strong> Note the exact steps that led to the problem</li>
                <li><strong>Check Console:</strong> Open browser console (F12) for additional error messages</li>
                <li><strong>Include Context:</strong> Mention if you're using cold wallet, BIP32, or watch-only mode</li>
                <li><strong>Submit Promptly:</strong> Submit debug reports soon after issues occur for complete logs</li>
            </ul>
            
            <div style="padding: 15px; background-color: #fef2f2; border: 1px solid #fecaca; border-radius: 4px;">
                <strong style="color: #dc2626;"> Important Notes:</strong>
                <ul style="margin-top: 10px; margin-bottom: 0;">
                    <li>Debug logs are limited to 100 sessions to prevent storage overflow</li>
                    <li>Logs persist across browser sessions until manually cleared</li>
                    <li>If automatic submission fails, the system will fallback to manual download</li>
                    <li>For sensitive issues, you can review the debug export before sharing</li>
                </ul>
            </div>
            </div>
            <!-- End Debug Tab Content -->
        </div>
    </div>

    <!-- Disclaimer Modal -->
    <div id="disclaimerModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeDisclaimerModal()">&times;</span>
            <h2>Disclaimer</h2>
            
            <div style="margin-top: 20px; line-height: 1.6;">
                <h3 style="margin-bottom: 15px; color: #333;">Use at Your Own Risk</h3>
                <p style="margin-bottom: 15px;">
                    This wallet software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose, and non-infringement.
                </p>
                
                <h3 style="margin-bottom: 15px; color: #333;">No Liability</h3>
                <p style="margin-bottom: 15px;">
                    In no event shall the authors, developers, or copyright holders be liable for any claim, damages, or other liability, whether in an action of contract, tort, or otherwise, arising from, out of, or in connection with the software or the use or other dealings in the software.
                </p>
                
                <h3 style="margin-bottom: 15px; color: #333;">Your Responsibility</h3>
                <ul style="margin-bottom: 15px;">
                    <li><strong>Backup your keys:</strong> You are solely responsible for backing up your private keys and seed phrases</li>
                    <li><strong>Secure your device:</strong> Ensure your computer is free from malware and unauthorized access</li>
                    <li><strong>Verify transactions:</strong> Always double-check addresses and amounts before sending</li>
                    <li><strong>Test first:</strong> Consider testing with small amounts before large transactions</li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;">No Recovery Service</h3>
                <p style="margin-bottom: 15px;">
                    Lost private keys cannot be recovered. If you lose access to your private keys, you will permanently lose access to your funds. There is no password recovery or account recovery service.
                </p>
                
                <h3 style="margin-bottom: 15px; color: #333;">Experimental Features</h3>
                <p style="margin-bottom: 15px;">
                    Some features, particularly BIP32 wallet.dat import, are experimental and may not work with all wallet configurations. Always maintain backups before using experimental features.
                </p>
                
                <div style="padding: 15px; background-color: #fef2f2; border: 1px solid #fecaca; border-radius: 4px; margin-top: 20px;">
                    <strong style="color: #dc2626;">By using this wallet, you acknowledge that you understand and accept these terms.</strong>
                </div>
            </div>
        </div>
    </div>

    <!-- Security Notes Modal -->
    <div id="securityNotesModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeSecurityNotesModal()">&times;</span>
            <h2>Security Notes</h2>
            
            <div style="margin-top: 20px; line-height: 1.6;">
                <h3 style="margin-bottom: 15px; color: #333;"> Private Key Security</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>Never shared:</strong> Your private keys are never transmitted outside of your computer</li>
                    <li><strong>Local generation:</strong> All keys are generated locally using secure cryptographic functions</li>
                    <li><strong>Browser storage:</strong> Keys are stored within your browser's local storage (IndexedDB/localStorage)</li>
                    <li><strong>No server access:</strong> This wallet runs entirely in your browser - no server has access to your keys</li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;"> Wallet Storage</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>Browser-based:</strong> Wallet data is stored in your browser's local storage</li>
                    <li><strong>Encryption available:</strong> You can encrypt your wallet with a password for additional security</li>
                    <li><strong>Export formats:</strong> 
                        <ul style="margin-top: 5px;">
                            <li><strong>WIF format:</strong> Export private keys in Wallet Import Format for compatibility</li>
                            <li><strong>BIP32 format:</strong> Support for hierarchical deterministic wallets</li>
                            <li><strong>Text backup:</strong> Human-readable backup files with all wallet information</li>
                        </ul>
                    </li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;"> Best Security Practices</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>Offline usage:</strong> For maximum security, save this HTML file and use it on an air-gapped computer</li>
                    <li><strong>Regular backups:</strong> Export and securely store wallet backups in multiple locations</li>
                    <li><strong>Password protection:</strong> Always use a strong password when encrypting your wallet</li>
                    <li><strong>Verify source:</strong> Only use this wallet from trusted sources</li>
                    <li><strong>Clear browser data:</strong> Clear browser cache/storage when using on shared computers</li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;"> Security Warnings</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>Phishing:</strong> Always verify you're using the correct wallet URL/file</li>
                    <li><strong>Malware:</strong> Keep your computer free from viruses and keyloggers</li>
                    <li><strong>Browser extensions:</strong> Be cautious of browser extensions that might access page data</li>
                    <li><strong>Public computers:</strong> Never use this wallet on public or shared computers</li>
                </ul>
                
                <h3 style="margin-bottom: 15px; color: #333;"> Supported Formats</h3>
                <ul style="margin-bottom: 20px;">
                    <li><strong>WIF (Wallet Import Format):</strong> Standard format for importing/exporting private keys</li>
                    <li><strong>BIP32/BIP44:</strong> Hierarchical deterministic wallet with multiple address derivation</li>
                    <li><strong>BIP32 wallet.dat:</strong> Import support for BIP32 hierarchical deterministic wallet files (experimental)</li>
                    <li><strong>Encrypted backups:</strong> AES-encrypted wallet files with PBKDF2 key derivation</li>
                </ul>
                
                <div style="padding: 15px; background-color: #f0f9ff; border: 1px solid #bfdbfe; border-radius: 4px; margin-top: 20px;">
                    <strong style="color: #1e40af;">Remember:</strong> You are your own bank. With great power comes great responsibility. Always prioritize security and never share your private keys with anyone.
                </div>
            </div>
        </div>
    </div>
    
    <!-- Transaction Debug Modal -->
    <div id="transactionDebugModal" style="display: none; position: fixed; z-index: 10001; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5);">
        <div style="position: relative; background-color: white; margin: 2% auto; padding: 20px; border-radius: 8px; width: 90%; max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <span onclick="closeTransactionDebugModal()" style="position: absolute; right: 15px; top: 15px; font-size: 28px; font-weight: bold; cursor: pointer; color: #999;">&times;</span>
            <h2 style="margin-bottom: 20px; color: #2563eb;">Transaction Debug Information</h2>
            
            <!-- Security Notice -->
            <div style="padding: 10px; background-color: #f0f9ff; border: 1px solid #3b82f6; border-radius: 4px; margin-bottom: 15px;">
                <strong style="color: #1e40af;"> Security Notice:</strong> This debug log does NOT contain any private keys or sensitive wallet data. All private information is automatically sanitized before logging. The transaction hex data shown is safe to share - it contains only signed transactions that become public when broadcast.
            </div>
            
            <div id="debugContent">
                <!-- Debug tabs -->
                <div style="display: flex; gap: 5px; margin-bottom: 20px; border-bottom: 2px solid #e5e7eb;">
                    <button onclick="showDebugTab('summary')" class="debug-tab-btn active" style="padding: 10px 20px; background: none; border: none; cursor: pointer; font-weight: 600; color: #2563eb; border-bottom: 3px solid #2563eb;" data-tab="summary">Summary</button>
                    <button onclick="showDebugTab('logs')" class="debug-tab-btn" style="padding: 10px 20px; background: none; border: none; cursor: pointer; font-weight: 600; color: #6b7280; border-bottom: 3px solid transparent;" data-tab="logs">Logs</button>
                    <button onclick="showDebugTab('errors')" class="debug-tab-btn" style="padding: 10px 20px; background: none; border: none; cursor: pointer; font-weight: 600; color: #6b7280; border-bottom: 3px solid transparent;" data-tab="errors">Errors</button>
                    <button onclick="showDebugTab('history')" class="debug-tab-btn" style="padding: 10px 20px; background: none; border: none; cursor: pointer; font-weight: 600; color: #6b7280; border-bottom: 3px solid transparent;" data-tab="history">History</button>
                </div>
                
                <!-- Debug tab contents -->
                <div id="modalDebugTabContent">
                    <!-- Content will be dynamically inserted here -->
                </div>
            </div>
            
            <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: space-between;">
                <button onclick="showFailedTransactions()" style="padding: 10px 20px; background-color: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Show Failed TXs</button>
                <div style="display: flex; gap: 10px;">
                    <button onclick="submitDebugReport()" style="padding: 10px 20px; background-color: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;"> Submit Report</button>
                    <button onclick="exportDebugLog()" style="padding: 10px 20px; background-color: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Export Debug Log</button>
                    <button onclick="clearDebugLog()" style="padding: 10px 20px; background-color: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Clear Logs</button>
                    <button onclick="closeTransactionDebugModal()" style="padding: 10px 20px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Debug modal functions
        window.showTransactionDebugModal = function(sessionId) {
            console.log('[DEBUG] showTransactionDebugModal called with sessionId:', sessionId);
            console.log('[DEBUG] window.transactionDebugLog:', window.transactionDebugLog);

            const modal = document.getElementById('transactionDebugModal');
            if (!modal) {
                console.error('[DEBUG] Transaction debug modal not found');
                return;
            }

            // Find the session or default behavior
            if (sessionId) {
                const session = window.transactionDebugLog.find(s => s.id === sessionId);
                console.log('[DEBUG] Found session by ID:', session);
                window.currentTransactionDebug = session || null;
                modal.style.display = 'block';
                showDebugTab('summary');
            } else {
                console.log('[DEBUG] No sessionId provided. transactionDebugLog length:', window.transactionDebugLog.length);
                // No session specified - auto-select most recent or show history
                if (window.transactionDebugLog.length > 0) {
                    // Auto-select the most recent session
                    window.currentTransactionDebug = window.transactionDebugLog[window.transactionDebugLog.length - 1];
                    console.log('[DEBUG] Auto-selected most recent session:', window.currentTransactionDebug);
                    modal.style.display = 'block';
                    showDebugTab('summary');
                } else {
                    // No sessions available - show history tab (will display empty state)
                    console.log('[DEBUG] No sessions available, showing history tab');
                    window.currentTransactionDebug = null;
                    modal.style.display = 'block';
                    showDebugTab('history');
                }
            }
        }
        
        window.closeTransactionDebugModal = function() {
            const modal = document.getElementById('transactionDebugModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        window.showDebugTab = function(tabName) {
            console.log('[DEBUG] showDebugTab called with:', tabName);
            console.log('[DEBUG] transactionDebugLog length:', window.transactionDebugLog ? window.transactionDebugLog.length : 'undefined');
            console.log('[DEBUG] currentTransactionDebug:', window.currentTransactionDebug);

            // Update tab buttons
            document.querySelectorAll('.debug-tab-btn').forEach(btn => {
                btn.style.color = '#6b7280';
                btn.style.borderBottom = '3px solid transparent';
            });

            const activeBtn = document.querySelector(`.debug-tab-btn[data-tab="${tabName}"]`);
            if (activeBtn) {
                activeBtn.style.color = '#2563eb';
                activeBtn.style.borderBottom = '3px solid #2563eb';
            }

            // Update content
            const contentDiv = document.getElementById('modalDebugTabContent');
            if (!contentDiv) {
                console.error('[DEBUG] modalDebugTabContent div not found!');
                return;
            }
            
            let content = '';

            switch(tabName) {
                case 'summary':
                    content = generateDebugSummary();
                    break;
                case 'logs':
                    content = generateDebugLogs();
                    break;
                case 'errors':
                    content = generateDebugErrors();
                    break;
                case 'history':
                    content = generateDebugHistory();
                    break;
            }

            console.log('[DEBUG] Generated content length:', content ? content.length : 0);
            console.log('[DEBUG] Content preview:', content ? content.substring(0, 100) : 'empty');
            contentDiv.innerHTML = content;
        }
        
        function generateDebugSummary() {
            if (!window.currentTransactionDebug) {
                return '<p style="color: #6b7280;">No debug session selected. Click the Debug button to view all sessions.</p>';
            }
            
            const session = window.currentTransactionDebug;
            const errorCount = session.logs ? session.logs.filter(l => l.level === 'error' || l.level === 'critical').length : 0;
            const warningCount = session.logs ? session.logs.filter(l => l.level === 'warning').length : 0;
            
            return `
                <div style="padding: 20px; background-color: #f9fafb; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px;">Session Summary</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <strong>Session ID:</strong> <code>${session.id}</code><br>
                            <strong>Operation:</strong> ${session.operation}<br>
                            <strong>Status:</strong> <span style="color: ${session.status === 'error' ? '#dc2626' : session.status === 'completed' ? '#10b981' : '#f59e0b'};">${session.status}</span><br>
                        </div>
                        <div>
                            <strong>Start Time:</strong> ${session.startTime}<br>
                            <strong>End Time:</strong> ${session.endTime || 'In progress'}<br>
                            <strong>Total Logs:</strong> ${session.logs ? session.logs.length : 0}<br>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <strong>Log Summary:</strong><br>
                        Errors: ${errorCount} | Warnings: ${warningCount} | Info: ${session.logs ? session.logs.filter(l => l.level === 'info').length : 0}
                    </div>
                </div>
            `;
        }
        
        function generateDebugLogs() {
            if (!window.currentTransactionDebug || !window.currentTransactionDebug.logs) {
                return '<p style="color: #6b7280;">No logs available for this session</p>';
            }
            
            let html = '<div style="max-height: 500px; overflow-y: auto; padding: 10px;">';
            
            window.currentTransactionDebug.logs.forEach((log, index) => {
                const levelColor = {
                    'critical': '#dc2626',
                    'error': '#ef4444',
                    'warning': '#f59e0b',
                    'info': '#3b82f6',
                    'success': '#10b981',
                    'debug': '#6b7280'
                }[log.level] || '#6b7280';
                
                html += `
                    <div style="margin-bottom: 15px; padding: 10px; background-color: white; border-left: 4px solid ${levelColor}; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <strong style="color: ${levelColor};">[${log.level.toUpperCase()}]</strong>
                            <span style="font-size: 11px; color: #9ca3af;">${log.timestamp}</span>
                        </div>
                        <div style="margin-bottom: 5px;">${log.message}</div>
                        ${log.data && Object.keys(log.data).length > 0 ? `
                            <details style="margin-top: 5px;">
                                <summary style="cursor: pointer; font-size: 12px; color: #6b7280;">Data</summary>
                                <pre style="margin-top: 5px; padding: 5px; background-color: #f3f4f6; border-radius: 4px; font-size: 11px; overflow-x: auto;">${JSON.stringify(log.data, null, 2)}</pre>
                            </details>
                        ` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }
        
        function generateDebugErrors() {
            if (!window.currentTransactionDebug || !window.currentTransactionDebug.logs) {
                return '<p style="color: #6b7280;">No logs available</p>';
            }
            
            const errors = window.currentTransactionDebug.logs.filter(l => l.level === 'error' || l.level === 'critical');
            
            if (errors.length === 0) {
                return '<p style="color: #10b981; padding: 20px;"> No errors found in this session</p>';
            }
            
            let html = '<div style="padding: 10px;">';
            errors.forEach(error => {
                html += `
                    <div style="margin-bottom: 15px; padding: 15px; background-color: #fef2f2; border: 1px solid #fecaca; border-radius: 4px;">
                        <strong style="color: #dc2626;">${error.message}</strong><br>
                        <span style="font-size: 11px; color: #9ca3af;">${error.timestamp}</span>
                        ${error.data ? `<pre style="margin-top: 10px; font-size: 11px; background-color: white; padding: 10px; border-radius: 4px;">${JSON.stringify(error.data, null, 2)}</pre>` : ''}
                    </div>
                `;
            });
            html += '</div>';
            return html;
        }
        
        function generateDebugHistory() {
            if (window.transactionDebugLog.length === 0) {
                return `
                    <div style="padding: 40px; text-align: center; color: #6b7280;">
                        <div style="font-size: 48px; margin-bottom: 15px;"></div>
                        <h3 style="color: #374151; margin-bottom: 10px;">No Debug History Yet</h3>
                        <p style="margin-bottom: 20px;">Debug information will appear here after you perform transactions.</p>
                        <p style="font-size: 14px; color: #9ca3af;">Try sending ALPHA to an address to generate debug logs.</p>
                    </div>
                `;
            }
            
            let html = '<div style="padding: 10px; max-height: 500px; overflow-y: auto;">';
            
            // Show recent sessions
            const recentSessions = [...window.transactionDebugLog].reverse().slice(0, 20);
            
            recentSessions.forEach(session => {
                const errorCount = session.logs ? session.logs.filter(l => l.level === 'error' || l.level === 'critical').length : 0;
                const statusColor = session.status === 'error' ? '#dc2626' : session.status === 'completed' ? '#10b981' : '#f59e0b';
                
                html += `
                    <div style="margin-bottom: 10px; padding: 10px; background-color: white; border: 1px solid #e5e7eb; border-radius: 4px; cursor: pointer;"
                         onclick="window.currentTransactionDebug = window.transactionDebugLog.find(s => s.id === '${session.id}'); showDebugTab('summary');">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${session.operation}</strong>
                                <span style="margin-left: 10px; color: ${statusColor};"></span>
                                <span style="color: ${statusColor}; font-size: 12px;">${session.status}</span>
                                ${errorCount > 0 ? `<span style="margin-left: 10px; color: #dc2626; font-size: 12px;">${errorCount} errors</span>` : ''}
                            </div>
                            <div style="font-size: 11px; color: #9ca3af;">
                                ${session.startTime}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            return html;
        }
        
        window.exportDebugLog = function() {
            // Prepare debug data with transaction hex for easy import
            const exportData = {
                exportTime: new Date().toISOString(),
                walletVersion: '0.3.0',
                sessions: transactionDebugLog.map(session => {
                    // Extract transaction hex from logs
                    const transactions = [];
                    if (session.logs) {
                        session.logs.forEach(log => {
                            if (log.data && log.data.hex) {
                                transactions.push({
                                    txid: log.data.txid || 'unknown',
                                    hex: log.data.hex,
                                    timestamp: log.timestamp,
                                    status: log.level,
                                    message: log.message,
                                    details: log.data.details || null,
                                    error: log.data.error || null
                                });
                            }
                        });
                    }
                    
                    return {
                        ...session,
                        extractedTransactions: transactions
                    };
                }),
                currentSession: currentTransactionDebug,
                
                // Add a convenient import format for developers
                readyToImport: transactionDebugLog.reduce((acc, session) => {
                    if (session.logs) {
                        session.logs.forEach(log => {
                            if (log.data && log.data.hex && (log.level === 'error' || log.level === 'info')) {
                                acc.push({
                                    txid: log.data.txid || 'unknown',
                                    hex: log.data.hex,
                                    sessionId: session.id,
                                    operation: session.operation,
                                    timestamp: log.timestamp,
                                    error: log.data.error || null,
                                    attempts: log.data.attempts || 1,
                                    details: log.data.details || null
                                });
                            }
                        });
                    }
                    return acc;
                }, []),
                
                // Add instructions for developers
                developerInstructions: {
                    description: 'This debug export contains all transaction attempts with their raw hex data',
                    howToTest: [
                        '1. Look for transactions in readyToImport array',
                        '2. Each transaction has a hex field that can be broadcast',
                        '3. Use alpha-cli sendrawtransaction <hex> to test broadcast',
                        '4. Check error field for previous failure reasons',
                        '5. Review session logs for complete debugging context'
                    ],
                    fields: {
                        hex: 'Raw transaction hex ready for broadcast',
                        txid: 'Transaction ID',
                        error: 'Error message if broadcast failed',
                        details: 'Transaction construction details (inputs/outputs)',
                        sessionId: 'Debug session ID for cross-reference'
                    },
                    securityNote: 'NO PRIVATE KEYS ARE INCLUDED IN THIS EXPORT. All sensitive data has been sanitized. Transaction hex contains only signed data that is already public once broadcast.'
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `transaction-debug-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showInAppNotification('Debug Log Exported', 'Transaction debug log has been exported', 'success');
        }
        
        window.clearDebugLog = function() {
            if (confirm('Are you sure you want to clear all transaction debug logs?')) {
                transactionDebugLog = [];
                currentTransactionDebug = null;
                localStorage.removeItem('transactionDebugLog');
                showInAppNotification('Debug Log Cleared', 'All transaction debug logs have been cleared', 'info');
                closeTransactionDebugModal();
            }
        }
        
        // Submit debug report to service
        window.submitDebugReport = async function() {
            if (transactionDebugLog.length === 0) {
                showInAppNotification('No Debug Data', 'No debug sessions to submit', 'warning');
                return;
            }
            
            // Prepare report with failed transactions extracted
            const failedTxs = [];
            transactionDebugLog.forEach(session => {
                if (session.status === 'failed' && session.logs) {
                    session.logs.forEach(log => {
                        if ((log.level === 'error' || log.level === 'critical') && log.data && log.data.hex) {
                            if (!failedTxs.find(tx => tx.txid === log.data.txid)) {
                                failedTxs.push({
                                    raw: log.data.hex,
                                    txid: log.data.txid || 'unknown',
                                    details: log.data.details || null
                                });
                            }
                        }
                    });
                }
            });
            
            const report = {
                sessions: transactionDebugLog,
                readyToImport: failedTxs,
                metadata: {
                    walletVersion: 'v0.5.0',
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    totalSessions: transactionDebugLog.length,
                    failedSessions: transactionDebugLog.filter(s => s.status === 'failed').length,
                    failedTransactionCount: failedTxs.length
                }
            };
            
            try {
                // Try to submit to the debug service
                const response = await fetch('https://unicity-debug-report.dyndns.org:3487/api/submit-report', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(report)
                });
                
                // Check if response is ok before trying to parse JSON
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server returned error:', response.status, errorText);
                    throw new Error(`Server error: ${response.status}`);
                }
                
                // Try to parse JSON response
                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    console.error('Failed to parse response as JSON:', jsonError);
                    // If we got here, the request succeeded but response isn't JSON
                    // This might mean it actually succeeded
                    showInAppNotification('Report Submitted', 
                        'Debug report appears to have been submitted (check server logs)', 
                        'info');
                    return;
                }
                
                if (result.success) {
                    showInAppNotification('Report Submitted', 
                        `Debug report submitted successfully. Report ID: ${result.reportId}`, 
                        'success');
                    
                    // Optionally clear the debug log after successful submission
                    if (confirm('Clear local debug log after successful submission?')) {
                        window.transactionDebugLog = [];
                        localStorage.setItem('walletDebugSessions', JSON.stringify(window.transactionDebugLog));
                        if (typeof updateDebugStatus === 'function') {
                            updateDebugStatus();
                        }
                    }
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                console.error('Failed to submit debug report:', error);
                
                // Check if it's a network error (CORS, connection refused, etc)
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    // This is likely a CORS or network issue
                    // Try alternative submission method or check if actually succeeded
                    console.log('Network error - this might be a CORS issue. The report may have been submitted successfully.');
                    showInAppNotification('Network Issue', 
                        'Could not confirm submission due to network/CORS. Check the debug service to see if report was received.', 
                        'warning');
                } else {
                    // Other error - fallback to download
                    showInAppNotification('Submission Failed', 
                        'Could not submit to debug service. Downloading report instead...', 
                        'warning');
                }
                
                // Download as fallback
                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `debug-report-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }
        
        window.showFailedTransactions = function() {
            // Extract all failed transactions with hex data
            const failedTxs = [];
            
            transactionDebugLog.forEach(session => {
                if (session.logs) {
                    session.logs.forEach(log => {
                        if ((log.level === 'error' || log.level === 'critical') && log.data && log.data.hex) {
                            failedTxs.push({
                                sessionId: session.id,
                                timestamp: log.timestamp,
                                txid: log.data.txid || 'unknown',
                                hex: log.data.hex,
                                error: log.data.error || log.message,
                                size: log.data.hex.length / 2,
                                details: log.data.details || null
                            });
                        }
                    });
                }
            });
            
            if (failedTxs.length === 0) {
                showInAppNotification('No Failed Transactions', 'No failed transactions with hex data found in debug log', 'info');
                return;
            }
            
            // Create modal to show failed transactions
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; z-index: 10002; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5);';
            
            let content = `
                <div style="position: relative; background-color: white; margin: 5% auto; padding: 20px; border-radius: 8px; width: 90%; max-width: 900px; max-height: 80vh; overflow-y: auto;">
                    <span onclick="this.closest('[style*=\\"z-index: 10002\\"]').remove()" style="position: absolute; right: 15px; top: 15px; font-size: 28px; font-weight: bold; cursor: pointer; color: #999;">&times;</span>
                    <h2 style="margin-bottom: 20px; color: #dc2626;">Failed Transactions (${failedTxs.length})</h2>
                    <p style="margin-bottom: 20px; color: #6b7280;">These transactions failed to broadcast. You can copy the hex and try broadcasting manually.</p>
            `;
            
            failedTxs.forEach((tx, index) => {
                content += `
                    <div style="margin-bottom: 20px; padding: 15px; background-color: #fef2f2; border: 1px solid #fecaca; border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <strong>Transaction ${index + 1}</strong><br>
                                <span style="font-size: 12px; color: #6b7280;">TXID: ${tx.txid}</span><br>
                                <span style="font-size: 12px; color: #6b7280;">Size: ${tx.size} bytes</span><br>
                                <span style="font-size: 12px; color: #6b7280;">Time: ${tx.timestamp}</span>
                            </div>
                            <button onclick="copyToClipboard('${tx.hex}')" style="padding: 6px 12px; background-color: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Copy Hex</button>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong style="color: #dc2626;">Error:</strong> ${tx.error}
                        </div>
                        <details style="margin-top: 10px;">
                            <summary style="cursor: pointer; color: #3b82f6;">Show Transaction Hex</summary>
                            <div style="margin-top: 10px; padding: 10px; background-color: white; border-radius: 4px; word-break: break-all; font-family: monospace; font-size: 11px; max-height: 200px; overflow-y: auto;">
                                ${tx.hex}
                            </div>
                        </details>
                        <div style="margin-top: 10px; padding: 10px; background-color: #f3f4f6; border-radius: 4px;">
                            <strong>To broadcast manually:</strong><br>
                            <code style="font-size: 11px;">alpha-cli sendrawtransaction "${tx.hex}"</code>
                        </div>
                    </div>
                `;
            });
            
            content += `
                    <div style="margin-top: 20px; padding: 15px; background-color: #f0f9ff; border: 1px solid #bfdbfe; border-radius: 4px;">
                        <strong style="color: #1e40af;">Options to retry:</strong><br>
                        <ol style="margin: 10px 0 0 20px; font-size: 14px;">
                            <li><strong>Using This Wallet:</strong> Click "Export for Wallet Broadcast"  Save the JSON file  Click the "Broadcast" button in the wallet  Select the saved file</li>
                            <li><strong>Using alpha-cli:</strong> Copy the transaction hex and run: <code>alpha-cli sendrawtransaction "&lt;hex&gt;"</code></li>
                            <li><strong>For Developers:</strong> Export all failed transactions to test them programmatically</li>
                        </ol>
                    </div>
                    <div style="margin-top: 20px; display: flex; justify-content: space-between; align-items: center;">
                        <button onclick="retryAllFailedInWallet()" style="padding: 10px 20px; background-color: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Retry All in Wallet</button>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="exportFailedForWalletBroadcast()" style="padding: 10px 20px; background-color: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer;">Export for Wallet Broadcast</button>
                            <button onclick="exportFailedTransactions()" style="padding: 10px 20px; background-color: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">Export for Developers</button>
                            <button onclick="this.closest('[style*=\\"z-index: 10002\\"]').remove()" style="padding: 10px 20px; background-color: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            modal.innerHTML = content;
            document.body.appendChild(modal);
        }
        
        window.copyToClipboard = function(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            showInAppNotification('Copied', 'Transaction hex copied to clipboard', 'success');
        }
        
        window.exportFailedTransactions = function() {
            const failedTxs = [];
            
            transactionDebugLog.forEach(session => {
                if (session.logs) {
                    session.logs.forEach(log => {
                        if ((log.level === 'error' || log.level === 'critical') && log.data && log.data.hex) {
                            failedTxs.push({
                                txid: log.data.txid || 'unknown',
                                hex: log.data.hex,
                                error: log.data.error || log.message,
                                timestamp: log.timestamp,
                                sessionId: session.id,
                                details: log.data.details || null
                            });
                        }
                    });
                }
            });
            
            const exportData = {
                exportTime: new Date().toISOString(),
                failedTransactions: failedTxs,
                instructions: {
                    broadcast: 'Use: alpha-cli sendrawtransaction <hex>',
                    testnet: 'For testnet: alpha-cli -testnet sendrawtransaction <hex>',
                    notes: 'Each transaction hex can be broadcast independently'
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `failed-transactions-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showInAppNotification('Export Complete', `Exported ${failedTxs.length} failed transactions`, 'success');
        }
        
        // Export failed transactions in wallet broadcast format
        window.exportFailedForWalletBroadcast = function() {
            const failedTxs = [];
            
            transactionDebugLog.forEach(session => {
                if (session.logs) {
                    session.logs.forEach(log => {
                        if ((log.level === 'error' || log.level === 'critical') && log.data && log.data.hex) {
                            // Only add unique transactions (by txid)
                            if (!failedTxs.find(tx => tx.txid === log.data.txid)) {
                                failedTxs.push({
                                    raw: log.data.hex,
                                    txid: log.data.txid || 'unknown',
                                    details: log.data.details || null
                                });
                            }
                        }
                    });
                }
            });
            
            if (failedTxs.length === 0) {
                showInAppNotification('No Transactions', 'No failed transactions to export', 'warning');
                return;
            }
            
            // Format in the same way the wallet exports for broadcast
            const exportData = {
                network: 'alpha',
                transactions: failedTxs,
                timestamp: new Date().toISOString(),
                type: 'failed_retry',
                description: 'Failed transactions ready for retry broadcast'
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `retry-transactions-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showInAppNotification('Export Ready', `Exported ${failedTxs.length} transactions. Use the Broadcast button to import this file.`, 'success');
            
            // Close the failed transactions modal
            const modal = document.querySelector('[style*="z-index: 10002"]');
            if (modal) modal.remove();
        }
        
        // Retry all failed transactions directly in wallet
        window.retryAllFailedInWallet = function() {
            const failedTxs = [];
            
            transactionDebugLog.forEach(session => {
                if (session.logs) {
                    session.logs.forEach(log => {
                        if ((log.level === 'error' || log.level === 'critical') && log.data && log.data.hex) {
                            // Only add unique transactions (by txid)
                            if (!failedTxs.find(tx => tx.txid === log.data.txid)) {
                                failedTxs.push({
                                    raw: log.data.hex,
                                    txid: log.data.txid || 'unknown',
                                    details: log.data.details || null
                                });
                            }
                        }
                    });
                }
            });
            
            if (failedTxs.length === 0) {
                showInAppNotification('No Transactions', 'No failed transactions to retry', 'warning');
                return;
            }
            
            // Check if we're online
            if (!electrumSocket || electrumSocket.readyState !== WebSocket.OPEN) {
                showInAppNotification('Not Connected', 'Please connect to Fulcrum server first to retry broadcasts', 'warning');
                return;
            }
            
            // Close the modal
            const modal = document.querySelector('[style*="z-index: 10002"]');
            if (modal) modal.remove();
            
            // Confirm retry
            if (confirm(`Retry broadcasting ${failedTxs.length} failed transaction(s)?`)) {
                // Start new debug session for retry
                const retryDebug = startTransactionDebug('retry_failed_transactions');
                retryDebug.log('info', `Retrying ${failedTxs.length} failed transactions`);
                
                // Add to broadcast queue
                broadcastTransactions(failedTxs);
                
                showInAppNotification('Retrying Transactions', `Added ${failedTxs.length} transaction(s) to broadcast queue`, 'info');
            }
        }
    </script>
    
    <!-- Debug Button (always visible) -->
    <button id="debugButton" onclick="showTransactionDebugModal()" style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 24px;
        background-color: #6b7280;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        z-index: 1000;
        font-weight: 600;
        font-size: 16px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.2s;
    " onmouseover="this.style.backgroundColor='#4b5563'" onmouseout="this.style.backgroundColor='#6b7280'">
         Debug
    </button>

</body>
</html>